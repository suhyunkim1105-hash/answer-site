<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>answer-site | Remote</title>
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/11.1.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/11.1.0/firebase-database-compat.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 10px;
      background: #050505;
      color: #f5f5f5;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      font-size: 14px;
    }
    .wrap {
      max-width: 820px;
      margin: 0 auto;
    }

    /* 상단 모드 버튼 */
    .mode-bar {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }
    .mode-btn {
      flex: 1 1 0;
      padding: 8px 0;
      border-radius: 16px;
      border: 1px solid #444;
      background: #111;
      color: #ddd;
      font-size: 13px;
      text-align: center;
      cursor: pointer;
    }
    .mode-btn.active {
      background: #1e90ff;
      border-color: #1e90ff;
      color: #fff;
      font-weight: 600;
    }

    /* 답 영역 */
    #sectionInfo {
      font-size: 12px;
      color: #aaa;
      margin-bottom: 4px;
    }

    #answerMain {
      padding: 10px 12px;
      border-radius: 10px;
      background: #101010;
      border: 1px solid #333;
      min-height: 40px;
      font-size: 18px;
      font-weight: 600;
      white-space: pre-wrap;
      margin-bottom: 4px;
    }

    #answerMeta {
      font-size: 11px;
      color: #88c0ff;
      margin-bottom: 8px;
      white-space: pre-wrap;
    }

    #answerRaw {
      padding: 8px 10px;
      border-radius: 8px;
      background: #080808;
      border: 1px solid #222;
      font-size: 12px;
      max-height: 180px;
      overflow-y: auto;
      white-space: pre-wrap;
    }

    /* 디버그 토글 & 패널 */
    #debugToggle {
      margin-top: 10px;
      padding: 4px 10px;
      font-size: 11px;
      border-radius: 999px;
      border: 1px solid #444;
      background: #111;
      color: #ddd;
      cursor: pointer;
    }
    #debugPanel {
      margin-top: 6px;
      padding: 8px;
      border-radius: 8px;
      background: #050505;
      border: 1px solid #333;
      display: none;
    }
    #debugPanel h4 {
      margin: 4px 0;
      font-size: 11px;
      color: #9ad;
    }
    .debug-block {
      margin-bottom: 6px;
    }
    .debug-pre {
      max-height: 120px;
      overflow-y: auto;
      padding: 4px 6px;
      border-radius: 4px;
      background: #000;
      border: 1px solid #222;
      font-size: 11px;
      white-space: pre-wrap;
    }
    #debugStatus {
      font-size: 11px;
      color: #ccc;
      margin-top: 4px;
    }

    /* 하단 버튼들 */
    .bottom-buttons {
      margin-top: 10px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .btn-primary {
      width: 100%;
      padding: 10px 0;
      font-size: 15px;
      border-radius: 999px;
      border: none;
      background: #1e90ff;
      color: #fff;
      font-weight: 600;
      cursor: pointer;
    }
    .btn-primary:active {
      transform: scale(0.98);
    }
    .btn-secondary {
      width: 100%;
      padding: 8px 0;
      font-size: 13px;
      border-radius: 999px;
      border: 1px solid #444;
      background: #111;
      color: #ddd;
      cursor: pointer;
    }
    .btn-secondary:active {
      transform: scale(0.98);
    }

    #globalStatus {
      margin-top: 6px;
      font-size: 11px;
      color: #bbb;
    }
  </style>
</head>
<body>
<div class="wrap">
  <!-- 모드 선택 -->
  <div class="mode-bar">
    <button class="mode-btn active"   data-mode="reading">Reading</button>
    <button class="mode-btn"          data-mode="listening">Listening</button>
    <button class="mode-btn"          data-mode="writing">Writing</button>
    <button class="mode-btn"          data-mode="speaking">Speaking</button>
  </div>

  <div id="sectionInfo">섹션: reading · 확신도: -</div>

  <!-- 답 영역 -->
  <div id="answerMain">아직 풀이 전입니다.</div>
  <div id="answerMeta"></div>
  <pre id="answerRaw"></pre>

  <!-- 디버그 -->
  <button id="debugToggle">디버그 보기 토글 (OCR/음성/지문)</button>
  <div id="debugPanel">
    <div class="debug-block">
      <h4>OCR 텍스트 (현재 화면)</h4>
      <pre id="debugOcrCurrent" class="debug-pre"></pre>
    </div>
    <div class="debug-block">
      <h4>지문 텍스트 (누적)</h4>
      <pre id="debugOcrAccum" class="debug-pre"></pre>
    </div>
    <div class="debug-block">
      <h4>음성 텍스트 (STT)</h4>
      <pre id="debugSttText" class="debug-pre"></pre>
    </div>
    <div class="debug-block">
      <h4>AI 원문 응답</h4>
      <pre id="debugAiRaw" class="debug-pre"></pre>
    </div>
    <div id="debugStatus"></div>
  </div>

  <!-- 하단 버튼 -->
  <div class="bottom-buttons">
    <button id="btnSolve" class="btn-primary">이 질문 풀기</button>
    <button id="btnResetListening" class="btn-secondary">리스닝 세트 초기화</button>
    <button id="btnSttToggle" class="btn-secondary">
      음성 인식 시작 (Listening/Speaking)
    </button>
  </div>

  <div id="globalStatus"></div>
</div>

<script>
  // ------------ Firebase ------------
  const firebaseConfig = {
    apiKey: "AIzaSyAvjpHfmbuHQq3ZeV6mNKQFI9LsnX-vf68",
    authDomain: "answer-site-p2p.firebaseapp.com",
    databaseURL: "https://answer-site-p2p-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "answer-site-p2p",
    storageBucket: "answer-site-p2p.firebasestorage.app",
    messagingSenderId: "364227113735",
    appId: "1:364227113735:web:b18355cf0b16454663cba2",
    measurementId: "G-C8MRHK5ZGS"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();
  const stateRef   = db.ref("p2p/state");
  const commandRef = db.ref("p2p/command");

  // ------------ DOM 요소 ------------
  const modeButtons      = document.querySelectorAll(".mode-btn");
  const sectionInfoSpan  = document.getElementById("sectionInfo");
  const answerMainEl     = document.getElementById("answerMain");
  const answerMetaEl     = document.getElementById("answerMeta");
  const answerRawEl      = document.getElementById("answerRaw");

  const debugToggleBtn   = document.getElementById("debugToggle");
  const debugPanel       = document.getElementById("debugPanel");
  const debugOcrCurrent  = document.getElementById("debugOcrCurrent");
  const debugOcrAccum    = document.getElementById("debugOcrAccum");
  const debugSttText     = document.getElementById("debugSttText");
  const debugAiRaw       = document.getElementById("debugAiRaw");
  const debugStatus      = document.getElementById("debugStatus");

  const btnSolve         = document.getElementById("btnSolve");
  const btnResetListening= document.getElementById("btnResetListening");
  const btnSttToggle     = document.getElementById("btnSttToggle");
  const globalStatus     = document.getElementById("globalStatus");

  // ------------ 상태 변수 ------------
  let currentMode      = "reading";
  let lastOcrText      = "";
  let accumulatedText  = ""; // 리딩/리스닝 지문 누적
  let lastOcrUpdatedAt = 0;

  let sttSupported     = false;
  let sttRecognition   = null;
  let sttActive        = false;
  let sttFinalText     = "";
  let sttRestartPlanned= false;

  let solving          = false;
  let pendingSolve     = false;
  let lastCommandTs    = 0;

  // ------------ 모드 전환 ------------
  function updateModeUI() {
    modeButtons.forEach(btn => {
      const m = btn.getAttribute("data-mode");
      btn.classList.toggle("active", m === currentMode);
    });
    let sectionLabel = currentMode;
    sectionInfoSpan.textContent = `섹션: ${sectionLabel} · 확신도: -`;
  }

  modeButtons.forEach(btn => {
    btn.addEventListener("click", () => {
      const newMode = btn.getAttribute("data-mode");
      if (currentMode === newMode) return;
      currentMode = newMode;
      updateModeUI();
      stateRef.update({ modeHint: currentMode });
    });
  });

  // ------------ 디버그 토글 ------------
  debugToggleBtn.addEventListener("click", () => {
    debugPanel.style.display =
      debugPanel.style.display === "none" || debugPanel.style.display === ""
        ? "block" : "none";
  });

  // ------------ Firebase 상태 구독 ------------
  stateRef.on("value", snap => {
    const state = snap.val() || {};
    const ocrText = state.ocrText || "";
    const ocrConf = typeof state.ocrConfidence === "number"
      ? state.ocrConfidence.toFixed(1) + "%"
      : "-";
    const audioText = state.audioText || "";
    const cameraBlocked = state.cameraBlocked ? "가려짐" : "정상";

    // 현재 OCR
    lastOcrText = ocrText;
    lastOcrUpdatedAt = state.ocrUpdatedAt || 0;
    debugOcrCurrent.textContent = ocrText || "(없음)";

    // 누적 지문(리딩/리스닝)
    if (ocrText) {
      // 아주 단순: 같은 스니펫이 아니면 계속 이어 붙이기
      const snippet = ocrText.slice(0, 200);
      if (!accumulatedText.includes(snippet)) {
        accumulatedText = (accumulatedText + "\n" + ocrText).trim();
      }
    }
    debugOcrAccum.textContent = accumulatedText || "(없음)";

    // STT
    if (!sttFinalText && audioText) {
      // 외부에서 이미 채워진 경우(혹시)
      sttFinalText = audioText;
    }
    debugSttText.textContent = sttFinalText || audioText || "(없음)";

    // 상태 표시
    const secLabel = currentMode;
    sectionInfoSpan.textContent =
      `섹션: ${secLabel} · OCR: conf=${ocrConf} · 카메라 상태: ${cameraBlocked}`;
  });

  // ------------ solve 트리거 (카메라에서) ------------
  commandRef.on("value", snap => {
    const cmd = snap.val();
    if (!cmd || cmd.type !== "solve" || !cmd.timestamp) return;
    if (cmd.timestamp === lastCommandTs) return;
    lastCommandTs = cmd.timestamp;
    // 카메라에서 온 자동 트리거 → 지금 풀기
    runSolve("auto");
  });

  // ------------ STT 초기화 ------------
  function initSTT() {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
      sttSupported = false;
      btnSttToggle.textContent = "브라우저에서 음성 인식 미지원";
      btnSttToggle.disabled = true;
      return;
    }
    sttSupported = true;
    sttRecognition = new SpeechRecognition();
    sttRecognition.lang = "en-US";
    sttRecognition.interimResults = true;
    sttRecognition.continuous = true;

    sttRecognition.onresult = (event) => {
      let interim = "";
      for (let i = event.resultIndex; i < event.results.length; i++) {
        const res = event.results[i];
        const txt = res[0].transcript;
        if (res.isFinal) {
          sttFinalText += (sttFinalText ? " " : "") + txt.trim();
        } else {
          interim += txt;
        }
      }
      const display = sttFinalText + (interim ? " [" + interim + "]" : "");
      debugSttText.textContent = display || "(없음)";

      // Firebase에 최종 텍스트 업데이트 (너무 자주 쓰지 않게 조금 조건)
      if (sttFinalText && sttFinalText.length % 20 < 5) {
        stateRef.update({
          audioText: sttFinalText,
          audioUpdatedAt: Date.now()
        });
      }
    };

    sttRecognition.onerror = (event) => {
      console.warn("STT error:", event.error);
      debugStatus.textContent = "STT 오류: " + event.error;
      if (event.error === "not-allowed" || event.error === "service-not-allowed") {
        sttActive = false;
        btnSttToggle.textContent = "음성 인식 불가 (권한 거부)";
      }
    };

    sttRecognition.onend = () => {
      // 사용자가 직접 끈 게 아니고, 여전히 active면 자동 재시작
      if (sttActive) {
        debugStatus.textContent = "STT 재시작 중...";
        try {
          sttRecognition.start();
        } catch (e) {
          console.warn("STT 재시작 실패:", e);
        }
      } else {
        debugStatus.textContent = "STT 중지됨.";
      }
    };
  }

  initSTT();

  // STT 토글 버튼
  btnSttToggle.addEventListener("click", () => {
    if (!sttSupported || !sttRecognition) return;
    if (!sttActive) {
      // 시작
      sttActive = true;
      sttFinalText = "";
      debugSttText.textContent = "(녹음 중...)";
      btnSttToggle.textContent = "음성 인식 중지";
      debugStatus.textContent = "STT 동작 중 (Listening/Speaking).";
      try {
        sttRecognition.start();
      } catch (e) {
        console.warn("STT start error:", e);
        debugStatus.textContent = "STT 시작 에러: " + e.toString();
      }
    } else {
      // 중지
      sttActive = false;
      btnSttToggle.textContent = "음성 인식 시작 (Listening/Speaking)";
      debugStatus.textContent = "STT 중지 요청.";
      try {
        sttRecognition.stop();
      } catch (e) {
        console.warn("STT stop error:", e);
      }
      // 마지막으로 Firebase에 확정본 push
      if (sttFinalText) {
        stateRef.update({
          audioText: sttFinalText,
          audioUpdatedAt: Date.now()
        });
      }
    }
  });

  // 리스닝 세트 초기화
  btnResetListening.addEventListener("click", () => {
    accumulatedText = "";
    sttFinalText = "";
    debugOcrAccum.textContent = "(없음)";
    debugSttText.textContent = "(없음)";
    stateRef.update({
      ocrText: "",
      ocrConfidence: null,
      audioText: "",
      audioUpdatedAt: null
    });
    globalStatus.textContent = "리스닝 세트 초기화 완료.";
  });

  // ------------ AI 호출 ------------
  btnSolve.addEventListener("click", () => {
    runSolve("manual");
  });

  async function runSolve(reason) {
    if (solving) {
      // 한 번 더 들어오면 끝나고 다시 실행
      pendingSolve = true;
      globalStatus.textContent = "이전 풀이가 끝나는 중입니다...";
      return;
    }

    solving = true;
    pendingSolve = false;

    const payload = {
      mode: currentMode || "auto",
      ocrText: accumulatedText || lastOcrText || "",
      audioText: sttFinalText || "",
    };

    globalStatus.textContent =
      `AI 풀이 중... (mode=${payload.mode}, 호출 이유=${reason})`;
    answerMainEl.textContent = "AI 풀이 중...";
    answerMetaEl.textContent = "";
    answerRawEl.textContent = "";
    debugAiRaw.textContent = "";

    try {
      const res = await fetch("/.netlify/functions/solve", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      const text = await res.text();
      const trimmed = text.trim();

      // HTML 에러 방어
      const looksLikeHtml = /^<!?html/i.test(trimmed.slice(0, 15)) ||
                            /^<html/i.test(trimmed.slice(0, 10)) ||
                            /^<head/i.test(trimmed.slice(0, 10)) ||
                            /^<body/i.test(trimmed.slice(0, 10));

      debugAiRaw.textContent = trimmed || "(응답 없음)";

      if (!res.ok || looksLikeHtml) {
        answerMainEl.textContent =
          "[AI 오류] 서버에서 정상적인 답을 받지 못했습니다.";
        answerMetaEl.textContent =
          "잠시 후 다시 시도하거나, 네트워크 상태·OpenRouter 대시보드를 확인해봐야 함.";
        answerRawEl.textContent = trimmed.slice(0, 1000);
        globalStatus.textContent =
          `AI 호출 실패 (HTTP ${res.status}${looksLikeHtml ? ", HTML 응답" : ""})`;
        solving = false;
        if (pendingSolve) {
          const again = pendingSolve;
          pendingSolve = false;
          if (again) runSolve("retry-after-error");
        }
        return;
      }

      // 정상 텍스트 → 파싱
      renderAnswer(trimmed, payload.mode);
      globalStatus.textContent = "AI 풀이 완료.";
    } catch (e) {
      console.error(e);
      answerMainEl.textContent = "[AI 오류] 네트워크/함수 에러.";
      answerMetaEl.textContent = e.toString();
      answerRawEl.textContent = "";
      debugAiRaw.textContent = e.toString();
      globalStatus.textContent = "AI 호출 중 예외 발생.";
    } finally {
      solving = false;
      if (pendingSolve) {
        const again = pendingSolve;
        pendingSolve = false;
        if (again) runSolve("retry");
      }
    }
  }

  // ------------ 답 파싱 & 표시 ------------
  function renderAnswer(text, mode) {
    answerRawEl.textContent = text;

    let mainLine = "";
    let probInfo = "";
    let metaInfo = "";

    // 공통: 확률 추출 ([P] 0.83 형태 or p=0.83)
    const probMatch = text.match(/p\s*=\s*([0-9.]+)/i) ||
                      text.match(/\[P\]\s*([0-9.]+)/i);
    if (probMatch) {
      const p = Math.max(0, Math.min(1, parseFloat(probMatch[1] || "0")));
      const pct = Math.round(p * 100);
      probInfo = `맞을 확률(추정): ${pct}%`;
    }

    if (mode === "reading" || mode === "listening") {
      const ansMatch = text.match(/\[ANSWER\]\s*([^\n]+)/i);
      const whyMatch = text.match(/\[WHY\]([\s\S]*)/i);
      mainLine = ansMatch ? ansMatch[1].trim() : "(정답 정보 없음)";
      metaInfo = whyMatch ? whyMatch[1].trim() : "";
    } else if (mode === "writing") {
      const essayMatch = text.match(/\[ESSAY\]([\s\S]*?)(?:\[FEEDBACK\]|$)/i);
      const fbMatch    = text.match(/\[FEEDBACK\]([\s\S]*)/i);
      mainLine = essayMatch ? essayMatch[1].trim() : "(에세이 본문 없음)";
      metaInfo = fbMatch ? fbMatch[1].trim() : "";
    } else if (mode === "speaking") {
      const evalMatch  = text.match(/\[EVAL\]([\s\S]*?)(?=\[MODEL\]|\[KOREAN\]|$)/i);
      const modelMatch = text.match(/\[MODEL\]([\s\S]*?)(?=\[KOREAN\]|$)/i);
      const krMatch    = text.match(/\[KOREAN\]([\s\S]*)/i);
      mainLine = modelMatch ? modelMatch[1].trim()
                            : (evalMatch ? evalMatch[1].trim() : "(모범 답안 없음)");
      metaInfo = [
        evalMatch ? "[EVAL]\n" + evalMatch[1].trim() : "",
        krMatch   ? "[KOREAN]\n" + krMatch[1].trim() : ""
      ].filter(Boolean).join("\n\n");
    } else {
      // 기타 모드/자동
      const firstLine = text.split(/\r?\n/).find(line => line.trim().length > 0) || "";
      mainLine = firstLine.trim();
      metaInfo = text;
    }

    answerMainEl.textContent = mainLine || "(내용 없음)";
    answerMetaEl.textContent =
      [probInfo, metaInfo].filter(s => s && s.trim().length > 0).join("\n\n");
  }

  // 초기 모드 표시
  updateModeUI();
</script>
</body>
</html>

