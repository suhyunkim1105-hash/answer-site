<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Auto OCR → Solve</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    video { width: 100%; max-width: 720px; background: #000; border-radius: 12px; }
    canvas { display:none; }
    textarea { width: 100%; min-height: 220px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    .muted { color: #666; font-size: 13px; }
    .warn { color: #b45309; font-weight: 600; }
    .ok { color: #16a34a; font-weight: 600; }
    pre { white-space: pre-wrap; word-break: break-word; margin: 0; }
  </style>
</head>
<body>
  <h2>Auto OCR → STOP 감지 → /solve → reader로 전송</h2>

  <div class="card">
    <div class="row">
      <button id="btnCam" class="primary">카메라 시작</button>
      <button id="btnAuto" disabled class="primary">AUTO START</button>
      <button id="btnStop" disabled>STOP</button>
      <button id="btnOpenReader">reader 열기</button>
    </div>
    <div class="row" style="margin-top:10px;">
      <label>페이지 시작:
        <input id="startPage" type="number" value="1" min="1" style="width:80px;">
      </label>
      <label>샷 수(페이지당):
        <input id="shotsPerPage" type="number" value="3" min="1" max="5" style="width:70px;">
      </label>
      <label>샷 간격(초):
        <input id="shotDelay" type="number" value="5" min="2" max="30" style="width:70px;">
      </label>
      <label>최대 가로(px):
        <input id="maxWidth" type="number" value="2000" min="800" max="4000" style="width:90px;">
      </label>
      <label>JPEG 품질(0~1):
        <input id="jpegQ" type="number" value="0.9" step="0.05" min="0.4" max="1" style="width:80px;">
      </label>
      <label>STOP 토큰:
        <input id="stopToken" type="text" value="ABCDEFGH" style="width:140px;">
      </label>
    </div>
    <div class="muted" style="margin-top:8px;">
      - STOP 토큰 페이지는 OCR은 하되, <b>best shot 선정/품질판정에서 제외</b>하고 누적 텍스트에도 제외함.<br/>
      - iOS는 프리뷰 해상도가 낮게 잡히는 경우가 있어 <b>track 실제 해상도</b>를 표시함.
    </div>
  </div>

  <div class="card">
    <h3>카메라 프리뷰</h3>
    <video id="video" playsinline autoplay muted></video>
    <canvas id="canvas"></canvas>
    <div id="camInfo" class="muted" style="margin-top:8px;"></div>
    <div id="previewWarn" class="warn" style="margin-top:6px;"></div>
  </div>

  <div class="card">
    <h3>상태 / 로그</h3>
    <div id="status" class="muted">대기 중</div>
    <pre id="log"></pre>
  </div>

  <div class="card">
    <h3>누적 OCR 텍스트</h3>
    <textarea id="accText" placeholder="자동으로 누적됨"></textarea>
  </div>

  <div class="card">
    <h3>정답 비교(선택)</h3>
    <div class="muted">정답표(공식)를 아래에 붙여넣으면 모델 정답과 자동 비교해서 %를 보여줌. 형식 자유(예: 1 A / 1: A / 01-2 / 1=2 등)</div>
    <textarea id="officialKey" placeholder="공식 정답 키를 여기 붙여넣기"></textarea>
    <div class="row" style="margin-top:8px;">
      <button id="btnCompare">비교하기</button>
      <div id="compareOut" class="muted"></div>
    </div>
  </div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  const video = $("video");
  const canvas = $("canvas");
  const ctx = canvas.getContext("2d");

  const btnCam = $("btnCam");
  const btnAuto = $("btnAuto");
  const btnStop = $("btnStop");
  const btnOpenReader = $("btnOpenReader");

  const statusEl = $("status");
  const logEl = $("log");
  const accTextEl = $("accText");
  const camInfoEl = $("camInfo");
  const previewWarnEl = $("previewWarn");

  const startPageEl = $("startPage");
  const shotsPerPageEl = $("shotsPerPage");
  const shotDelayEl = $("shotDelay");
  const maxWidthEl = $("maxWidth");
  const jpegQEl = $("jpegQ");
  const stopTokenEl = $("stopToken");

  const officialKeyEl = $("officialKey");
  const btnCompare = $("btnCompare");
  const compareOut = $("compareOut");

  const bc = new BroadcastChannel("answers_channel");

  let stream = null;
  let running = false;
  let stopRequested = false;

  let page = 1;
  let accumulated = "";
  let lastAnswers = null;

  function now() {
    const d = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    return `${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }
  function log(msg) {
    logEl.textContent += `[${now()}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setStatus(msg) {
    statusEl.textContent = msg;
  }

  function normalizeStopToken(s) {
    return (s || "").trim();
  }

  function sleep(ms) {
    return new Promise(res => setTimeout(res, ms));
  }

  async function startCamera() {
    if (stream) return;

    // iOS에서 ideal 요청이 무시될 수 있지만, 최대한 고해상도로 요청
    const constraints = {
      audio: false,
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 2560 },
        height: { ideal: 1440 }
      }
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;

    await new Promise(res => video.onloadedmetadata = res);

    const track = stream.getVideoTracks()[0];
    const settings = track.getSettings ? track.getSettings() : {};
    const w = settings.width || video.videoWidth;
    const h = settings.height || video.videoHeight;

    camInfoEl.textContent = `실제 프리뷰(트랙) 해상도: ${w}x${h} / facingMode=${settings.facingMode || "?"}`;
    previewWarnEl.textContent = "";

    // 너 로그 기준: 1080x1920이면 OCR 크게 떨어진다고 경고
    if (Math.min(w, h) <= 1080) {
      previewWarnEl.textContent =
        `경고: 프리뷰 해상도가 낮다(${w}x${h}). OCR 정확도가 크게 떨어질 수 있음. (대응: 더 밝은 조명 / 폰-종이 거리 늘리고 꽉 채우기 / Safari 재시도 / 다른 기기)`;
      log(`경고: 프리뷰 해상도가 낮다(${w}x${h}). OCR 정확도가 크게 떨어질 수 있다.`);
      log(`대응: (1) 더 밝은 조명 (2) 폰-종이 거리 늘리고 꽉 채우기 (3) 다른 브라우저/사파리 재시도`);
    } else {
      log(`카메라 OK (${w}x${h})`);
    }

    btnAuto.disabled = false;
    btnStop.disabled = false;
    setStatus("카메라 준비 완료");
  }

  function captureToJpegDataUrl(maxW, jpegQ) {
    const vw = video.videoWidth;
    const vh = video.videoHeight;

    // 가로세로가 뒤집힌 경우가 많으니, 원본 비율 유지
    let targetW = vw;
    let targetH = vh;

    if (vw > maxW) {
      const r = maxW / vw;
      targetW = Math.round(vw * r);
      targetH = Math.round(vh * r);
    }

    canvas.width = targetW;
    canvas.height = targetH;
    ctx.drawImage(video, 0, 0, targetW, targetH);

    return canvas.toDataURL("image/jpeg", jpegQ);
  }

  function calcQualityScore(text) {
    // OCR.Space가 confidence를 안 주는 경우를 대비한 휴리스틱 q
    // 1) 길이 + 2) 알파벳/숫자/구두점 비율 + 3) 이상문자 비율 패널티
    const t = (text || "");
    const len = t.length;
    if (!len) return 0;

    const good = (t.match(/[A-Za-z0-9.,;:"'!?()\-\s]/g) || []).length;
    const weird = len - good;

    const goodRatio = good / len;         // 0~1
    const weirdPenalty = weird / len;     // 0~1

    // 길이는 로그 스케일로 (너 로그 q 비슷하게 0~100 근처로)
    const lenScore = Math.min(50, Math.log10(len + 1) * 20); // 최대 50
    const ratioScore = goodRatio * 60;                       // 최대 60
    const penalty = weirdPenalty * 20;                       // 최대 20

    const q = Math.max(0, Math.min(100, lenScore + ratioScore - penalty));
    return Math.round(q * 10) / 10;
  }

  function containsStopToken(text, token) {
    if (!token) return false;
    const re = new RegExp(`\\b${token.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\b`, "i");
    return re.test(text || "");
  }

  async function ocrViaFunction(imageDataUrl) {
    const r = await fetch("/.netlify/functions/ocr", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ imageDataUrl })
    });

    const j = await r.json().catch(() => ({}));
    if (!r.ok) {
      throw new Error(j?.error || `OCR failed (${r.status})`);
    }
    return j; // { text, raw }
  }

  async function solveViaFunction(text) {
    const r = await fetch("/.netlify/functions/solve", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ text })
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok) {
      throw new Error(j?.error || `solve failed (${r.status})`);
    }
    return j; // { answers: {..} }
  }

  function broadcastAnswers(payload) {
    // payload: { answers, timestamp, meta }
    try { localStorage.setItem("last_answers_payload", JSON.stringify(payload)); } catch(e){}
    bc.postMessage(payload);
  }

  function appendAccumulated(pageNo, text) {
    accumulated += `\n\n[PAGE ${pageNo}]\n` + (text || "").trim() + "\n";
    accTextEl.value = accumulated.trim();
  }

  async function runAuto() {
    if (!stream) {
      alert("먼저 카메라 시작");
      return;
    }
    if (running) return;

    running = true;
    stopRequested = false;

    page = parseInt(startPageEl.value || "1", 10);
    const shotsPerPage = Math.max(1, Math.min(5, parseInt(shotsPerPageEl.value || "3", 10)));
    const delaySec = Math.max(2, Math.min(30, parseInt(shotDelayEl.value || "5", 10)));
    const maxW = Math.max(800, Math.min(4000, parseInt(maxWidthEl.value || "2000", 10)));
    const jpegQ = Math.max(0.4, Math.min(1, parseFloat(jpegQEl.value || "0.9")));
    const stopToken = normalizeStopToken(stopTokenEl.value);

    log("AUTO START");
    setStatus("AUTO 실행 중");

    while (!stopRequested) {
      setStatus(`페이지 ${page} OCR 중...`);
      let best = { q: -1, text: "", shot: 0 };

      // 페이지당 N샷
      for (let s = 1; s <= shotsPerPage; s++) {
        if (stopRequested) break;

        log(`페이지 ${page} / 샷 ${s} 카운트다운 시작 (${delaySec}s)`);
        await sleep(delaySec * 1000);

        const img = captureToJpegDataUrl(maxW, jpegQ);

        let ocr;
        try {
          ocr = await ocrViaFunction(img);
        } catch (e) {
          log(`OCR FAIL page=${page} shot=${s} err=${e.message}`);
          continue;
        }

        const text = (ocr.text || "").trim();
        const q = calcQualityScore(text);

        log(`OCR OK page=${page} shot=${s} len=${text.length} q=${q}`);

        // STOP 토큰 감지
        if (containsStopToken(text, stopToken)) {
          // ✅ STOP 페이지는 누적 제외 + best 선정 제외하고 즉시 종료
          log(`STOP TOKEN 감지 (${stopToken}) → 종료`);
          stopRequested = true;
          break;
        }

        // 일반 페이지 best 선정
        if (q > best.q) best = { q, text, shot: s };
      }

      // STOP 없이 페이지 완료되면 누적
      if (!stopRequested) {
        log(`페이지 ${page} 완료 (best q=${best.q}, shot=${best.shot})`);
        appendAccumulated(page, best.text);
        page += 1;
      }
    }

    // solve 호출(누적 텍스트가 있어야 함)
    const finalText = (accumulated || "").trim();
    if (!finalText) {
      log("정답 계산 스킵: 누적 텍스트가 비어있음");
      setStatus("종료(누적 텍스트 없음)");
      running = false;
      return;
    }

    log("정답 계산 시작 (/solve 호출)");
    setStatus("정답 계산 중...");

    try {
      const answers = await solveViaFunction(finalText);
      lastAnswers = answers;

      log("정답 수신 OK");
      setStatus("정답 수신 완료");

      const payload = {
        answers,
        timestamp: Date.now(),
        meta: { pagesCaptured: page - 1 }
      };
      broadcastAnswers(payload);

      // 바로 비교 결과도 업데이트(공식키가 있으면)
      updateCompareIfPossible();

    } catch (e) {
      log(`정답 계산 FAIL: ${e.message}`);
      setStatus("정답 계산 실패");
    }

    running = false;
  }

  function parseKeyTextToMap(text) {
    // 다양한 입력 형식을 최대한 파싱:
    // - "1번: A", "1: A", "01 A", "1=2", "1 2" 등
    // 반환: { "1": "A" } 형태 (A~E로 통일)
    const t = (text || "").replace(/\r/g, "\n");
    const out = {};

    // 1) "number + letter" (A-E)
    const re1 = /(?:^|\s)(\d{1,3})\s*[:=)\-]?\s*([A-Ea-e])(?:\s|$)/g;
    let m;
    while ((m = re1.exec(t)) !== null) {
      out[String(parseInt(m[1], 10))] = m[2].toUpperCase();
    }

    // 2) "number + digit(1-5)" -> A-E
    const re2 = /(?:^|\s)(\d{1,3})\s*[:=)\-]?\s*([1-5])(?:\s|$)/g;
    while ((m = re2.exec(t)) !== null) {
      const n = String(parseInt(m[1], 10));
      const d = parseInt(m[2], 10);
      out[n] = "ABCDE"[d - 1];
    }

    return out;
  }

  function updateCompareIfPossible() {
    const official = parseKeyTextToMap(officialKeyEl.value);
    const model = lastAnswers?.answers || lastAnswers?.answers?.answers || lastAnswers?.answers;

    // solve 응답 구조가 {answers:{...}}이므로 model은 아래처럼 정규화
    const modelMap = (lastAnswers && lastAnswers.answers) ? lastAnswers.answers : (lastAnswers?.answers?.answers || {});
    const hasOfficial = Object.keys(official).length > 0;
    const hasModel = Object.keys(modelMap).length > 0;

    if (!hasOfficial || !hasModel) {
      compareOut.textContent = "공식키/모델정답 둘 다 있어야 비교 가능";
      return;
    }

    const keys = Object.keys(official).sort((a,b)=>Number(a)-Number(b));
    let total = 0, hit = 0, missList = [];
    for (const k of keys) {
      total++;
      const o = official[k];
      const p = (modelMap[k] || "").toUpperCase();
      if (p && p === o) hit++;
      else missList.push(`${k}(${o}≠${p||"?"})`);
    }
    const pct = total ? (hit / total * 100) : 0;
    compareOut.textContent = `일치: ${hit}/${total} = ${pct.toFixed(1)}%  / 오답: ${missList.slice(0,10).join(", ")}${missList.length>10?" ...":""}`;
  }

  // UI handlers
  btnCam.onclick = async () => {
    try {
      await startCamera();
    } catch (e) {
      alert("카메라 실패: " + e.message);
    }
  };

  btnAuto.onclick = async () => {
    if (running) return;
    runAuto();
  };

  btnStop.onclick = () => {
    stopRequested = true;
    log("STOP 요청");
    setStatus("STOP 요청됨");
  };

  btnOpenReader.onclick = () => {
    window.open("/reader.html", "_blank");
  };

  btnCompare.onclick = () => {
    updateCompareIfPossible();
  };

})();
</script>
</body>
</html>
