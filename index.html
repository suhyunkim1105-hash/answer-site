<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>NONSUL Auto OCR + Auto Solve</title>

  <!-- Tesseract.js v5 -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
      padding: 10px;
    }
    .wrap { max-width: 980px; margin: 0 auto; }
    #videoBox {
      position: relative;
      width: 100%;
      background: #000;
      border-radius: 10px;
      overflow: hidden;
      border: 1px solid rgba(0,255,0,0.35);
    }
    #video {
      width: 100%;
      height: auto;
      transform-origin: center center;
      /* â€œ0.8ë°°ìœ¨â€ ìš”ì²­: ì¹´ë©”ë¼ ìì²´ 0.8ì€ iOSì—ì„œ ë¶ˆê°€(1.0 ë¯¸ë§Œ ë¶ˆê°€ê°€ ë§ìŒ)ë¼ì„œ
         í™”ë©´ í‘œì‹œë¥¼ 0.8ë¡œ ì¤„ì—¬ â€œëœ í™•ëŒ€ëœ ê²ƒì²˜ëŸ¼â€ ë³´ì´ê²Œ í•¨ */
      transform: scale(0.8);
    }
    .btnRow {
      display: flex;
      gap: 10px;
      margin: 10px 0;
      flex-wrap: wrap;
    }
    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
      font-size: 14px;
    }
    button:active { transform: scale(0.98); }
    .panel {
      border: 1px solid #333;
      border-radius: 12px;
      padding: 12px;
      background: #0b0b0b;
      margin-top: 10px;
      white-space: pre-wrap;
      line-height: 1.35;
      font-size: 14px;
    }
    .title {
      font-weight: 700;
      margin-bottom: 8px;
      font-size: 15px;
    }
    pre {
      margin: 0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12.5px;
      white-space: pre-wrap;
      word-break: break-word;
      max-height: 360px;
      overflow: auto;
      padding: 10px;
      border-radius: 10px;
      background: #000;
      border: 1px solid #222;
    }
    #answerBox pre { max-height: 520px; font-size: 13px; }
  </style>
</head>

<body>
<div class="wrap">
  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <div class="btnRow">
    <button id="btnTTS">ğŸ”Š ìŒì„± í…ŒìŠ¤íŠ¸(í•œ ë²ˆ íƒ­)</button>
    <button id="btnForceSolve">âš¡ ì§€ê¸ˆê¹Œì§€ë¡œ ê°•ì œ í’€ì´</button>
    <button id="btnRestart">ğŸ” OCR ì¬ì‹œì‘(ìƒˆë¡œê³ ì¹¨)</button>
  </div>

  <div class="panel" id="statusPanel">ë¡œë”© ì¤‘...</div>

  <div class="panel">
    <div class="title">ì‹¤ì‹œê°„ OCR(ëˆ„ì )</div>
    <pre id="ocrPreview"></pre>
  </div>

  <div class="panel" id="answerBox">
    <div class="title">ë‹µì•ˆ</div>
    <pre id="answerOut"></pre>
  </div>
</div>

<script>
(() => {
  // =============================
  // ì„¤ì •
  // =============================
  const SOLVE_URL = "/.netlify/functions/solve";

  const OCR_INTERVAL_MS = 3000;              // 3ì´ˆë§ˆë‹¤ OCR ì‹œë„
  const INSUFFICIENT_WARN_MS = 60 * 1000;    // 1ë¶„: â€œì§€ë¬¸ ë¶€ì¡±â€ ì•ˆë‚´
  const INSUFFICIENT_AUTO_SOLVE_MS = 8 * 60 * 1000; // 8ë¶„: ë¶€ì¡±ì´ì–´ë„ ìë™ í’€ì´
  const READY_LEN_TARGET = 2400;             // ê³µë°±ì œì™¸ ëˆ„ì  ê¸¸ì´ ê¸°ì¤€(ì¶©ë¶„í•˜ë©´ ë°”ë¡œ í’€ì´)
  const MAX_OCR_PREVIEW_CHARS = 16000;       // í™”ë©´ í‘œì‹œìš© ìµœëŒ€ ê¸¸ì´
  const MAX_SEND_CHARS = 9000;               // solveë¡œ ë³´ë‚´ëŠ” ìµœëŒ€ ê¸¸ì´(íƒ€ì„ì•„ì›ƒ ë°©ì§€)

  // OCR ì—”ì§„(ì¤‘ìš”): kor ì–¸ì–´ë°ì´í„° ê²½ë¡œ (ê¸°ì¡´ì— ì—¬ê¸° í‹€ë¦¬ë©´ â€œë¡œë”© ì¤‘â€ ë¬´í•œ)
  const WORKER_PATH = "https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js";
  const CORE_PATH   = "https://unpkg.com/tesseract.js-core@5.0.0";
  const LANG_PATH   = "https://cdn.jsdelivr.net/npm/@tesseract.js-data/kor@1.0.0/4.0.0/";

  // =============================
  // DOM
  // =============================
  const video = document.getElementById("video");
  const statusPanel = document.getElementById("statusPanel");
  const ocrPreview = document.getElementById("ocrPreview");
  const answerOut = document.getElementById("answerOut");

  const btnTTS = document.getElementById("btnTTS");
  const btnForceSolve = document.getElementById("btnForceSolve");
  const btnRestart = document.getElementById("btnRestart");

  // =============================
  // ìƒíƒœ ë³€ìˆ˜
  // =============================
  let stream = null;
  let worker = null;
  let engineReady = false;

  let ocrBusy = false;
  let ocrTickCount = 0;

  let lastOcrAt = 0;

  let accumulatedSegments = []; // {text, conf, gramsSig}
  let avgConf = 0;

  let insufficientSince = null;
  let insufficientWarned = false;
  let solvedOnce = false;

  let ttsUnlocked = false;

  // ì¹´ë©”ë¼ ìƒíƒœ(ê°€ë ¤ì§/ê±°ë¦¬ ì¶”ì •)
  const TH_W = 96, TH_H = 54;
  const thumbCanvas = document.createElement("canvas");
  thumbCanvas.width = TH_W;
  thumbCanvas.height = TH_H;
  const thumbCtx = thumbCanvas.getContext("2d", { willReadFrequently: true });

  let prevThumb = null;
  let lastStableStart = 0;

  // =============================
  // ìœ í‹¸: í…ìŠ¤íŠ¸ ì •ë¦¬(ìˆ«ì/ê¸°í˜¸ ì œê±° ì¤‘ì‹¬)
  // =============================
  function normalizeText(raw) {
    const s = (raw || "")
      .replace(/\r/g, "")
      .replace(/[0-9]/g, "")                          // ìˆ«ì ì œê±°
      .replace(/[~`^_=+<>\\|]/g, " ")                 // ë°©í•´ë˜ëŠ” ê¸°í˜¸ ì œê±°
      .replace(/[â– â–¡â—†â—‡â—â—‹â–²â–³â–¼â–½â€»â˜…â˜†]/g, " ")
      .replace(/[(){}\[\]]/g, " ")
      .replace(/[â€œâ€"']/g, " ")
      .replace(/[â€¢Â·]/g, " ")
      .replace(/[â€”â€“]/g, "-")
      .replace(/[^\uAC00-\uD7A3\u3131-\u318E\u314F-\u3163\s\.\,\!\?\:\;\-\n]/g, " ") // í•œê¸€/ê¸°ë³¸ë¬¸ì¥ë¶€í˜¸ë§Œ ë‚¨ê¸°ê¸°
      .replace(/[ \t]+/g, " ")
      .replace(/\n{3,}/g, "\n\n")
      .trim();

    // ì¤„ ëì— ë¶™ëŠ” ê³µë°± ì •ë¦¬
    return s.split("\n").map(line => line.trim()).join("\n").trim();
  }

  function effectiveLen(s) {
    return (s || "").replace(/\s/g, "").length;
  }

  // =============================
  // ìœ í‹¸: ìœ ì‚¬ë„(ì„¸ê·¸ë¨¼íŠ¸ êµì²´ìš©)
  // =============================
  function make3GramSet(s, limit = 1200) {
    const t = (s || "").replace(/\s+/g, "");
    const u = t.slice(0, limit);
    const set = new Set();
    for (let i = 0; i + 3 <= u.length; i++) {
      set.add(u.slice(i, i + 3));
    }
    return set;
  }

  function jaccard(aSet, bSet) {
    if (!aSet || !bSet) return 0;
    let inter = 0;
    for (const x of aSet) if (bSet.has(x)) inter++;
    const union = aSet.size + bSet.size - inter;
    return union ? (inter / union) : 0;
  }

  function mergeSegment(newText, newConf) {
    const grams = make3GramSet(newText);
    let bestIdx = -1;
    let bestSim = 0;

    for (let i = 0; i < accumulatedSegments.length; i++) {
      const sim = jaccard(grams, accumulatedSegments[i].gramsSig);
      if (sim > bestSim) {
        bestSim = sim;
        bestIdx = i;
      }
    }

    // ë¹„ìŠ·í•˜ë©´(ê²¹ì¹˜ë©´) ë” ì¢‹ì€ ê±¸ë¡œ â€œìˆ˜ì •/ëŒ€ì²´â€
    if (bestIdx >= 0 && bestSim >= 0.62) {
      const old = accumulatedSegments[bestIdx];
      const oldLen = effectiveLen(old.text);
      const newLen = effectiveLen(newText);

      // êµì²´ ê¸°ì¤€: (1) ê¸¸ì´ê°€ ë” ê¸¸ê±°ë‚˜ (2) ì‹ ë¢°ë„ê°€ ë” ë†’ìœ¼ë©´ êµì²´
      if (newLen > oldLen || newConf > old.conf + 3) {
        accumulatedSegments[bestIdx] = { text: newText, conf: newConf, gramsSig: grams };
      }
      return;
    }

    // ì¶©ë¶„íˆ ë‹¤ë¥´ë©´ ìƒˆ í˜ì´ì§€/ì„¸ê·¸ë¨¼íŠ¸ë¼ê³  ë³´ê³  ì¶”ê°€
    accumulatedSegments.push({ text: newText, conf: newConf, gramsSig: grams });

    // ì„¸ê·¸ë¨¼íŠ¸ ë„ˆë¬´ ë§ì•„ì§€ë©´ (ë©”ëª¨ë¦¬/ì¤‘ë³µ ë°©ì§€) ë’¤ì—ì„œ ì˜ë¼ëƒ„
    if (accumulatedSegments.length > 40) {
      accumulatedSegments = accumulatedSegments.slice(-40);
    }
  }

  function getAccumulatedText() {
    const joined = accumulatedSegments.map(s => s.text).join("\n\n");
    // ë„ˆë¬´ ê¸¸ë©´ ë’¤ì—ì„œë¶€í„° ë‚¨ê¸°ê¸°(ìµœê·¼/ì¶”ê°€ëœ ê²Œ ë³´í†µ ë” ì •í™•)
    if (joined.length <= MAX_OCR_PREVIEW_CHARS) return joined;
    return joined.slice(joined.length - MAX_OCR_PREVIEW_CHARS);
  }

  function calcAvgConf() {
    if (!accumulatedSegments.length) return 0;
    const sum = accumulatedSegments.reduce((a, s) => a + (s.conf || 0), 0);
    return sum / accumulatedSegments.length;
  }

  // =============================
  // ì¹´ë©”ë¼ ë¶„ì„(ê°€ë ¤ì§/í”ë“¤ë¦¼/ê±°ë¦¬ ì¶”ì •(ì¶”ì¸¡))
  // =============================
  function analyzeFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      return { blocked: false, stable: false, distanceHint: "ì•Œ ìˆ˜ ì—†ìŒ(ëŒ€ê¸°)" };
    }

    thumbCtx.drawImage(video, 0, 0, TH_W, TH_H);
    const img = thumbCtx.getImageData(0, 0, TH_W, TH_H).data;

    const n = TH_W * TH_H;
    let sum = 0;
    let diffSum = 0;

    // â€œì„ ëª…ë„â€ ëŒ€ì¶© ì¶”ì •(ì¸ì ‘ í”½ì…€ ì°¨ì´)
    let edgeSum = 0;

    const curr = new Uint8Array(n);
    for (let i = 0, p = 0; i < img.length; i += 4, p++) {
      const r = img[i], g = img[i+1], b = img[i+2];
      const gray = (r + g + b) / 3;
      curr[p] = gray;
      sum += gray;
      if (prevThumb) diffSum += Math.abs(gray - prevThumb[p]);
    }

    // edge(ê°„ë‹¨)
    for (let y = 1; y < TH_H - 1; y++) {
      for (let x = 1; x < TH_W - 1; x++) {
        const idx = y * TH_W + x;
        const gx = Math.abs(curr[idx] - curr[idx - 1]) + Math.abs(curr[idx] - curr[idx + 1]);
        const gy = Math.abs(curr[idx] - curr[idx - TH_W]) + Math.abs(curr[idx] - curr[idx + TH_W]);
        edgeSum += (gx + gy);
      }
    }

    const avgBright = sum / n;
    const diffAvg = prevThumb ? (diffSum / n) : 0;
    prevThumb = curr;

    const blocked = avgBright < 18; // ê±°ì˜ ê²€ì •ì´ë©´ ê°€ë ¤ì§/ì–´ë‘ì›€

    const now = Date.now();
    let stable = false;
    if (diffAvg < 7) {
      if (!lastStableStart) lastStableStart = now;
      if (now - lastStableStart > 700) stable = true;
    } else {
      lastStableStart = 0;
    }

    // ê±°ë¦¬ íŒíŠ¸(ì •í™•í•œ íŒì • ë¶ˆê°€ â†’ â€œì¶”ì¸¡â€ìœ¼ë¡œë§Œ)
    // edgeê°€ ë„ˆë¬´ ë‚®ìœ¼ë©´: ë„ˆë¬´ ë©€ê±°ë‚˜ ì´ˆì /í”ë“¤ë¦¼
    // edgeê°€ ë„ˆë¬´ ë†’ìœ¼ë©´: ë„ˆë¬´ ê°€ê¹Œì›Œ ê¸€ìê°€ í¬ê²Œ ê¹¨ì§€ê±°ë‚˜(í˜¹ì€ ë¬´ëŠ¬/ì¡ìŒ)
    let distanceHint = "ì •ìƒ(ì¶”ì¸¡)";
    const edgeAvg = edgeSum / (TH_W * TH_H);
    if (blocked) {
      distanceHint = "ê°€ë ¤ì§/ë„ˆë¬´ ì–´ë‘ì›€";
    } else if (edgeAvg < 9) {
      distanceHint = "ì¶”ì¸¡: ë„ˆë¬´ ë©€ê±°ë‚˜ í”ë“¤ë¦¼/ì´ˆì  ë¶ˆëŸ‰";
    } else if (edgeAvg > 28) {
      distanceHint = "ì¶”ì¸¡: ë„ˆë¬´ ê°€ê¹Œì›€/ë¬´ëŠ¬(ë°°ê²½) ì¡ìŒ";
    }

    return { blocked, stable, distanceHint };
  }

  // =============================
  // ì „ì²˜ë¦¬ ìº”ë²„ìŠ¤ ë§Œë“¤ê¸°(ë‹¤ìš´ìŠ¤ì¼€ì¼ + ëŒ€ë¹„)
  // =============================
  function buildOcrCanvas() {
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    if (!vw || !vh) {
      canvas.width = 640;
      canvas.height = 360;
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      return canvas;
    }

    // ë„ˆë¬´ í° í”„ë ˆì„ì€ WASM ì£½ì„ í™•ë¥ â†‘ â†’ ê°•ì œ ë‹¤ìš´ìŠ¤ì¼€ì¼
    const maxW = 1280; // iPhoneì—ì„œë„ ì¶©ë¶„íˆ ê¸€ì ì¸ì‹ë¨
    const scale = Math.min(1, maxW / vw);
    const outW = Math.floor(vw * scale);
    const outH = Math.floor(vh * scale);

    canvas.width = outW;
    canvas.height = outH;
    ctx.drawImage(video, 0, 0, outW, outH);

    // ê°„ë‹¨ ëŒ€ë¹„/ê·¸ë ˆì´
    const img = ctx.getImageData(0, 0, outW, outH);
    const d = img.data;

    // ëŒ€ë¹„ ì¦ê°€(ê°€ë³ê²Œ)
    const contrast = 1.25; // 1.0~1.4 ì •ë„
    const intercept = 128 * (1 - contrast);

    for (let i = 0; i < d.length; i += 4) {
      const r = d[i], g = d[i+1], b = d[i+2];
      let gray = (r*0.299 + g*0.587 + b*0.114);

      // ëŒ€ë¹„ ì¡°ì ˆ
      gray = gray * contrast + intercept;

      // clamp
      if (gray < 0) gray = 0;
      if (gray > 255) gray = 255;

      d[i] = d[i+1] = d[i+2] = gray;
      d[i+3] = 255;
    }

    ctx.putImageData(img, 0, 0);
    return canvas;
  }

  // =============================
  // TTS
  // =============================
  function speak(text) {
    if (!ttsUnlocked) return;

    try {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(String(text || "").slice(0, 2200));
      u.lang = "ko-KR";
      u.rate = 1.02;
      u.pitch = 1.0;
      window.speechSynthesis.speak(u);
    } catch (e) {
      // ë¬´ì‹œ(ì¼ë¶€ iOS í™˜ê²½ì—ì„œ ì˜ˆì™¸)
    }
  }

  btnTTS.addEventListener("click", () => {
    ttsUnlocked = true;
    speak("ìŒì„± ì—°ê²° ì™„ë£Œ. ì´ì œ ë‹µì•ˆì´ ë‚˜ì˜¤ë©´ ìë™ìœ¼ë¡œ ì½ì–´ì¤ë‹ˆë‹¤.");
    btnTTS.textContent = "ğŸ”Š ìŒì„± ì—°ê²°ë¨";
  });

  btnRestart.addEventListener("click", () => {
    location.reload();
  });

  btnForceSolve.addEventListener("click", () => {
    triggerSolve(true, "ì‚¬ìš©ìê°€ ê°•ì œ í’€ì´ë¥¼ ëˆŒë €ìŠµë‹ˆë‹¤.");
  });

  // =============================
  // OCR ì—”ì§„ ì´ˆê¸°í™” (í•µì‹¬: langPath ì •í™•íˆ!)
  // =============================
  async function initOcrEngine() {
    engineReady = false;
    setStatus("OCR ì—”ì§„ ë¡œë”© ì¤‘...");

    // ì•ˆì „ì¥ì¹˜: ê¸°ì¡´ ì›Œì»¤ ì •ë¦¬
    if (worker) {
      try { await worker.terminate(); } catch (e) {}
      worker = null;
    }

    // createWorker í˜¸í™˜(ì„œëª… ì°¨ì´ ëŒ€ì‘)
    try {
      const opt = {
        logger: (m) => {
          // ë¡œë”©ì´ ë©ˆì¶˜ ê²ƒì²˜ëŸ¼ ë³´ì—¬ì„œ ì§„í–‰ë¥  í‘œì‹œ
          if (m && m.status) {
            if (m.status === "loading tesseract core" ||
                m.status === "loading language traineddata" ||
                m.status === "initializing tesseract" ||
                m.status === "loading tesseract worker") {
              setStatus(`OCR ì—”ì§„ ë¡œë”© ì¤‘... (${m.status})`);
            }
          }
        },
        workerPath: WORKER_PATH,
        corePath: CORE_PATH,
        langPath: LANG_PATH,
        // iOS/ì¼ë¶€ í™˜ê²½ì—ì„œ blob worker ë¬¸ì œ ì˜ˆë°©(ì§€ì› ì•ˆ í•˜ë©´ ë¬´ì‹œë¨)
        workerBlobURL: false
      };

      // v5 ì¼ë°˜ í˜•íƒœ
      worker = await Tesseract.createWorker(opt);

      await worker.loadLanguage("kor");
      await worker.initialize("kor");

      // ìˆ«ì/ê¸°í˜¸ ë°©í•´ ìµœì†Œí™”(ì™„ë²½ ì°¨ë‹¨ì€ ë¶ˆê°€í•˜ì§€ë§Œ íš¨ê³¼ í¼)
      await worker.setParameters({
        tessedit_pageseg_mode: "6",              // block of text
        preserve_interword_spaces: "1",
        tessedit_char_blacklist: "0123456789@#$%^&*_=+<>|{}[]~`",
      });

      engineReady = true;
      setStatus("OCR ì—”ì§„ ë¡œë”© ì™„ë£Œ");
    } catch (e) {
      engineReady = false;
      setStatus("OCR ì—”ì§„ ë¡œë”© ì‹¤íŒ¨: " + String(e && e.message ? e.message : e));

      // ìë™ ì¬ì‹œë„(1íšŒ)
      await new Promise(r => setTimeout(r, 1200));
      try {
        const opt2 = {
          logger: () => {},
          workerPath: WORKER_PATH,
          corePath: CORE_PATH,
          langPath: LANG_PATH,
          workerBlobURL: false
        };
        worker = await Tesseract.createWorker(opt2);
        await worker.loadLanguage("kor");
        await worker.initialize("kor");
        await worker.setParameters({
          tessedit_pageseg_mode: "6",
          preserve_interword_spaces: "1",
          tessedit_char_blacklist: "0123456789@#$%^&*_=+<>|{}[]~`",
        });
        engineReady = true;
        setStatus("OCR ì—”ì§„ ë¡œë”© ì™„ë£Œ(ì¬ì‹œë„ ì„±ê³µ)");
      } catch (e2) {
        engineReady = false;
        setStatus("OCR ì—”ì§„ ìµœì¢… ì‹¤íŒ¨. (1) ì™€ì´íŒŒì´ ì—°ê²° (2) ì•„ë˜ URLì´ ì—´ë¦¬ëŠ”ì§€ í™•ì¸ í•„ìš”\n" + LANG_PATH);
      }
    }
  }

  // =============================
  // ì¹´ë©”ë¼ ì‹œì‘(í™”ì§ˆ/ì´ˆì  ì‹œë„)
  // =============================
  async function startCamera() {
    try {
      const constraints = {
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          frameRate: { ideal: 30 }
        },
        audio: false
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      // ê³ ê¸‰ ì œì–´(ê°€ëŠ¥í•˜ë©´ ì ìš©, ì•ˆ ë˜ë©´ ë¬´ì‹œ)
      const track = stream.getVideoTracks()[0];
      if (track && track.applyConstraints) {
        const caps = track.getCapabilities ? track.getCapabilities() : null;

        // iOSëŠ” ë³´í†µ zoom < 1 ë¶ˆê°€. ê°€ëŠ¥í•˜ë©´ 1~ ì‚¬ì´ì—ì„œë§Œ ì¡°ì ˆë¨.
        // ì—¬ê¸°ì„  â€œí™”ì§ˆâ€ ëª©ì ë§Œ: continuous focus/exposure ë“± ì‹œë„
        try {
          const adv = [];
          if (caps && caps.focusMode && caps.focusMode.includes("continuous")) adv.push({ focusMode: "continuous" });
          if (caps && caps.exposureMode && caps.exposureMode.includes("continuous")) adv.push({ exposureMode: "continuous" });
          if (caps && caps.whiteBalanceMode && caps.whiteBalanceMode.includes("continuous")) adv.push({ whiteBalanceMode: "continuous" });

          if (adv.length) await track.applyConstraints({ advanced: adv });
        } catch (e) {}
      }

      setStatus("ì¹´ë©”ë¼ ON");
    } catch (e) {
      setStatus("ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: " + String(e && e.message ? e.message : e));
    }
  }

  // =============================
  // OCR 1íšŒ ì‹¤í–‰
  // =============================
  async function runOcrOnce() {
    if (!engineReady || !worker) return;
    if (ocrBusy) return;

    const { blocked, stable, distanceHint } = analyzeFrame();
    if (blocked) {
      // ê°€ë ¤ì§ì´ë©´ OCR í•˜ì§€ ë§ê³  â€œì§€ë¬¸ ë¶€ì¡±â€ ì¹´ìš´íŠ¸ë§Œ ìŒ“ì´ê²Œ ë‘ 
      markInsufficient();
      renderStatus(blocked, stable, distanceHint, "ì¹´ë©”ë¼ ê°€ë ¤ì§/ë„ˆë¬´ ì–´ë‘ì›€");
      return;
    }

    // í”ë“¤ë¦¬ë©´ OCRì€ í•˜ë˜(ì‚¬ìš©ì ìš”ì²­: ìë™ ê³„ì†), ë„ˆë¬´ ì¦ì€ í­ë°œ ë°©ì§€ë¡œ stable ì•„ë‹ˆë©´ ìŠ¤í‚µ
    // (ì •í™•ë„ ê¸‰ë½ + Aborted ìœ ë°œ)
    if (!stable) {
      markInsufficient();
      renderStatus(blocked, stable, distanceHint, "í”ë“¤ë¦¼ ê°ì§€(ì ê¹ ê³ ì •í•´ì¤˜)");
      return;
    }

    ocrBusy = true;
    lastOcrAt = Date.now();

    try {
      const canvas = buildOcrCanvas();

      const res = await worker.recognize(canvas);
      const conf = (res && res.data && typeof res.data.confidence === "number") ? res.data.confidence : 0;

      const raw = (res && res.data && res.data.text) ? res.data.text : "";
      const cleaned = normalizeText(raw);
      const len = effectiveLen(cleaned);

      // ë„ˆë¬´ ì§§ìœ¼ë©´ ëˆ„ì  ê¸ˆì§€
      if (len < 30) {
        markInsufficient();
        renderStatus(false, true, distanceHint, `OCR ë„ˆë¬´ ì§§ìŒ(len=${len}, conf=${conf.toFixed(1)}%)`);
        return;
      }

      // ëˆ„ì (ìœ ì‚¬í•˜ë©´ êµì²´)
      mergeSegment(cleaned, conf);

      avgConf = calcAvgConf();

      // ì§€ë¬¸ ì¶©ë¶„/ë¶€ì¡± íƒ€ì´ë¨¸ ê°±ì‹ 
      const acc = getAccumulatedText();
      const accLen = effectiveLen(acc);

      if (accLen >= READY_LEN_TARGET) {
        clearInsufficient();
      } else {
        markInsufficient();
      }

      // í™”ë©´ ê°±ì‹ 
      ocrPreview.textContent = acc.slice(0, MAX_OCR_PREVIEW_CHARS);

      // ìë™ í’€ì´ íŠ¸ë¦¬ê±°
      if (!solvedOnce) {
        if (accLen >= READY_LEN_TARGET) {
          await triggerSolve(false, "ëˆ„ì  ì§€ë¬¸ì´ ì¶©ë¶„í•´ ìë™ í’€ì´í•©ë‹ˆë‹¤.");
        } else {
          // 1ë¶„ ì•ˆë‚´ / 8ë¶„ ìë™ í’€ì´
          const now = Date.now();
          if (insufficientSince) {
            const dur = now - insufficientSince;

            if (!insufficientWarned && dur >= INSUFFICIENT_WARN_MS) {
              insufficientWarned = true;
              const msg = "ì§€ë¬¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ì¢…ì´ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ, í”ë“¤ë¦¼ ì—†ì´ 5ì´ˆ ì´ìƒ ê³ ì •í•´ ì£¼ì„¸ìš”.";
              speak(msg);
            }

            if (dur >= INSUFFICIENT_AUTO_SOLVE_MS) {
              await triggerSolve(false, "ì§€ë¬¸ ë¶€ì¡±ì´ ì˜¤ë˜ ì§€ì†ë˜ì–´ í˜„ì¬ê¹Œì§€ë¡œ ìë™ í’€ì´í•©ë‹ˆë‹¤.", true);
            }
          }
        }
      }

      // ì›Œì»¤ ë©”ëª¨ë¦¬ ëˆ„ìˆ˜/Aborted ì˜ˆë°©: ì£¼ê¸°ì ìœ¼ë¡œ ì›Œì»¤ ì¬ì‹œì‘
      ocrTickCount++;
      if (ocrTickCount % 18 === 0) {
        await restartWorkerSafely("ì£¼ê¸°ì  ì›Œì»¤ ì¬ì‹œì‘(ë©”ëª¨ë¦¬ ì•ˆì •í™”)");
      }

      renderStatus(false, true, distanceHint, `OCR ì™„ë£Œ(len=${len}, conf=${conf.toFixed(1)}%)`);
    } catch (e) {
      const msg = String(e && e.message ? e.message : e);

      // Aborted(-1) ê°™ì€ WASM í¬ë˜ì‹œëŠ” â€œì´ë¯¸ì§€ ë„ˆë¬´ í¼/ë°˜ë³µ ëˆ„ì ìœ¼ë¡œ ë©”ëª¨ë¦¬â€ê°€ ì›ì¸ì¸ ê²½ìš°ê°€ ë§ìŒ
      if (msg.includes("Aborted") || msg.includes("RuntimeError")) {
        await restartWorkerSafely("OCR ì—”ì§„ í¬ë˜ì‹œ ê°ì§€ â†’ ì›Œì»¤ ì¬ì‹œì‘");
      }

      markInsufficient();
      renderStatus(false, true, analyzeFrame().distanceHint, "OCR ì—ëŸ¬: " + msg);
    } finally {
      ocrBusy = false;
    }
  }

  async function restartWorkerSafely(reason) {
    try {
      setStatus(reason + "\nOCR ì—”ì§„ ì¬ì‹œì‘ ì¤‘...");
      engineReady = false;
      if (worker) {
        try { await worker.terminate(); } catch (e) {}
        worker = null;
      }
      await initOcrEngine();
    } catch (e) {
      setStatus("ì›Œì»¤ ì¬ì‹œì‘ ì‹¤íŒ¨: " + String(e && e.message ? e.message : e));
    }
  }

  // =============================
  // ì§€ë¬¸ ë¶€ì¡± íƒ€ì´ë¨¸
  // =============================
  function markInsufficient() {
    const now = Date.now();
    if (!insufficientSince) insufficientSince = now;
  }

  function clearInsufficient() {
    insufficientSince = null;
    insufficientWarned = false;
  }

  // =============================
  // ìƒíƒœ ì¶œë ¥
  // =============================
  function setStatus(msg) {
    statusPanel.textContent = String(msg || "");
  }

  function renderStatus(blocked, stable, distanceHint, lastMsg) {
    const acc = getAccumulatedText();
    const accLen = effectiveLen(acc);

    const now = Date.now();
    const dur = insufficientSince ? (now - insufficientSince) : 0;

    const warnSec = Math.floor(INSUFFICIENT_WARN_MS / 1000);
    const autoSec = Math.floor(INSUFFICIENT_AUTO_SOLVE_MS / 1000);

    const lines = [];
    lines.push("ìë™ OCR(ëˆ„ì ) â†’ ìë™ í’€ì´");
    lines.push("í”„ë¦¬ë·° ë°°ìœ¨: 0.8 (í‘œì‹œìš©)");
    lines.push("ì¹´ë©”ë¼ ìƒíƒœ: " + (blocked ? "ê°€ë ¤ì§/ì–´ë‘ì›€" : "ì •ìƒ"));
    lines.push("ì•ˆì •ì„±: " + (stable ? "ì•ˆì •" : "í”ë“¤ë¦¼"));
    lines.push("ê±°ë¦¬ ìƒíƒœ: " + distanceHint);
    lines.push("ì„¸ê·¸ë¨¼íŠ¸(í˜ì´ì§€ ì¶”ì •) ìˆ˜: " + accumulatedSegments.length);
    lines.push("ëˆ„ì  OCR ê¸¸ì´(ê³µë°±ì œì™¸): " + accLen + " / ê¸°ì¤€ " + READY_LEN_TARGET);
    lines.push("í‰ê·  OCR ì‹ ë¢°ë„(ëŒ€ëµ): " + (avgConf ? avgConf.toFixed(1) : "0.0") + "%");

    if (insufficientSince) {
      const sec = Math.floor(dur / 1000);
      lines.push("ì§€ë¬¸ ë¶€ì¡± ì§€ì†: " + sec + "ì´ˆ ("
        + warnSec + "ì´ˆì— ì•ˆë‚´, "
        + autoSec + "ì´ˆì— ìë™ í’€ì´)");
    } else {
      lines.push("ì§€ë¬¸ ë¶€ì¡± ì§€ì†: 0ì´ˆ");
    }

    lines.push("OCR ì—”ì§„: " + (engineReady ? "ì¤€ë¹„ë¨" : "ë¡œë”©/ë¶ˆì•ˆì •"));
    lines.push("ë§ˆì§€ë§‰ ë©”ì‹œì§€: " + (lastMsg || "-"));

    statusPanel.textContent = lines.join("\n");
  }

  // =============================
  // solve í˜¸ì¶œ + TTS
  // =============================
  async function triggerSolve(force, reason, becauseInsufficient = false) {
    if (solvedOnce && !force) return;
    solvedOnce = true;

    const acc = getAccumulatedText();
    let sendText = acc;

    if (sendText.length > MAX_SEND_CHARS) {
      sendText = sendText.slice(sendText.length - MAX_SEND_CHARS);
    }

    const accLen = effectiveLen(sendText);

    if (!force && accLen < 80) {
      // ë„ˆë¬´ ì§§ìœ¼ë©´ ì˜ë¯¸ê°€ ì—†ìŒ â†’ ë‹¤ì‹œ í’€ê¸° ê°€ëŠ¥í•˜ë„ë¡ solvedOnce ë˜ëŒë¦¼
      solvedOnce = false;
      return;
    }

    answerOut.textContent = "í’€ì´ ìƒì„± ì¤‘...\n" + reason;

    try {
      const payload = {
        mode: "NONSUL",
        ocr_text: sendText,
        ocrText: sendText
      };

      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();
      let answerText = "";

      if (ct.includes("application/json")) {
        const data = await res.json();
        answerText = (data && data.answer) ? String(data.answer) : JSON.stringify(data);
      } else {
        answerText = await res.text();
      }

      if (!res.ok) {
        answerOut.textContent = "ì„œë²„ ì—ëŸ¬(" + res.status + ")\n" + answerText.slice(0, 2000);
        solvedOnce = false; // ì‹¤íŒ¨ë©´ ë‹¤ì‹œ ì‹œë„ ê°€ëŠ¥
        return;
      }

      if (becauseInsufficient) {
        answerText = "â€» ì§€ë¬¸ì´ ë¶€ì¡±í•˜ì—¬ í˜„ì¬ê¹Œì§€ë¡œ ìë™ í’€ì´í•©ë‹ˆë‹¤.\n\n" + answerText;
      }

      answerOut.textContent = answerText;
      speak(answerText);
    } catch (e) {
      answerOut.textContent = "solve í˜¸ì¶œ ì‹¤íŒ¨: " + String(e && e.message ? e.message : e);
      solvedOnce = false;
    }
  }

  // =============================
  // ìë™ ë£¨í”„ ì‹œì‘
  // =============================
  async function boot() {
    await startCamera();
    await initOcrEngine();

    // ìƒíƒœ ì´ˆê¸° ë Œë”
    const a = analyzeFrame();
    renderStatus(a.blocked, a.stable, a.distanceHint, "ì‹œì‘");

    // OCR ì£¼ê¸° ì‹¤í–‰(ë©ˆì¶”ì§€ ì•Šê²Œ setInterval)
    setInterval(() => {
      // ì—”ì§„ ë¡œë”© ì¤‘ì´ë©´ ìƒíƒœë§Œ ê°±ì‹ 
      const af = analyzeFrame();
      if (!engineReady) {
        renderStatus(af.blocked, af.stable, af.distanceHint, "OCR ì—”ì§„ ë¡œë”©/ë¶ˆì•ˆì •");
        return;
      }
      // ë„ˆë¬´ ìì£¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡ ìµœì†Œ ê°„ê²© ë³´í˜¸
      if (Date.now() - lastOcrAt < (OCR_INTERVAL_MS - 200)) return;

      runOcrOnce();
    }, OCR_INTERVAL_MS);
  }

  boot();
})();
</script>
</body>
</html>




