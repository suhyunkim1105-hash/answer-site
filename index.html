<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Answer Site</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { max-width: 820px; margin: 32px auto; padding: 0 16px; }
    textarea { width: 100%; min-height: 120px; padding: 12px; font-size: 16px; }
    button { padding: 10px 16px; font-size: 16px; cursor: pointer; }
    .row { display: flex; gap: 10px; align-items: center; margin: 12px 0; flex-wrap: wrap; }
    .out { white-space: pre-wrap; background: #f6f7f8; padding: 12px; border-radius: 8px; min-height: 48px; }
    .muted { color: #666; font-size: 14px; }
    .error { color: #b00020; }
    .cam-wrap { position: relative; display: inline-block; max-width: 100%; }
    #preview { max-width: 100%; border-radius: 8px; display: none; }
    #roiCanvas {
      position: absolute; inset: 0; display: none;
      touch-action: none; /* 모바일 드래그 허용 */
    }
    .hint { font-size: 13px; color:#555; }
    .panel label { display:block; font-size:13px; margin-bottom:4px; }
    .panel input[type=range]{ width:220px; }
  </style>
</head>
<body>
  <h1>정답 풀이 테스트</h1>
  <p class="muted">질문을 적고 <b>보내기</b>를 누르면 <code>/.netlify/functions/solve</code>로 POST합니다.</p>

  <textarea id="q" placeholder="여기에 질문/문제 텍스트를 입력하거나 OCR로 채워보세요."></textarea>
  <div class="row">
    <button id="send">보내기</button>
    <span id="status" class="muted"></span>
  </div>

  <h3>결과</h3>
  <div id="out" class="out"></div>

  <hr>
  <h3>카메라 · OCR · 음성</h3>

  <div class="row">
    <button id="camStart">카메라 켜기</button>
    <button id="camShot" disabled>캡처 → OCR</button>
    <button id="camStop" disabled>카메라 끄기</button>
    <button id="speak" disabled>정답만 읽어주기(TTS)</button>
    <span id="ocrStatus" class="muted"></span>
  </div>

  <div class="row" style="align-items:center">
    <label style="display:flex; gap:8px; align-items:center">
      <input type="checkbox" id="autoMode">
      <span>자동 모드(안정 시 자동 풀이)</span>
    </label>
    <span id="autoStatus" class="muted"></span>
  </div>

  <!-- 자동 모드 파라미터 조절 패널 -->
  <div id="autoPanel" class="row panel" style="gap:18px; align-items:flex-end">
    <div>
      <label>민감도(변화 허용 비율)
        <input id="inpThreshold" type="range" min="0.03" max="0.30" step="0.01" value="0.15">
      </label>
      <div class="muted">현재: <span id="lblThreshold">0.15</span></div>
    </div>

    <div>
      <label>체크 주기(ms)
        <input id="inpInterval" type="range" min="200" max="1500" step="50" value="800">
      </label>
      <div class="muted">현재: <span id="lblInterval">800</span> ms</div>
    </div>

    <div>
      <label>안정 시간(s)
        <input id="inpStable" type="range" min="1" max="8" step="1" value="3">
      </label>
      <div class="muted">현재: <span id="lblStable">3</span> s</div>
    </div>

    <div>
      <label>쿨다운(s)
        <input id="inpCooldown" type="range" min="5" max="30" step="1" value="10">
      </label>
      <div class="muted">현재: <span id="lblCooldown">10</span> s</div>
    </div>
  </div>

  <div class="hint">TIP: 비디오 위를 <b>드래그</b>하면 파란 박스로 <b>영역 지정</b>이 됩니다. 지정한 영역만 OCR합니다.</div>

  <div class="cam-wrap">
    <video id="preview" autoplay playsinline></video>
    <canvas id="roiCanvas"></canvas>
  </div>
  <canvas id="frame" style="display:none"></canvas>

  <!-- Tesseract.js (OCR) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    /* ===== 질문 전송 ===== */
    const $q = document.getElementById('q');
    const $btn = document.getElementById('send');
    const $out = document.getElementById('out');
    const $status = document.getElementById('status');

    async function ask() {
      const question = ($q.value || '').trim();
      if (!question) { $out.textContent = ''; $status.textContent = '질문을 입력하세요.'; return; }
      $status.textContent = '요청 중...'; $btn.disabled = true; $out.textContent = '';
      try {
        const res = await fetch('/.netlify/functions/solve', {
          method: 'POST', headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ question })
        });
        const ct = res.headers.get('content-type') || '';
        let answerText = '';
        if (ct.includes('application/json')) {
          const data = await res.json(); answerText = data.answer ?? JSON.stringify(data, null, 2);
        } else {
          const text = await res.text(); try { const maybe = JSON.parse(text); answerText = maybe.answer ?? text; } catch { answerText = text; }
        }
        $out.textContent = answerText;
        $status.textContent = res.ok ? '완료' : `에러: ${res.status}`;
      } catch (err) {
        console.error(err); $status.innerHTML = `<span class="error">요청 실패: ${String(err)}</span>`;
      } finally { $btn.disabled = false; }
    }
    $btn.addEventListener('click', ask);
    $q.addEventListener('keydown', (e) => { if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) ask(); });

    /* ===== 카메라 + ROI + OCR + TTS ===== */
    const $video = document.getElementById('preview');
    const $canvas = document.getElementById('frame');
    const $roiCanvas = document.getElementById('roiCanvas');
    const $camStart = document.getElementById('camStart');
    const $camShot  = document.getElementById('camShot');
    const $camStop  = document.getElementById('camStop');
    const $speak    = document.getElementById('speak');
    const $ocrStatus = document.getElementById('ocrStatus');

    let stream;
    async function startCamera() {
      try {
        $ocrStatus.textContent = '카메라 권한 요청 중...';
        stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
        $video.srcObject = stream; $video.style.display = 'block';
        $roiCanvas.style.display = 'block'; resizeOverlay();
        $camShot.disabled = false; $camStop.disabled = false;
        $ocrStatus.textContent = '카메라 ON';
      } catch (e) { console.error(e); $ocrStatus.textContent = '카메라 접근 실패: ' + e.message; }
    }
    function stopCamera() {
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      $video.srcObject = null; $video.style.display = 'none'; $roiCanvas.style.display = 'none';
      $camShot.disabled = true; $camStop.disabled = true; $ocrStatus.textContent = '카메라 OFF';
    }

    // ROI 드래그
    let dragging = false, roi = null;
    function resizeOverlay() {
      const rect = $video.getBoundingClientRect();
      $roiCanvas.width = rect.width; $roiCanvas.height = rect.height;
      $roiCanvas.style.width = rect.width+'px'; $roiCanvas.style.height = rect.height+'px';
      $roiCanvas.style.left = $video.offsetLeft+'px'; $roiCanvas.style.top = $video.offsetTop+'px';
      drawROI();
    }
    window.addEventListener('resize', () => { if ($video.style.display !== 'none') resizeOverlay(); });
    function drawROI() {
      const ctx = $roiCanvas.getContext('2d'); ctx.clearRect(0,0,$roiCanvas.width,$roiCanvas.height);
      if (!roi) return;
      ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(0,0,$roiCanvas.width,$roiCanvas.height);
      ctx.clearRect(roi.x, roi.y, roi.w, roi.h);
      ctx.strokeStyle='#3b82f6'; ctx.lineWidth=2; ctx.strokeRect(roi.x, roi.y, roi.w, roi.h);
    }
    function startDrag(e){ dragging=true; const p=pointerPos(e); roi={x:p.x,y:p.y,w:0,h:0}; drawROI(); }
    function moveDrag(e){ if(!dragging) return; const p=pointerPos(e);
      roi.w=p.x-roi.x; roi.h=p.y-roi.y;
      const nx=Math.min(roi.x,roi.x+roi.w), ny=Math.min(roi.y,roi.y+roi.h);
      const nw=Math.abs(roi.w), nh=Math.abs(roi.h); roi={x:nx,y:ny,w:nw,h:nh}; drawROI();
    }
    function endDrag(){ dragging=false; }
    function pointerPos(e){ const r=$roiCanvas.getBoundingClientRect();
      const x=e.touches?e.touches[0].clientX:e.clientX, y=e.touches?e.touches[0].clientY:e.clientY;
      return {x:Math.max(0,Math.min(r.width,x-r.left)), y:Math.max(0,Math.min(r.height,y-r.top))}; }
    $roiCanvas.addEventListener('mousedown', startDrag);
    $roiCanvas.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);
    $roiCanvas.addEventListener('touchstart', e=>{e.preventDefault();startDrag(e);},{passive:false});
    $roiCanvas.addEventListener('touchmove',  e=>{e.preventDefault();moveDrag(e); },{passive:false});
    $roiCanvas.addEventListener('touchend',   e=>{e.preventDefault();endDrag();   },{passive:false});

    async function captureAndOCR() {
      if (!$video.srcObject) return;
      $ocrStatus.textContent = '캡처 중...';

      const vw=$video.videoWidth||1280, vh=$video.videoHeight||720;
      $canvas.width=vw; $canvas.height=vh; const ctx=$canvas.getContext('2d');
      ctx.drawImage($video,0,0,vw,vh);

      let sourceCanvas=$canvas;
      if (roi && roi.w>8 && roi.h>8) {
        const vis=$video.getBoundingClientRect();
        const sx=Math.round(roi.x*(vw/vis.width)),  sy=Math.round(roi.y*(vh/vis.height));
        const sw=Math.round(roi.w*(vw/vis.width)),  sh=Math.round(roi.h*(vh/vis.height));
        const crop=document.createElement('canvas'); crop.width=sw; crop.height=sh;
        crop.getContext('2d').drawImage($canvas,sx,sy,sw,sh,0,0,sw,sh);
        sourceCanvas=crop;
      }

      $ocrStatus.textContent='OCR 인식 중...';
      try {
        const { data } = await Tesseract.recognize(sourceCanvas, 'kor+eng', {
          langPath: 'https://tessdata.projectnaptha.com/4.0.0',
          logger: m=>{
            if (m.status==='recognizing text' && typeof m.progress==='number')
              $ocrStatus.textContent=`OCR 진행률: ${Math.round(m.progress*100)}%`;
            else if (m.status) $ocrStatus.textContent=m.status.replace(/_/g,' ');
          }
        });
        const text=(data?.text||'').trim();
        if (text){ document.getElementById('q').value=text; $ocrStatus.textContent='OCR 완료 ✅'; }
        else { $ocrStatus.textContent='문자 인식 실패. 더 밝고 선명하게 다시 시도해주세요.'; }
      } catch(e){ console.error(e); $ocrStatus.textContent='OCR 오류: '+e.message; }
    }

    function extractAnswerOnly(fullText){
      if (!fullText) return '';
      const m1 = fullText.match(/(?:정답|answer)\s*[:：]\s*([^\n]+)/i);
      if (m1) return m1[1].trim();
      const line = fullText.split(/\r?\n/).find(l=>/정답|answer/i.test(l));
      if (line) return line.replace(/.*?(정답|answer)\s*[:：]?\s*/i,'').trim();
      return fullText.split(/\r?\n/)[0].trim();
    }
    function speakResult(){
      const full=$out.textContent.trim(); if(!full){ $ocrStatus.textContent='읽을 결과가 없습니다.'; return; }
      const key=extractAnswerOnly(full); const u=new SpeechSynthesisUtterance(key||full);
      u.lang='ko-KR'; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
    }
    $camStart.addEventListener('click', startCamera);
    $camStop .addEventListener('click', stopCamera);
    $camShot .addEventListener('click', captureAndOCR);
    $speak  .addEventListener('click', speakResult);

    // 결과 생기면 TTS 버튼 활성화
    const outObserver=new MutationObserver(()=>{ $speak.disabled=!($out.textContent||'').trim().length; });
    outObserver.observe($out,{childList:true,subtree:true,characterData:true});

    /* ===== 자동 모드 (안정 → 캡처→OCR→ask→자동 TTS) ===== */
    const $auto = document.getElementById('autoMode');
    const $autoStatus = document.getElementById('autoStatus');

    // 가변 파라미터(슬라이더로 변경)
    let DIFF_THRESHOLD = 0.15;   // 변화 허용 비율
    let CHECK_INTERVAL = 800;    // ms
    let STABLE_MS      = 3000;   // ms
    let COOLDOWN_MS    = 10000;  // ms

    // 슬라이더 DOM & 라벨
    const $inpThreshold=document.getElementById('inpThreshold');
    const $inpInterval =document.getElementById('inpInterval');
    const $inpStable   =document.getElementById('inpStable');
    const $inpCooldown =document.getElementById('inpCooldown');
    const $lblThreshold=document.getElementById('lblThreshold');
    const $lblInterval =document.getElementById('lblInterval');
    const $lblStable   =document.getElementById('lblStable');
    const $lblCooldown =document.getElementById('lblCooldown');

    function applyPanelValues(){
      DIFF_THRESHOLD=parseFloat($inpThreshold.value);
      CHECK_INTERVAL=parseInt($inpInterval.value,10);
      STABLE_MS     =parseInt($inpStable.value,10)*1000;
      COOLDOWN_MS   =parseInt($inpCooldown.value,10)*1000;

      $lblThreshold.textContent=DIFF_THRESHOLD.toFixed(2);
      $lblInterval.textContent =CHECK_INTERVAL;
      $lblStable.textContent   =(STABLE_MS/1000).toFixed(0);
      $lblCooldown.textContent =(COOLDOWN_MS/1000).toFixed(0);

      if (autoLoopId){ stopAuto(); startAuto(); } // 실행 중이면 새 값 즉시 반영
    }
    [$inpThreshold,$inpInterval,$inpStable,$inpCooldown].forEach(el=>el.addEventListener('input',applyPanelValues));
    applyPanelValues();

    let autoLoopId=null, lastImageData=null, stableSince=0, cooldownUntil=0;

    function frameDiffRatio(){
      if (!$video.srcObject || !$video.videoWidth) return 1;
      const w=640, h=Math.round(w*($video.videoHeight/$video.videoWidth));
      const tmp=$canvas.getContext('2d');
      $canvas.width=w; $canvas.height=h; tmp.drawImage($video,0,0,w,h);
      const cur=tmp.getImageData(0,0,w,h).data; let diff=0, total=w*h;
      if (!lastImageData){ lastImageData=cur; return 1; }
      for(let i=0;i<cur.length;i+=4){
        const dr=cur[i]-lastImageData[i], dg=cur[i+1]-lastImageData[i+1], db=cur[i+2]-lastImageData[i+2];
        const delta=Math.abs(dr)+Math.abs(dg)+Math.abs(db); if (delta>60) diff++;
      }
      lastImageData=cur; return diff/total;
    }

    async function captureOCRAndAsk(){
      await captureAndOCR();
      const q=($q.value||'').trim();
      if (q.length>0){ await ask(); speakResult(); }  // 자동 TTS
    }

    function startAuto(){
      if (!$video.srcObject){ $ocrStatus.textContent='먼저 카메라를 켜주세요.'; $auto.checked=false; return; }
      stableSince=0; lastImageData=null; $autoStatus.textContent='자동 모드 ON';
      autoLoopId=setInterval(async ()=>{
        const now=Date.now();
        if (now<cooldownUntil){ $ocrStatus.textContent=`자동 대기 중… ${Math.ceil((cooldownUntil-now)/1000)}s`; return; }
        const ratio=frameDiffRatio();
        if (ratio<DIFF_THRESHOLD){
          if (!stableSince) stableSince=now;
          const remain=Math.max(0,STABLE_MS-(now-stableSince));
          $ocrStatus.textContent=`안정 감지 중… ${Math.ceil(remain/1000)}s`;
          if (now-stableSince>=STABLE_MS){
            $ocrStatus.textContent='자동 캡처 → OCR 실행!'; cooldownUntil=now+COOLDOWN_MS; stableSince=0;
            try{ await captureOCRAndAsk(); }catch(e){ console.error(e); }
          }
        }else{
          stableSince=0; $ocrStatus.textContent='움직임 감지됨(대기)…';
        }
      }, CHECK_INTERVAL);
    }
    function stopAuto(){ if (autoLoopId) clearInterval(autoLoopId); autoLoopId=null; $autoStatus.textContent='자동 모드 OFF'; $ocrStatus.textContent='대기'; }
    $auto.addEventListener('change', ()=>{ if($auto.checked) startAuto(); else stopAuto(); });

    // 카메라가 꺼지면 자동 모드도 종료
    const _origStop=stopCamera; stopCamera=function(){ stopAuto(); _origStop(); };
  </script>
</body>
</html>
