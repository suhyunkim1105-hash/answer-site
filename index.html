<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì—°ì„¸ëŒ€ ë…¼ìˆ  OCR â†’ ë³µë¶™ â†’ TTS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 12px;
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      background: #050505;
      color: #fff;
    }
    h1 {
      font-size: 17px;
      margin: 4px 0 10px;
      font-weight: 650;
    }
    #status {
      margin-top: 4px;
      font-size: 12px;
      white-space: pre-wrap;
      padding: 8px 10px;
      border-radius: 10px;
      border: 1px solid #333;
      background: #0c0c0c;
      min-height: 34px;
    }
    .btn-col {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 10px;
    }
    button {
      width: 100%;
      padding: 10px 14px;
      font-size: 15px;
      border-radius: 14px;
      border: 1px solid #555;
      background: #151515;
      color: #fff;
    }
    button:active {
      transform: scale(0.98);
    }
    #ttsHint {
      margin-top: 6px;
      font-size: 11px;
      color: #aaa;
    }
    #ttsBox {
      width: 100%;
      min-height: 130px;
      margin-top: 6px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid #333;
      background: #060606;
      color: #fff;
      font-size: 12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space: pre-wrap;
    }
    #videoBox {
      margin-top: 10px;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      border: 1px solid #333;
    }
    video {
      width: 100%;
      height: auto;
      display: block;
      object-fit: contain;
      transform: translateZ(0);
    }
    #shotsInfo {
      margin-top: 6px;
      font-size: 11px;
      color: #888;
    }
    #chartGalleryLabel {
      margin-top: 6px;
      font-size: 11px;
      color: #bbb;
    }
    #chartGallery {
      margin-top: 4px;
      display: flex;
      gap: 6px;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 4px;
    }
    .chartThumbWrap {
      flex: 0 0 auto;
      width: 70px;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #444;
      background: #000;
      position: relative;
    }
    .chartThumbWrap span {
      position: absolute;
      left: 4px;
      top: 2px;
      font-size: 9px;
      background: rgba(0,0,0,0.6);
      padding: 1px 3px;
      border-radius: 3px;
    }
    .chartThumb {
      width: 100%;
      display: block;
    }
    #shotsGalleryLabel {
      margin-top: 6px;
      font-size: 11px;
      color: #bbb;
    }
    #shotsGallery {
      margin-top: 4px;
      display: flex;
      gap: 6px;
      flex-wrap: nowrap;
      overflow-x: auto;
      padding-bottom: 4px;
    }
    .shotThumbWrap {
      flex: 0 0 auto;
      width: 70px;
      border-radius: 6px;
      overflow: hidden;
      border: 1px solid #555;
      background: #000;
      position: relative;
    }
    .shotThumbWrap span {
      position: absolute;
      left: 4px;
      top: 2px;
      font-size: 9px;
      background: rgba(0,0,0,0.6);
      padding: 1px 3px;
      border-radius: 3px;
    }
    .shotThumb {
      width: 100%;
      display: block;
    }
    #ocrBox {
      width: 100%;
      min-height: 120px;
      margin-top: 8px;
      padding: 8px;
      border-radius: 10px;
      border: 1px solid #333;
      background: #050505;
      color: #ccc;
      font-size: 11px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space: pre-wrap;
    }
    #errOverlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.94);
      color: #fff;
      display: none;
      padding: 14px;
      z-index: 9999;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space: pre-wrap;
    }
    #errOverlay button {
      margin-top: 10px;
      width: auto;
    }
  </style>
</head>

<body>
  <div id="errOverlay"></div>

  <h1>ì—°ì„¸ëŒ€ ë…¼ìˆ  OCR â†’ ë³µë¶™ â†’ TTS</h1>
  <div id="status">ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...</div>

  <!-- ë§¨ ìœ„ ë²„íŠ¼ 2ê°œ -->
  <div class="btn-col">
    <button id="btnAuto">ğŸ“¸ ìë™ OCR ì‹œì‘/ì •ì§€</button>
    <button id="btnShare">ğŸ”— ChatGPTë¡œ ê³µìœ  (í…ìŠ¤íŠ¸+ë„í‘œ ìƒ·)</button>
  </div>

  <div id="ttsHint">
    ì—¬ê¸°ì— ChatGPT ìµœì¢… ë‹µì•ˆì„ ë¶™ì—¬ë„£ìœ¼ë©´ 0.9ë°°ì†ìœ¼ë¡œ ê³„ì† ë°˜ë³µ ì¬ìƒëœë‹¤.<br/>
    â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼.
  </div>
  <textarea id="ttsBox" placeholder="ChatGPT ìµœì¢… ë‹µì•ˆì„ ì—¬ê¸° ë¶™ì—¬ë„£ê¸°"></textarea>

  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <div id="shotsInfo"></div>
  <div id="chartGalleryLabel"></div>
  <div id="chartGallery"></div>
  <div id="shotsGalleryLabel"></div>
  <div id="shotsGallery"></div>

  <textarea id="ocrBox" placeholder="OCR ëˆ„ì  í…ìŠ¤íŠ¸ (ì ê²€ìš©)"></textarea>

<script>
(function(){
  "use strict";

  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnAuto = document.getElementById("btnAuto");
  const btnShare = document.getElementById("btnShare");
  const ttsBox = document.getElementById("ttsBox");
  const ocrBox = document.getElementById("ocrBox");
  const shotsInfo = document.getElementById("shotsInfo");
  const chartGallery = document.getElementById("chartGallery");
  const chartGalleryLabel = document.getElementById("chartGalleryLabel");
  const shotsGallery = document.getElementById("shotsGallery");
  const shotsGalleryLabel = document.getElementById("shotsGalleryLabel");
  const errOverlay = document.getElementById("errOverlay");

  const OCR_URL = "/.netlify/functions/ocr";

  let stream = null;
  let autoRunning = false;
  let currentPage = 1;
  const MAX_PAGES = 16;
  const SHOTS_PER_PAGE = 3;

  let shotIndex = 0;
  let allText = "";
  let shots = [];
  let chartImages = [];
  let lastFrameDataUrl = null;

  function setStatus(msg) {
    statusEl.textContent = msg;
  }

  function showErrorOverlay(title, detail) {
    try {
      errOverlay.style.display = "block";
      errOverlay.textContent = "[ERROR]\n" + title + "\n\n" + (detail || "") + "\n\n(ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ë‹«í˜)";
      const btn = document.createElement("button");
      btn.textContent = "ë‹«ê¸°";
      btn.onclick = () => {
        errOverlay.style.display = "none";
        errOverlay.innerHTML = "";
      };
      errOverlay.appendChild(document.createElement("br"));
      errOverlay.appendChild(btn);
    } catch (e) {}
  }

  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  async function startCamera() {
    try {
      setStatus("ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­ ì¤‘...");
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        },
        audio: false
      });
      video.srcObject = stream;
      setStatus("ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ. ì‹œí—˜ì§€ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë§ì¶˜ ë’¤ ìë™ OCRì„ ì‹œì‘í•˜ë¼.");
    } catch (e) {
      setStatus("ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨: " + (e.message || String(e)));
      showErrorOverlay("ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨", e && e.stack ? e.stack : String(e));
    }
  }

  function captureFrameDataUrl() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) return null;
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);
    return canvas.toDataURL("image/jpeg", 0.9);
  }

  async function ocrOneShot(pageIndex) {
    const dataUrl = captureFrameDataUrl();
    lastFrameDataUrl = dataUrl;
    if (!dataUrl) {
      setStatus("ì˜ìƒ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤. 1~2ì´ˆ í›„ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.");
      return { ok: false, message: "NO_FRAME" };
    }

    try {
      const res = await fetch(OCR_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          imageBase64: dataUrl,
          pageIndex,
          mode: "dual"
        })
      });
      const json = await res.json().catch(() => null);
      if (!json || !json.ok) {
        const msg = (json && (json.message || json.error)) || "OCR ì‹¤íŒ¨";
        return { ok: false, message: msg };
      }
      return {
        ok: true,
        text: json.text || "",
        conf: typeof json.conf === "number" ? json.conf : 0,
        dataUrl
      };
    } catch (e) {
      return { ok: false, message: e.message || String(e) };
    }
  }

  function updateChartGallery() {
    chartGallery.innerHTML = "";
    if (!chartImages.length) {
      chartGalleryLabel.textContent = "";
      return;
    }
    chartGalleryLabel.textContent = `ë„í‘œ ìƒ· ëˆ„ì  (${chartImages.length}ê°œ): (ChatGPTë¡œ ê³µìœ ì‹œ í•¨ê»˜ ì „ì†¡ ì‹œë„)`;
    chartImages.forEach((item, idx) => {
      const wrap = document.createElement("div");
      wrap.className = "chartThumbWrap";
      const badge = document.createElement("span");
      badge.textContent = `P${item.page}`;
      const img = document.createElement("img");
      img.className = "chartThumb";
      img.src = item.dataUrl;
      wrap.appendChild(img);
      wrap.appendChild(badge);
      chartGallery.appendChild(wrap);
    });
  }

  function updateShotsGallery() {
    shotsGallery.innerHTML = "";
    if (!shots.length) {
      shotsGalleryLabel.textContent = "";
      return;
    }
    shotsGalleryLabel.textContent = `ì´¬ì˜ ìƒ· ëˆ„ì  (${shots.length}ê°œ):`;
    shots.forEach((s) => {
      if (!s.dataUrl) return;
      const wrap = document.createElement("div");
      wrap.className = "shotThumbWrap";
      const badge = document.createElement("span");
      badge.textContent = `P${s.page}`;
      const img = document.createElement("img");
      img.className = "shotThumb";
      img.src = s.dataUrl;
      wrap.appendChild(img);
      wrap.appendChild(badge);
      shotsGallery.appendChild(wrap);
    });
  }

  function updateShotsInfo() {
    if (!shots.length) {
      shotsInfo.textContent = "";
      return;
    }
    const last = shots[shots.length - 1];
    const chartCount = chartImages.length;
    const chartMark = chartCount ? ` / ë„í‘œ ìƒ· ${chartCount}ê°œ ëˆ„ì ` : "";
    shotsInfo.textContent =
      `í˜„ì¬ê¹Œì§€ ìƒ· ${shots.length}ê°œ ëˆ„ì  (ë§ˆì§€ë§‰: í˜ì´ì§€ ${last.page}, ì‹ ë¢°ë„ ëŒ€ëµ ${last.conf.toFixed(1)}%)` +
      chartMark;
  }

  function appendShot(pageIndex, text, conf, dataUrl) {
    shotIndex += 1;
    const clean = String(text || "").trim();
    const head = `[ìƒ· ${shotIndex}] ---------------------- (í˜ì´ì§€ ${pageIndex}, ì‹ ë¢°ë„ ëŒ€ëµ ${conf.toFixed(1)}%)`;
    if (allText) allText += "\n\n";
    allText += head + "\n" + clean;
    ocrBox.value = allText;

    const isChart = clean.includes("ë„í‘œì…ë‹ˆë‹¤") || clean.includes("ë„í‘œ ");
    if (isChart && dataUrl) {
      chartImages.push({ page: pageIndex, dataUrl });
      updateChartGallery();
    }

    shots.push({ idx: shotIndex, page: pageIndex, text: clean, conf, dataUrl, isChart });
    updateShotsInfo();
    updateShotsGallery();

    // â˜… ì—¬ê¸° ìˆ˜ì •: "í’€ì´ ì‹œì‘" ëŒ€ì‹  "ë¬¸ì œ 1 / ë¬¸ì œ 2"ê°€ ë³´ì´ë©´ ë§ˆì§€ë§‰ í˜ì´ì§€ë¡œ íŒë‹¨
    const isLastPage =
      /ë¬¸ì œ\s*1/.test(clean) ||
      /ë¬¸ì œ\s*2/.test(clean);

    return { isChart, isLastPage };
  }

  /* ===== ë‹µì•ˆ TTS (ë‹¨ì–´ ì‚¬ì´ 3ì´ˆ, ê¸°í˜¸ ë§ë¡œ ì½ê¸°) ===== */

  let ttsPrimed = false;
  const ANSWER_RATE = 0.9;
  let answerTtsStop = false;

  function primeTTS() {
    if (ttsPrimed) return;
    ttsPrimed = true;
    try {
      const u = new SpeechSynthesisUtterance("ìŒì„± ì—°ê²°");
      u.lang = "ko-KR";
      u.rate = 1.0;
      u.onend = () => {
        window.speechSynthesis.cancel();
      };
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  function preprocessAnswerForTTS(raw) {
    let t = String(raw || "");

    t = t.replace(/\r/g, "");
    t = t.replace(/\n+/g, " ì¤„ë°”ê¿ˆ ");

    t = t.replace(/\./g, " ë§ˆì¹¨í‘œ ");
    t = t.replace(/,/g, " ì‰¼í‘œ ");

    t = t.replace(/\(/g, " ì†Œê´„í˜¸ ì—¬ëŠ” ê´„í˜¸ ");
    t = t.replace(/\)/g, " ì†Œê´„í˜¸ ë‹«ëŠ” ê´„í˜¸ ");
    t = t.replace(/\[/g, " ëŒ€ê´„í˜¸ ì—¬ëŠ” ê´„í˜¸ ");
    t = t.replace(/\]/g, " ëŒ€ê´„í˜¸ ë‹«ëŠ” ê´„í˜¸ ");
    t = t.replace(/</g, " êº¾ì‡  ì—¬ëŠ” ê´„í˜¸ ");
    t = t.replace(/>/g, " êº¾ì‡  ë‹«ëŠ” ê´„í˜¸ ");

    t = t.replace(/"/g, " í°ë”°ì˜´í‘œ ");
    t = t.replace(/'/g, " ì‘ì€ë”°ì˜´í‘œ ");

    t = t.replace(/%/g, " í¼ì„¼íŠ¸ ");
    t = t.replace(/\*/g, " ë³„í‘œ ");
    t = t.replace(/-/g, " ë¹¼ê¸° ê¸°í˜¸ ");
    t = t.replace(/_/g, " ë°‘ì¤„ ");

    t = t.replace(/\s+/g, " ").trim();
    return t;
  }

  function speakAnswerWithLongGaps(text) {
    if (!window.speechSynthesis) return;

    primeTTS();

    const processed = preprocessAnswerForTTS(text);
    const tokens = processed.split(" ").filter(Boolean);
    if (!tokens.length) return;

    answerTtsStop = false;
    window.speechSynthesis.cancel();

    let idx = 0;

    function speakNext() {
      if (answerTtsStop) return;

      if (idx >= tokens.length) {
        idx = 0;
        setTimeout(speakNext, 1500);
        return;
      }

      const word = tokens[idx++];
      const u = new SpeechSynthesisUtterance(word);
      u.lang = "ko-KR";
      u.rate = ANSWER_RATE;
      u.pitch = 1.0;

      u.onend = () => {
        if (answerTtsStop) return;
        setTimeout(speakNext, 3000); // â˜… 7ì´ˆ â†’ 3ì´ˆ
      };

      u.onerror = () => {
        if (answerTtsStop) return;
        setTimeout(speakNext, 3000); // â˜… 7ì´ˆ â†’ 3ì´ˆ
      };

      window.speechSynthesis.speak(u);
    }

    speakNext();
  }

  ttsBox.addEventListener("input", () => {
    const txt = (ttsBox.value || "").trim();

    if (!txt) {
      answerTtsStop = true;
      if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
      }
      return;
    }

    speakAnswerWithLongGaps(txt);
  });

  function stopAnswerTTS() {
    answerTtsStop = true;
    if (window.speechSynthesis) {
      window.speechSynthesis.cancel();
    }
  }

  /* ===== ì—¬ê¸°ê¹Œì§€ TTS ===== */

  async function autoOCRLoop() {
    if (autoRunning) {
      autoRunning = false;
      setStatus("ìë™ OCR ì¤‘ì§€ ìš”ì²­ë¨.");
      return;
    }

    if (!video.videoWidth || !video.videoHeight) {
      setStatus("ì¹´ë©”ë¼ ì˜ìƒì´ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. 1~2ì´ˆ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.");
      return;
    }

    autoRunning = true;
    currentPage = 1;
    shotIndex = 0;
    allText = "";
    shots = [];
    chartImages = [];
    ocrBox.value = "";
    updateShotsInfo();
    updateChartGallery();
    updateShotsGallery();
    setStatus("1ë¶„ ëŒ€ê¸° í›„ ì‹œì‘í•©ë‹ˆë‹¤. ì‹œí—˜ì§€ë¥¼ ì •ë ¬í•˜ì„¸ìš”.");
    primeTTS();

    const notice = new SpeechSynthesisUtterance("1ë¶„ ë’¤ì— ìë™ ì˜¤ì”¨ì•Œì„ ì‹œì‘í•©ë‹ˆë‹¤.");
    notice.lang = "ko-KR";
    notice.rate = 1.0;
    window.speechSynthesis.speak(notice);

    await sleep(60000);
    if (!autoRunning) { setStatus("ìë™ OCRì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."); return; }

    const notice2 = new SpeechSynthesisUtterance("10ì´ˆ ë’¤ì— ì‹œì‘í•©ë‹ˆë‹¤.");
    notice2.lang = "ko-KR";
    notice2.rate = 1.0;
    window.speechSynthesis.speak(notice2);

    await sleep(10000);
    if (!autoRunning) { setStatus("ìë™ OCRì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤."); return; }

    while (autoRunning && currentPage <= MAX_PAGES) {
      setStatus(`í˜ì´ì§€ ${currentPage} ìë™ OCR ì¤‘...(ì´ ${SHOTS_PER_PAGE}íšŒ ì´¬ì˜)`);

      // ê° í˜ì´ì§€ 3íšŒ ì¤‘ conf ê°€ì¥ ë†’ì€ ìƒ·ë§Œ ì„ íƒ
      let bestShot = null;

      for (let i = 0; i < SHOTS_PER_PAGE && autoRunning; i++) {
        const r = await ocrOneShot(currentPage);
        if (!r.ok) continue;

        if (!bestShot || (typeof r.conf === "number" && r.conf > (bestShot.conf || 0))) {
          bestShot = r;
        }
      }

      if (!bestShot) {
        setStatus(`í˜ì´ì§€ ${currentPage}ì—ì„œ OCRì— ëª¨ë‘ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì‹œí—˜ì§€ë¥¼ ë‹¤ì‹œ ë§ì¶˜ ë’¤ ìë™ OCRì„ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.`);
        const failUtter = new SpeechSynthesisUtterance("ì´ í˜ì´ì§€ ì˜¤ì”¨ì•Œì— ëª¨ë‘ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë§ì¶”ê³  ìë™ ì˜¤ì”¨ì•Œì„ ë‹¤ì‹œ ì‹œì‘í•˜ì„¸ìš”.");
        failUtter.lang = "ko-KR";
        failUtter.rate = 1.0;
        window.speechSynthesis.speak(failUtter);
        autoRunning = false;
        break;
      }

      const info = appendShot(currentPage, bestShot.text, bestShot.conf || 0, bestShot.dataUrl || lastFrameDataUrl);

      if (info.isLastPage) {
        setStatus(`í˜ì´ì§€ ${currentPage} ì¸ì‹ ì™„ë£Œ. ë§ˆì§€ë§‰ í˜ì´ì§€ë¡œ íŒë‹¨ë˜ì–´ ìë™ OCRì„ ì¢…ë£Œí•©ë‹ˆë‹¤.`);
        const lastUtter = new SpeechSynthesisUtterance("ì´ í˜ì´ì§€ ì¸ì‹ ì™„ë£Œ. ì´ì œ ë§ˆì§€ë§‰ í˜ì´ì§€ì…ë‹ˆë‹¤.");
        lastUtter.lang = "ko-KR";
        lastUtter.rate = 1.0;
        window.speechSynthesis.speak(lastUtter);
        autoRunning = false;
        break;
      } else {
        setStatus(`í˜ì´ì§€ ${currentPage} ì¸ì‹ ì™„ë£Œ. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”. 5ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¥¼ ì¸ì‹í•©ë‹ˆë‹¤.`);
        const nextUtter = new SpeechSynthesisUtterance("ì´ í˜ì´ì§€ ì¸ì‹ ì™„ë£Œ. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”. 5ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¥¼ ì¸ì‹í•©ë‹ˆë‹¤.");
        nextUtter.lang = "ko-KR";
        nextUtter.rate = 1.0;
        window.speechSynthesis.speak(nextUtter);
        currentPage += 1;
        await sleep(5000);
      }
    }

    autoRunning = false;
  }

  function buildShareText() {
    const core = (ocrBox.value || allText || "").trim();
    if (!core) return "";
    return "[ì—°ì„¸ëŒ€ ì‚¬íšŒ í¸ì… ë…¼ìˆ  OCR TEXT]\n\n[OCR TEXT START]\n" +
      core +
      "\n[OCR TEXT END]";
  }

  function dataUrlToFile(dataUrl, filename) {
    try {
      const arr = dataUrl.split(",");
      if (arr.length < 2) return null;
      const match = arr[0].match(/data:(.*?);base64/);
      const mime = match ? match[1] : "image/jpeg";
      const bstr = atob(arr[1]);
      const len = bstr.length;
      const u8 = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
        u8[i] = bstr.charCodeAt(i);
      }
      return new File([u8], filename, { type: mime });
    } catch (e) {
      return null;
    }
  }

  async function shareToChatGPT() {
    const text = buildShareText();
    if (!text) {
      setStatus("ë¨¼ì € ìë™ OCRì„ ì‹¤í–‰í•´ í…ìŠ¤íŠ¸ë¥¼ ìŒ“ì•„ì•¼ ê³µìœ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
      return;
    }

    const imgs = chartImages.slice(0, 3);
    const files = [];

    if (imgs.length && typeof File !== "undefined") {
      for (let i = 0; i < imgs.length; i++) {
        const f = dataUrlToFile(imgs[i].dataUrl, `chart-page-${imgs[i].page}-${i+1}.jpg`);
        if (f) files.push(f);
      }
    }

    if (navigator.share) {
      try {
        if (files.length && navigator.canShare && navigator.canShare({ files })) {
          await navigator.share({
            title: "ì—°ì„¸ëŒ€ ì‚¬íšŒ í¸ì… ë…¼ìˆ  OCR TEXT",
            text,
            files
          });
          setStatus("í…ìŠ¤íŠ¸ + ë„í‘œ ìƒ·(ìµœëŒ€ 3ì¥)ì„ ê³µìœ  ì‹œíŠ¸ë¡œ ë³´ëƒˆìŠµë‹ˆë‹¤. ChatGPT ì•±ì„ ì„ íƒí•œ ë’¤ ì „ì†¡í•˜ì„¸ìš”.");
        } else {
          await navigator.share({
            title: "ì—°ì„¸ëŒ€ ì‚¬íšŒ í¸ì… ë…¼ìˆ  OCR TEXT",
            text
          });
          setStatus("í…ìŠ¤íŠ¸ë§Œ ê³µìœ  ì‹œíŠ¸ë¡œ ë³´ëƒˆìŠµë‹ˆë‹¤. ChatGPTì—ì„œ ë¶™ì—¬ë„£ê¸° í•˜ì„¸ìš”.");
        }
      } catch (e) {
        setStatus("ê³µìœ  ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: " + (e.message || String(e)));
      }
      return;
    }

    if (navigator.clipboard && navigator.clipboard.writeText) {
      try {
        await navigator.clipboard.writeText(text);
        setStatus("ê³µìœ  ë¯¸ì§€ì› í™˜ê²½ì…ë‹ˆë‹¤. í…ìŠ¤íŠ¸ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆìŠµë‹ˆë‹¤. ChatGPTì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.");
      } catch (e) {
        setStatus("í…ìŠ¤íŠ¸ ë³µì‚¬ ì‹¤íŒ¨: " + (e.message || String(e)));
      }
    } else {
      setStatus("ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ê³µìœ /ë³µì‚¬ê°€ ì œí•œë©ë‹ˆë‹¤. í…ìŠ¤íŠ¸ ì˜ì—­ì„ ê¸¸ê²Œ ëˆŒëŸ¬ ìˆ˜ë™ ë³µì‚¬í•˜ì„¸ìš”.");
    }
  }

  btnAuto.addEventListener("click", () => {
    autoOCRLoop();
  });

  btnShare.addEventListener("click", () => {
    shareToChatGPT();
  });

  window.addEventListener("error", (e) => {
    showErrorOverlay(e.message || "Unknown JS error", e.error && e.error.stack ? e.error.stack : "");
  });

  window.addEventListener("unhandledrejection", (e) => {
    const msg = e && e.reason ? (e.reason.message || String(e.reason)) : "Unhandled rejection";
    const stack = e && e.reason && e.reason.stack ? e.reason.stack : "";
    showErrorOverlay(msg, stack);
  });

  startCamera();
})();
</script>
</body>
</html>

