<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>자동 OCR(누적) → 자동 풀이</title>

  <!-- Tesseract.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0f14; color:#e8eef6; font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .btn {
      appearance:none; border:1px solid rgba(255,255,255,.15);
      background: rgba(255,255,255,.06);
      color:#fff; padding:12px 14px; border-radius:14px;
      font-weight:800; cursor:pointer;
    }
    .btn.primary { background: rgba(0,180,255,.18); border-color: rgba(0,180,255,.35); }
    .btn.danger { background: rgba(255,90,90,.14); border-color: rgba(255,90,90,.35); }
    .card {
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      border-radius:18px; padding:12px; margin-top:12px;
    }
    .title { font-size:15px; font-weight:900; opacity:.95; margin:0 0 8px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .muted { opacity:.72; font-size:12px; line-height:1.4; }
    .big { font-size:13px; line-height:1.55; white-space:pre-wrap; word-break:break-word; }
    video { width:100%; max-height: 44vh; border-radius:18px; background:#000; }
    textarea {
      width:100%; min-height: 220px; resize: vertical;
      border-radius:18px; border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.25); color:#e8eef6; padding:12px;
      outline:none;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="row">
      <button id="btnCam" class="btn primary">카메라 시작(필수 1회 탭)</button>
      <button id="btnAudio" class="btn">음성 연결/테스트(필수 1회 탭)</button>
      <button id="btnReset" class="btn">OCR 재시작(새로고침)</button>
      <button id="btnForceSolve" class="btn danger">지금까지로 풀이</button>
    </div>

    <div class="card">
      <p class="title">자동 OCR(누적) → 자동 풀이</p>
      <div class="muted mono" id="statusLine">
        OCR 엔진: 대기 | 카메라: 대기 | 음성: 대기
      </div>
      <div class="muted mono" id="progressLine" style="margin-top:6px;">
        누적 길이(공백제외): 0 / 기준 2400 | 평균 신뢰도(대략): 0.0% | 경과: 0초
      </div>
      <div class="muted" style="margin-top:6px;">
        iOS는 카메라/음성이 “첫 탭”이 필요하다. 위 버튼 2개는 반드시 한 번 눌러라.
      </div>
    </div>

    <div class="card">
      <p class="title">카메라</p>
      <video id="video" playsinline autoplay muted></video>
      <div class="muted mono" id="camMsg" style="margin-top:8px;">대기</div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <p class="title" style="margin:0;">실시간 OCR(누적)</p>
        <div class="muted mono" id="ocrMsg"></div>
      </div>
      <textarea id="ocrBox" placeholder="OCR 누적 텍스트가 여기에 쌓임" spellcheck="false"></textarea>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <p class="title" style="margin:0;">답안</p>
        <button id="btnStopTTS" class="btn">음성 중지</button>
      </div>
      <textarea id="ansBox" placeholder="아직 답안 없음" spellcheck="false"></textarea>
    </div>
  </div>

<script>
(() => {
  // ===== 설정(안정성/퀄리티 우선) =====
  const OCR_INTERVAL_MS = 2500;        // OCR 갱신 주기(느려도 OK)
  const SOLVE_THRESHOLD = 2400;        // 공백 제외 글자 수 기준
  const MIN_CONF = 55;                // 너무 낮은 OCR은 버림(대략)
  const STABLE_REQUIRED = 2;           // 연속 2번 “충분” 상태면 solve
  const MAX_SOLVE_PER_SESSION = 1;     // 자동 solve는 1번만

  // ===== DOM =====
  const $ = (id) => document.getElementById(id);
  const statusLine = $("statusLine");
  const progressLine = $("progressLine");
  const camMsg = $("camMsg");
  const ocrMsg = $("ocrMsg");
  const ocrBox = $("ocrBox");
  const ansBox = $("ansBox");
  const video = $("video");

  // ===== 상태 =====
  let camReady = false;
  let ttsReady = false;
  let workerReady = false;

  let worker = null;
  let ocrTimer = null;
  let startedAt = Date.now();

  let bestText = "";
  let bestConf = 0;
  let stableCount = 0;
  let autoSolvedCount = 0;
  let ocrBusy = false;

  function nowSec() { return Math.floor((Date.now() - startedAt) / 1000); }
  function stripSpaces(s) { return (s || "").replace(/\s+/g, ""); }
  function pct(n) { return (Math.max(0, Math.min(100, n)) || 0).toFixed(1); }

  function setStatus(engine, cam, tts) {
    statusLine.textContent = `OCR 엔진: ${engine} | 카메라: ${cam} | 음성: ${tts}`;
  }

  function updateProgress() {
    const len = stripSpaces(bestText).length;
    progressLine.textContent =
      `누적 길이(공백제외): ${len} / 기준 ${SOLVE_THRESHOLD} | 평균 신뢰도(대략): ${pct(bestConf)}% | 경과: ${nowSec()}초`;
  }

  function speak(text) {
    if (!ttsReady) return;
    if (!text) return;
    try {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "ko-KR";
      u.rate = 1.0;
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  // ===== 카메라 =====
  async function startCamera() {
    try {
      camMsg.textContent = "카메라 연결 중...";
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        },
        audio: false
      });
      video.srcObject = stream;
      camReady = true;
      camMsg.textContent = "카메라 연결 완료";
      setStatus(workerReady ? "준비됨" : (workerReady===false ? "대기" : "대기"), "연결됨", ttsReady ? "준비됨" : "대기");
    } catch (e) {
      camReady = false;
      camMsg.textContent = "카메라 실패: 설정에서 이 사이트 카메라 허용했는지 확인";
      setStatus(workerReady ? "준비됨" : "대기", "실패", ttsReady ? "준비됨" : "대기");
    }
  }

  // ===== OCR 엔진 =====
  async function initWorker() {
    // 이미 준비되면 끝
    if (workerReady && worker) return;

    setStatus("로딩중… (tesseract core 다운로드)", camReady ? "연결됨" : "대기", ttsReady ? "준비됨" : "대기");
    ocrMsg.textContent = "OCR 엔진 준비 중...";

    // “꼼꼼하게”: 3번까지 재시도
    const MAX_TRY = 3;
    let lastErr = null;

    for (let attempt = 1; attempt <= MAX_TRY; attempt++) {
      try {
        // 혹시 남아있는 워커 정리
        if (worker) {
          try { await worker.terminate(); } catch (e) {}
          worker = null;
        }

        worker = await Tesseract.createWorker({
          logger: (m) => {
            // m.status / m.progress
            if (m && m.status) {
              const p = (typeof m.progress === "number") ? `${Math.round(m.progress * 100)}%` : "";
              ocrMsg.textContent = `엔진 로딩: ${m.status} ${p}`;
              setStatus(`로딩중… (${m.status} ${p})`, camReady ? "연결됨" : "대기", ttsReady ? "준비됨" : "대기");
            }
          },
          // 엔진 파일은 CDN에서 가져오게 고정
          workerPath: "https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js",
          corePath: "https://cdn.jsdelivr.net/npm/tesseract.js-core@5/tesseract-core.wasm.js",
          // 한국어 학습데이터
          langPath: "https://tessdata.projectnaptha.com/4.0.0"
        });

        await worker.loadLanguage("kor");
        await worker.initialize("kor");

        workerReady = true;
        ocrMsg.textContent = "OCR 엔진 준비 완료";
        setStatus("준비됨", camReady ? "연결됨" : "대기", ttsReady ? "준비됨" : "대기");
        return;

      } catch (e) {
        lastErr = e;
        workerReady = false;
        ocrMsg.textContent = `엔진 실패(재시도 ${attempt}/${MAX_TRY})...`;
      }
    }

    // 최종 실패
    setStatus("실패", camReady ? "연결됨" : "대기", ttsReady ? "준비됨" : "대기");
    ocrMsg.textContent = "OCR 엔진 로딩 실패";
    const msg = (lastErr && (lastErr.message || String(lastErr))) ? (lastErr.message || String(lastErr)) : "알 수 없는 오류";
    camMsg.textContent = `OCR 엔진 로딩 실패: ${msg}`;
  }

  function mergeText(oldT, newT) {
    // 안정성 우선: “더 길고 더 신뢰도 높게 나온 텍스트”를 우선
    // 겹치는 경우는 그냥 긴 쪽을 채택(단순하지만 안정적)
    const o = oldT || "";
    const n = newT || "";
    if (stripSpaces(n).length >= stripSpaces(o).length) return n;
    return o;
  }

  // ===== OCR 루프 =====
  async function tickOCR() {
    if (!camReady || !workerReady || !worker) return;
    if (ocrBusy) return;

    ocrBusy = true;
    try {
      // 비디오 프레임 캡처
      const w = 1280;
      const h = Math.round((video.videoHeight / video.videoWidth) * w) || 720;
      const canvas = document.createElement("canvas");
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext("2d", { willReadFrequently: true });
      ctx.drawImage(video, 0, 0, w, h);

      const res = await worker.recognize(canvas);
      const text = (res && res.data && res.data.text) ? res.data.text.trim() : "";
      const conf = (res && res.data && typeof res.data.confidence === "number") ? res.data.confidence : 0;

      if (text && conf >= MIN_CONF) {
        bestText = mergeText(bestText, text);
        bestConf = Math.max(bestConf, conf);
        ocrBox.value = bestText;
      }

      // 자동 solve 판정(퀄리티 우선)
      const len = stripSpaces(bestText).length;
      if (len >= SOLVE_THRESHOLD && bestConf >= MIN_CONF) {
        stableCount++;
      } else {
        stableCount = 0;
      }

      updateProgress();

      if (stableCount >= STABLE_REQUIRED && autoSolvedCount < MAX_SOLVE_PER_SESSION) {
        autoSolvedCount++;
        stableCount = 0;
        await callSolve(bestText);
      }

    } catch (e) {
      // OCR 중 오류가 나도 “계속” 돌게 한다
      ocrMsg.textContent = `OCR 중 오류(무시하고 계속): ${e && e.message ? e.message : e}`;
    } finally {
      ocrBusy = false;
    }
  }

  function startOCRLoop() {
    stopOCRLoop();
    ocrTimer = setInterval(tickOCR, OCR_INTERVAL_MS);
  }

  function stopOCRLoop() {
    if (ocrTimer) clearInterval(ocrTimer);
    ocrTimer = null;
  }

  // ===== solve 호출 =====
  async function callSolve(text) {
    const payload = { text: text || "" };

    ansBox.value = "풀이 생성 중...";
    try {
      const r = await fetch("/.netlify/functions/solve", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      const out = await r.text();
      ansBox.value = out || "(빈 응답)";
      // 자동 음성
      speak(out);

    } catch (e) {
      ansBox.value = `solve 실패: ${e && e.message ? e.message : e}`;
    }
  }

  // ===== 버튼 이벤트 =====
  $("btnCam").addEventListener("click", async () => {
    await startCamera();
    // 카메라 시작하면 OCR 엔진도 같이 준비(사용자 입장에서 단순)
    await initWorker();
    if (camReady && workerReady) {
      startOCRLoop();
    }
  });

  $("btnAudio").addEventListener("click", () => {
    try {
      // iOS “첫 탭” 언락용
      const u = new SpeechSynthesisUtterance("음성 준비 완료");
      u.lang = "ko-KR";
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
      ttsReady = true;
      setStatus(workerReady ? "준비됨" : "대기", camReady ? "연결됨" : "대기", "준비됨");
    } catch (e) {
      ttsReady = false;
      setStatus(workerReady ? "준비됨" : "대기", camReady ? "연결됨" : "대기", "실패");
    }
  });

  $("btnStopTTS").addEventListener("click", () => {
    try { window.speechSynthesis.cancel(); } catch (e) {}
  });

  $("btnReset").addEventListener("click", async () => {
    bestText = "";
    bestConf = 0;
    stableCount = 0;
    autoSolvedCount = 0;
    startedAt = Date.now();
    ocrBox.value = "";
    ansBox.value = "";
    updateProgress();
    ocrMsg.textContent = "";

    // 워커 재시작(꼼꼼)
    workerReady = false;
    await initWorker();
    if (camReady && workerReady) startOCRLoop();
  });

  $("btnForceSolve").addEventListener("click", async () => {
    const t = (ocrBox.value || "").trim();
    if (!t) {
      ansBox.value = "OCR 텍스트가 비어있음";
      return;
    }
    await callSolve(t);
  });

  // 첫 화면
  setStatus("대기", "대기", "대기");
  updateProgress();
})();
</script>

</body>
</html>

