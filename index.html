<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Answer Site</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { max-width: 820px; margin: 32px auto; padding: 0 16px; }
    textarea { width: 100%; min-height: 120px; padding: 12px; font-size: 16px; }
    button { padding: 10px 16px; font-size: 16px; cursor: pointer; }
    .row { display: flex; gap: 10px; align-items: center; margin: 12px 0; flex-wrap: wrap; }
    .out { white-space: pre-wrap; background: #f6f7f8; padding: 12px; border-radius: 8px; min-height: 48px; }
    .muted { color: #666; font-size: 14px; }
    .error { color: #b00020; }
    .cam-wrap { position: relative; display: inline-block; max-width: 100%; }
    #preview { max-width: 100%; border-radius: 8px; display: none; }
    #roiCanvas { position: absolute; inset: 0; display: none; touch-action: none; }
    .hint { font-size: 13px; color:#555; }
    .panel label { display:block; font-size:13px; margin-bottom:4px; }
    .panel input[type=range]{ width:220px; }
  </style>
</head>
<body>
  <h1>정답 풀이 테스트</h1>
  <p class="muted">질문을 적고 <b>보내기</b>를 누르면 <code>/.netlify/functions/solve</code>로 POST합니다.</p>

  <textarea id="q" placeholder="여기에 질문/문제 텍스트를 입력하거나 OCR로 채워보세요."></textarea>
  <div class="row">
    <button id="send">보내기</button>
    <span id="status" class="muted"></span>
  </div>

  <h3>결과</h3>
  <div id="out" class="out"></div>

  <hr>
  <h3>카메라 · OCR · 음성</h3>

  <div class="row">
    <button id="camStart">카메라 켜기</button>
    <button id="camShot" disabled>캡처 → OCR</button>
    <button id="camStop" disabled>카메라 끄기</button>
    <button id="speak" disabled>정답만 읽어주기(TTS)</button>
    <span id="ocrStatus" class="muted"></span>
  </div>

  <div class="row" style="align-items:center">
    <label style="display:flex; gap:8px; align-items:center">
      <input type="checkbox" id="autoMode">
      <span>자동 모드(안정 시 자동 풀이)</span>
    </label>
    <span id="autoStatus" class="muted"></span>
    <span id="autoDebug" class="muted"></span>
  </div>

  <div id="autoPanel" class="row panel" style="gap:18px; align-items:flex-end">
    <div>
      <label>민감도(변화 허용 비율)
        <input id="inpThreshold" type="range" min="0.03" max="0.40" step="0.01" value="0.30">
      </label>
      <div class="muted">현재: <span id="lblThreshold">0.30</span></div>
    </div>
    <div>
      <label>체크 주기(ms)
        <input id="inpInterval" type="range" min="200" max="1500" step="50" value="900">
      </label>
      <div class="muted">현재: <span id="lblInterval">900</span> ms</div>
    </div>
    <div>
      <label>안정 시간(s)
        <input id="inpStable" type="range" min="1" max="8" step="1" value="2">
      </label>
      <div class="muted">현재: <span id="lblStable">2</span> s</div>
    </div>
    <div>
      <label>쿨다운(s)
        <input id="inpCooldown" type="range" min="5" max="30" step="1" value="6">
      </label>
      <div class="muted">현재: <span id="lblCooldown">6</span> s</div>
    </div>
  </div>

  <div class="hint">TIP: 비디오 위를 <b>드래그</b>하면 파란 박스로 <b>영역 지정(ROI)</b>이 됩니다. ROI가 없을 땐 화면 가장자리 10%를 자동 무시해 배경/손 영향이 줄어듭니다.</div>

  <div class="cam-wrap">
    <video id="preview" autoplay playsinline></video>
    <canvas id="roiCanvas"></canvas>
  </div>
  <canvas id="frame" style="display:none"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    /* ===================== 공통: 질문 → 함수 호출 ===================== */
    const $q = document.getElementById('q');
    const $btn = document.getElementById('send');
    const $out = document.getElementById('out');
    const $status = document.getElementById('status');

    async function ask() {
      const question = ($q.value || '').trim();
      if (!question) { $out.textContent = ''; $status.textContent = '질문을 입력하세요.'; return; }
      $status.textContent = '요청 중...'; $btn.disabled = true; $out.textContent = '';
      try {
        const res = await fetch('/.netlify/functions/solve', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ question })
        });
        const ct = res.headers.get('content-type') || '';
        let answerText = '';
        if (ct.includes('application/json')) {
          const data = await res.json(); answerText = data.answer ?? JSON.stringify(data, null, 2);
        } else {
          const text = await res.text();
          try { const maybe = JSON.parse(text); answerText = maybe.answer ?? text; }
          catch { answerText = text; }
        }
        $out.textContent = answerText;
        $status.textContent = res.ok ? '완료' : `에러: ${res.status}`;
      } catch (err) {
        console.error(err);
        $status.innerHTML = `<span class="error">요청 실패: ${String(err)}</span>`;
      } finally {
        $btn.disabled = false;
      }
    }
    $btn.addEventListener('click', ask);
    $q.addEventListener('keydown', (e) => { if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) ask(); });

    /* ===================== 카메라 / ROI / OCR / TTS ===================== */
    const $video = document.getElementById('preview');
    const $canvas = document.getElementById('frame');
    const $roiCanvas = document.getElementById('roiCanvas');
    const $camStart = document.getElementById('camStart');
    const $camShot  = document.getElementById('camShot');
    const $camStop  = document.getElementById('camStop');
    const $speak    = document.getElementById('speak');
    const $ocrStatus = document.getElementById('ocrStatus');
    let stream;

    function resizeOverlay() {
      const rect = $video.getBoundingClientRect();
      $roiCanvas.width = rect.width;
      $roiCanvas.height = rect.height;
      $roiCanvas.style.width = rect.width + 'px';
      $roiCanvas.style.height = rect.height + 'px';
      $roiCanvas.style.left = $video.offsetLeft + 'px';
      $roiCanvas.style.top  = $video.offsetTop  + 'px';
      drawROI();
    }
    window.addEventListener('resize', () => { if ($video.style.display !== 'none') resizeOverlay(); });

    // 장치 탐색(폴백용)
    async function pickAnyVideoDeviceId() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const cams = devices.filter(d => d.kind === 'videoinput');
        return cams.length ? cams[0].deviceId : null;
      } catch { return null; }
    }

    // 카메라 켜기: 고해상도 + 폴백 + play() 보장
    async function startCamera() {
      try {
        $ocrStatus.textContent = '카메라 권한 요청 중...';
        // 선명도 우선 제약
        let constraints = {
          video: {
            facingMode: { ideal: 'environment' },
            width:  { ideal: 1920 },
            height: { ideal: 1080 },
            frameRate: { ideal: 24, max: 30 }
          },
          audio: false
        };
        let localStream;
        try {
          localStream = await navigator.mediaDevices.getUserMedia(constraints);
        } catch (e1) {
          const devId = await pickAnyVideoDeviceId();
          if (e1.name === 'NotReadableError' || e1.name === 'NotAllowedError') throw e1;
          if (devId) {
            try {
              localStream = await navigator.mediaDevices.getUserMedia({ video: { deviceId: { exact: devId } }, audio: false });
            } catch {
              localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
            }
          } else {
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
          }
        }

        stream = localStream;
        $video.srcObject = stream;
        $video.style.display = 'block';
        $roiCanvas.style.display = 'block';

        await new Promise(resolve => {
          const onReady = async () => { try { await $video.play(); } catch {} resizeOverlay(); resolve(); };
          if ($video.readyState >= 1) onReady(); else $video.addEventListener('loadedmetadata', onReady, { once: true });
        });

        $camShot.disabled = false;
        $camStop.disabled = false;
        $ocrStatus.textContent = '카메라 ON';
        if ($auto.checked) startAuto();
      } catch (e) {
        console.error(e);
        let msg = e?.name || 'UnknownError';
        if (msg === 'NotAllowedError') msg = '권한 거부됨: 주소창 🔒/OS 개인정보 보호에서 카메라 허용을 확인하세요.';
        else if (msg === 'NotFoundError') msg = '카메라 장치를 찾을 수 없습니다.';
        else if (msg === 'NotReadableError') msg = '다른 앱이 카메라 사용 중입니다. 종료 후 다시 시도하세요.';
        else if (msg === 'OverconstrainedError') msg = '요청한 카메라 조건을 만족하지 못합니다.';
        else msg = '카메라 접근 실패: ' + (e.message || e);
        $ocrStatus.textContent = msg;
      }
    }
    function stopCamera() {
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      $video.pause();
      $video.srcObject = null;
      $video.style.display = 'none';
      $roiCanvas.style.display = 'none';
      $camShot.disabled = true;
      $camStop.disabled = true;
      $ocrStatus.textContent = '카메라 OFF';
      stopAuto();
    }

    // ROI 드래그
    let dragging = false, roi = null;
    function drawROI() {
      const ctx = $roiCanvas.getContext('2d'); ctx.clearRect(0,0,$roiCanvas.width,$roiCanvas.height);
      if (!roi) return;
      ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(0,0,$roiCanvas.width,$roiCanvas.height);
      ctx.clearRect(roi.x, roi.y, roi.w, roi.h);
      ctx.strokeStyle='#3b82f6'; ctx.lineWidth=2; ctx.strokeRect(roi.x, roi.y, roi.w, roi.h);
    }
    function pointerPos(e){ const r=$roiCanvas.getBoundingClientRect();
      const x=e.touches?e.touches[0].clientX:e.clientX, y=e.touches?e.touches[0].clientY:e.clientY;
      return {x:Math.max(0,Math.min(r.width,x-r.left)), y:Math.max(0,Math.min(r.height,y-r.top))}; }
    function startDrag(e){ dragging=true; const p=pointerPos(e); roi={x:p.x,y:p.y,w:0,h:0}; drawROI(); }
    function moveDrag(e){ if(!dragging) return; const p=pointerPos(e);
      roi.w=p.x-roi.x; roi.h=p.y-roi.y;
      const nx=Math.min(roi.x,roi.x+roi.w), ny=Math.min(roi.y,roi.y+roi.h);
      const nw=Math.abs(roi.w), nh=Math.abs(roi.h); roi={x:nx,y:ny,w:nw,h:nh}; drawROI();
    }
    function endDrag(){ dragging=false; }
    $roiCanvas.addEventListener('mousedown', startDrag);
    $roiCanvas.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);
    $roiCanvas.addEventListener('touchstart', e=>{e.preventDefault();startDrag(e);},{passive:false});
    $roiCanvas.addEventListener('touchmove',  e=>{e.preventDefault();moveDrag(e); },{passive:false});
    $roiCanvas.addEventListener('touchend',   e=>{e.preventDefault();endDrag();   },{passive:false});

    /* ---------- OCR 정확도 향상 헬퍼 ---------- */
    function laplacianVariance(gray, w, h) {
      const k = [-1,-1,-1,-1,8,-1,-1,-1,-1];
      let sum=0, sum2=0, n=0;
      const idx=(x,y)=>y*w+x;
      for (let y=1; y<h-1; y++) for (let x=1; x<w-1; x++) {
        let v=0,p=0; for (let ky=-1; ky<=1; ky++) for (let kx=-1; kx<=1; kx++) v += gray[idx(x+kx,y+ky)] * k[p++];
        v=Math.abs(v); sum+=v; sum2+=v*v; n++;
      }
      const mean=sum/n; return sum2/n - mean*mean;
    }
    function preprocessCanvas(srcCanvas) {
      const up=document.createElement('canvas');
      up.width=Math.min(srcCanvas.width*2,2200);
      up.height=Math.min(srcCanvas.height*2,2200);
      const ctx=up.getContext('2d',{willReadFrequently:true});
      ctx.imageSmoothingEnabled=true;
      ctx.drawImage(srcCanvas,0,0,up.width,up.height);

      const {width:w,height:h}=up;
      const img=ctx.getImageData(0,0,w,h); const d=img.data;
      const gray=new Uint8ClampedArray(w*h);
      for(let i=0,j=0;i<d.length;i+=4,j++) gray[j]=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];

      const tile=32,C=8;
      for(let ty=0;ty<h;ty+=tile){
        for(let tx=0;tx<w;tx+=tile){
          let sum=0,cnt=0;
          for(let y=ty;y<Math.min(ty+tile,h);y++)
            for(let x=tx;x<Math.min(tx+tile,w);x++){ sum+=gray[y*w+x]; cnt++; }
          const thr=sum/cnt - C;
          for(let y=ty;y<Math.min(ty+tile,h);y++)
            for(let x=tx;x<Math.min(tx+tile,w);x++){
              const i=y*w+x; gray[i]=gray[i]>thr?255:0;
            }
        }
      }
      for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
        const i=y*w+x;
        const v = gray[i]*1.5 - (gray[i-1]+gray[i+1]+gray[i-w]+gray[i+w])/4*0.5;
        gray[i]=Math.max(0,Math.min(255,v));
      }
      for(let i=0,j=0;j<gray.length;i+=4,j++){ const g=gray[j]; d[i]=d[i+1]=d[i+2]=g; d[i+3]=255; }
      ctx.putImageData(img,0,0);
      return up;
    }
    async function captureSharpestFrame(video,N=3,gapMs=220){
      const vw=video.videoWidth||1280,vh=video.videoHeight||720;
      const tmp=document.createElement('canvas'); tmp.width=vw; tmp.height=vh;
      const tctx=tmp.getContext('2d',{willReadFrequently:true});
      let best=null,bestScore=-1;
      for(let k=0;k<N;k++){
        tctx.drawImage(video,0,0,vw,vh);
        const im=tctx.getImageData(0,0,vw,vh); const gray=new Uint8ClampedArray(vw*vh);
        for(let i=0,j=0;i<im.data.length;i+=4,j++) gray[j]=0.299*im.data[i]+0.587*im.data[i+1]+0.114*im.data[i+2];
        const score=laplacianVariance(gray,vw,vh);
        if(score>bestScore){ bestScore=score; best=tmp.cloneNode(true); best.getContext('2d').drawImage(tmp,0,0); }
        await new Promise(r=>setTimeout(r,gapMs));
      }
      return best;
    }

    // OCR 본체(선명 프레임+전처리+옵션)
    async function captureAndOCR() {
      if (!$video.srcObject) return;
      $ocrStatus.textContent = '캡처 중...';

      const best = await captureSharpestFrame($video, 3, 220);

      const vw=best.width, vh=best.height;
      let sourceCanvas=best;
      if (roi && roi.w>8 && roi.h>8) {
        const vis=$video.getBoundingClientRect();
        const sx=Math.round(roi.x*(vw/vis.width)), sy=Math.round(roi.y*(vh/vis.height));
        const sw=Math.round(roi.w*(vw/vis.width)), sh=Math.round(roi.h*(vh/vis.height));
        const crop=document.createElement('canvas'); crop.width=sw; crop.height=sh;
        crop.getContext('2d').drawImage(best,sx,sy,sw,sh,0,0,sw,sh);
        sourceCanvas=crop;
      }

      const pre = preprocessCanvas(sourceCanvas);

      $ocrStatus.textContent='OCR 인식 중...';
      try {
        const { data } = await Tesseract.recognize(pre, 'kor+eng', {
          langPath: 'https://tessdata.projectnaptha.com/4.0.0',
          tessedit_pageseg_mode: 6,
          preserve_interword_spaces: 1,
          user_defined_dpi: 300
          // 필요 시 화이트리스트/블랙리스트 추가 가능
          // tessedit_char_whitelist: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz .,:;()[]-–—?\'"/%+'
        });
        let text = (data?.text || '').trim();
        text = text
          .replace(/\u00A0/g, ' ')
          .replace(/[“”]/g, '"').replace(/[‘’]/g, "'")
          .replace(/—|–/g, '-')
          .replace(/[lI]\s?\/\s?O/g, '10');
        if (text){ $q.value = text; $ocrStatus.textContent = 'OCR 완료 ✅'; }
        else { $ocrStatus.textContent = '문자 인식 실패'; }
      } catch(e){ console.error(e); $ocrStatus.textContent = 'OCR 오류: ' + e.message; }
    }

    function extractAnswerOnly(fullText){
      if (!fullText) return '';
      const m1 = fullText.match(/(?:정답|answer)\s*[:：]\s*([^\n]+)/i);
      if (m1) return m1[1].trim();
      const line = fullText.split(/\r?\n/).find(l=>/정답|answer/i.test(l));
      if (line) return line.replace(/.*?(정답|answer)\s*[:：]?\s*/i,'').trim();
      return fullText.split(/\r?\n/)[0].trim();
    }
    function speakResult(){
      const full=$out.textContent.trim(); if(!full){ $ocrStatus.textContent='읽을 결과가 없습니다.'; return; }
      const key=extractAnswerOnly(full); const u=new SpeechSynthesisUtterance(key||full);
      u.lang='ko-KR'; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
    }
    $camStart.addEventListener('click', startCamera);
    $camStop .addEventListener('click', stopCamera);
    $camShot .addEventListener('click', captureAndOCR);
    $speak  .addEventListener('click', speakResult);

    const outObserver=new MutationObserver(()=>{ $speak.disabled=!($out.textContent||'').trim().length; });
    outObserver.observe($out,{childList:true,subtree:true,characterData:true});

    /* ===================== 자동 모드(느슨+스무딩) ===================== */
    const $auto = document.getElementById('autoMode');
    const $autoStatus = document.getElementById('autoStatus');
    const $autoDebug = document.getElementById('autoDebug');

    let DIFF_THRESHOLD = 0.30, CHECK_INTERVAL = 900, STABLE_MS = 2000, COOLDOWN_MS = 6000;

    const diffCanvas = document.createElement('canvas');
    const diffCtx = diffCanvas.getContext('2d');

    const $inpThreshold=document.getElementById('inpThreshold');
    const $inpInterval =document.getElementById('inpInterval');
    const $inpStable   =document.getElementById('inpStable');
    const $inpCooldown =document.getElementById('inpCooldown');
    const $lblThreshold=document.getElementById('lblThreshold');
    const $lblInterval =document.getElementById('lblInterval');
    const $lblStable   =document.getElementById('lblStable');
    const $lblCooldown =document.getElementById('lblCooldown');

    function applyPanelValues(){
      DIFF_THRESHOLD=parseFloat($inpThreshold.value);
      CHECK_INTERVAL=parseInt($inpInterval.value,10);
      STABLE_MS     =parseInt($inpStable.value,10)*1000;
      COOLDOWN_MS   =parseInt($inpCooldown.value,10)*1000;
      $lblThreshold.textContent=DIFF_THRESHOLD.toFixed(2);
      $lblInterval.textContent =CHECK_INTERVAL;
      $lblStable.textContent   =(STABLE_MS/1000).toFixed(0);
      $lblCooldown.textContent =(COOLDOWN_MS/1000).toFixed(0);
      if ($auto.checked) { stopAuto(); startAuto(); }
    }
    [$inpThreshold,$inpInterval,$inpStable,$inpCooldown].forEach(el=>el.addEventListener('input',applyPanelValues));
    applyPanelValues();

    let autoLoopId=null, lastImageData=null, stableSince=0, cooldownUntil=0;
    let ratioEMA = 1;
    const SMOOTH_ALPHA = 0.25;
    const EDGE_IGNORE  = 0.10;

    function frameDiffRatio() {
      if (!$video.srcObject || !$video.videoWidth) return 1;
      const w=480, h=Math.round(w*($video.videoHeight/$video.videoWidth));
      diffCanvas.width=w; diffCanvas.height=h;
      diffCtx.drawImage($video,0,0,w,h);
      const cur=diffCtx.getImageData(0,0,w,h).data;

      let x0=0,y0=0,x1=w,y1=h;
      if (!roi || roi.w<8 || roi.h<8) {
        const m=Math.floor(EDGE_IGNORE*w), n=Math.floor(EDGE_IGNORE*h);
        x0=m; y0=n; x1=w-m; y1=h-n;
      }

      let diff=0,total=0;
      if (!lastImageData){ lastImageData=cur; return 1; }
      for(let y=y0;y<y1;y++) for(let x=x0;x<x1;x++){
        const i=(y*w+x)*4;
        const Yr=0.299*cur[i]+0.587*cur[i+1]+0.114*cur[i+2];
        const Yo=0.299*lastImageData[i]+0.587*lastImageData[i+1]+0.114*lastImageData[i+2];
        const d=Math.abs(Yr-Yo);
        if (d>80) diff++; total++;
      }
      lastImageData=cur;
      const ratio= total? diff/total : 1;
      ratioEMA = SMOOTH_ALPHA*ratio + (1-SMOOTH_ALPHA)*ratioEMA;
      return ratioEMA;
    }

    async function captureOCRAndAsk(){
      await captureAndOCR();
      const q=($q.value||'').trim();
      if (q.length>0){ await ask(); speakResult(); }
    }

    function startAuto(){
      if (!$video.srcObject){ $ocrStatus.textContent='먼저 카메라를 켜주세요.'; $auto.checked=false; return; }
      stableSince=0; lastImageData=null; ratioEMA=1; $autoStatus.textContent='자동 모드 ON';
      if (autoLoopId) clearInterval(autoLoopId);
      autoLoopId=setInterval(async ()=>{
        const now=Date.now();
        const ratio=frameDiffRatio();
        const remainSec = Math.max(0, STABLE_MS-(stableSince?(now-stableSince):0))/1000;
        $autoDebug.textContent = `(EMA) 변화율: ${ratio.toFixed(3)} / 임계: ${DIFF_THRESHOLD.toFixed(2)} · 남은 안정: ${remainSec.toFixed(1)}s`;

        if (now<cooldownUntil){ $ocrStatus.textContent=`자동 대기 중… ${Math.ceil((cooldownUntil-now)/1000)}s`; return; }

        if (ratio < DIFF_THRESHOLD){
          if (!stableSince) stableSince = now;
          const remain = Math.max(0, STABLE_MS - (now - stableSince));
          $ocrStatus.textContent = `안정 감지 중… ${Math.ceil(remain/1000)}s`;
          if (now - stableSince >= STABLE_MS){
            $ocrStatus.textContent='자동 캡처 → OCR 실행!';
            cooldownUntil = now + COOLDOWN_MS;
            stableSince = 0;
            try { await captureOCRAndAsk(); } catch(e){ console.error(e); }
          }
        } else {
          stableSince = 0;
          $ocrStatus.textContent='움직임 감지됨(대기)…';
        }
      }, CHECK_INTERVAL);
    }
    function stopAuto(){ if (autoLoopId) clearInterval(autoLoopId); autoLoopId=null; $autoStatus.textContent='자동 모드 OFF'; }
    const $auto = document.getElementById('autoMode');
    $auto.addEventListener('change', ()=>{ if($auto.checked) startAuto(); else stopAuto(); });

    // TTS 버튼 활성화 연동
    const outObserver=new MutationObserver(()=>{ $speak.disabled=!($out.textContent||'').trim().length; });
    outObserver.observe($out,{childList:true,subtree:true,characterData:true});
  </script>
</body>
</html>
