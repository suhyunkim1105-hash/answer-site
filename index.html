<script>
(function () {
  // =========================
  // 0) ì„¤ì •ê°’
  // =========================
  const OCR_INTERVAL_MS = 3000;

  // ìµœì†Œ í’€ì´ ê°€ëŠ¥ ê¸¸ì´ (ë„ˆë¬´ ì§§ìœ¼ë©´ ì ˆëŒ€ ì•ˆ í’€ê¸°)
  const MIN_SOLVE_LEN_EFFECTIVE = 900;

  // ê¶Œì¥ ê¸°ì¤€: ìœ íš¨ ê¸€ììˆ˜ 2000 ê·¼ì²˜
  const TEXT_THRESHOLD_EFFECTIVE = 2000;

  // ì§€ë¬¸ ë¶€ì¡± ì•ˆë‚´: ì—°ì† 5ë¶„
  const INSUFFICIENT_WARN_MS = 5 * 60 * 1000;

  // ìµœëŒ€ ê¸°ë‹¤ë¦¼: ì—°ì† 8ë¶„ì´ë©´ ë¶€ì¡±í•´ë„ í’€ì´
  const MAX_WAIT_MS = 8 * 60 * 1000;

  // solve í•¨ìˆ˜ URL (netlify/functions/solve)
  const SOLVE_URL = "/.netlify/functions/solve";

  // OCR ì–¸ì–´ â€” í•œê¸€ë§Œ
  const OCR_LANG = "kor";

  // TTS ì„¤ì •
  const TTS_ENABLED = true;
  const TTS_RATE = 1.03;
  const TTS_PITCH = 1.0;
  const TTS_STATUS_COOLDOWN_MS = 15000;

  // =========================
  // 1) DOM
  // =========================
  const video = document.getElementById("video");
  const statusEl = document.getElementById("status");
  const ocrPreviewEl = document.getElementById("ocrPreview");
  const answerBoxEl = document.getElementById("answerBox");
  const zoomRangeEl = document.getElementById("zoomRange");
  const zoomLabelEl = document.getElementById("zoomLabel");

  // =========================
  // 2) ìƒíƒœ
  // =========================
  let stream = null;
  let ocrRunning = false;
  let lastOcrAt = 0;

  // ëˆ„ì  OCR ì„¸ê·¸ë¨¼íŠ¸
  let segments = []; // { text, effLen, conf }
  let accText = "";
  let accEffectiveLen = 0;
  let accBestConf = 0;

  // ì¹´ë©”ë¼/ê±°ë¦¬ ìƒíƒœ
  let blocked = false;
  let tooNear = false;
  let tooFar = false;

  // â€œì•„ì§ ì™„ì„± ì•„ë‹˜â€ì´ ì–¼ë§ˆë‚˜ ì´ì–´ì¡ŒëŠ”ì§€
  let notReadySince = null;

  // solve ìƒíƒœ
  let solved = false;
  let solving = false;

  // TTS ìƒíƒœ
  let lastStatusSpokenAt = 0;
  let audioUnlocked = false;
  let voicesReady = false;

  // ì›€ì§ì„/ë°ê¸° ë¶„ì„ìš© ìº”ë²„ìŠ¤
  const BW = 64;
  const BH = 36;
  const bCanvas = document.createElement("canvas");
  bCanvas.width = BW;
  bCanvas.height = BH;
  const bCtx = bCanvas.getContext("2d", { willReadFrequently: true });
  let prevThumb = null;
  let lastStableStart = 0;

  // OCR ìº¡ì²˜ìš© ìº”ë²„ìŠ¤ (ì „ì²´ í”„ë ˆì„ ê¸°ì¤€, í¬ë¡­/ë°°ìœ¨ ì—†ìŒ = í•­ìƒ ìµœëŒ€ ì¤Œì•„ì›ƒ)
  const capCanvas = document.createElement("canvas");
  const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

  // =========================
  // 3) ê³µí†µ ìœ í‹¸
  // =========================
  function now() {
    return Date.now();
  }

  function effectiveLenOf(text) {
    return (text || "").replace(/\s/g, "").length;
  }

  function setStatus(lines) {
    statusEl.textContent = lines.join("\n");
  }

  function normalizeOcrText(text) {
    let t = String(text || "");
    // ì¤„ ë í•˜ì´í”ˆ ë¶™ì´ê¸°
    t = t.replace(/-\s*\n\s*/g, "");
    // ê³µë°± ì •ë¦¬
    t = t.replace(/[ \t]+\n/g, "\n");
    t = t.replace(/\n[ \t]+/g, "\n");
    t = t.replace(/[ \t]{2,}/g, " ");
    // ì œì–´ë¬¸ì ì œê±°
    t = t.replace(/[\u0000-\u001F\u007F]/g, "");
    // ë¸”ë¡ ê¸°í˜¸ ì—¬ëŸ¬ ê°œ â†’ ê³µë°± í•˜ë‚˜
    t = t.replace(/[â– â–¡â–¢â—â—†â—‡]{2,}/g, " ");
    // ğŸ”´ ì˜ì–´ ì•ŒíŒŒë²³ ì „ë¶€ ì œê±° (ëŒ€/ì†Œë¬¸ì)
    t = t.replace(/[A-Za-z]/g, "");
    // ê´„í˜¸/ê¸°í˜¸/ë™ê·¸ë¼ë¯¸ ìˆ«ì ë“±ì€ ê·¸ëŒ€ë¡œ ë‘”ë‹¤
    return t.trim();
  }

  // =========================
  // 4) TTS ê´€ë ¨
  // =========================
  function initVoices() {
    if (!("speechSynthesis" in window)) return;
    function tryLoad() {
      const v = window.speechSynthesis.getVoices();
      if (v && v.length) {
        voicesReady = true;
      }
    }
    tryLoad();
    window.speechSynthesis.onvoiceschanged = function () {
      const v = window.speechSynthesis.getVoices();
      if (v && v.length) {
        voicesReady = true;
      }
    };
  }

  function chooseKoreanVoice() {
    if (!("speechSynthesis" in window)) return null;
    const voices = window.speechSynthesis.getVoices() || [];
    for (let i = 0; i < voices.length; i++) {
      if ((voices[i].lang || "").toLowerCase().indexOf("ko") === 0) {
        return voices[i];
      }
    }
    return voices.length ? voices[0] : null;
  }

  function speak(text, force) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const t = (text || "").trim();
    if (!t) return;

    const tNow = now();
    if (!force && tNow - lastStatusSpokenAt < TTS_STATUS_COOLDOWN_MS) return;

    function doSpeak() {
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(t);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        const v = chooseKoreanVoice();
        if (v) u.voice = v;
        lastStatusSpokenAt = tNow;
        window.speechSynthesis.speak(u);
      } catch (e) {}
    }

    if (!voicesReady) {
      setTimeout(doSpeak, 250);
    } else {
      doSpeak();
    }
  }

  function speakLong(text) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const full = (text || "").trim();
    if (!full) return;

    const chunkSize = 900;
    const chunks = [];
    for (let i = 0; i < full.length; i += chunkSize) {
      chunks.push(full.slice(i, i + chunkSize));
    }

    try {
      window.speechSynthesis.cancel();
      let idx = 0;
      const v = chooseKoreanVoice();

      function speakNext() {
        if (idx >= chunks.length) return;
        const u = new SpeechSynthesisUtterance(chunks[idx]);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        if (v) u.voice = v;
        u.onend = function () {
          idx += 1;
          speakNext();
        };
        window.speechSynthesis.speak(u);
      }

      setTimeout(speakNext, voicesReady ? 0 : 300);
    } catch (e) {}
  }

  function unlockAudioOnce() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    if (!TTS_ENABLED) return;
    speak("ìŒì„±ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.", true);
  }

  // =========================
  // 5) ì›€ì§ì„/ë°ê¸°/ê°€ë ¤ì§ ë¶„ì„
  // =========================
  function analyzeFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      return { blocked: false, stable: false, avgBright: 255, diffAvg: 0 };
    }

    bCtx.drawImage(video, 0, 0, BW, BH);
    const img = bCtx.getImageData(0, 0, BW, BH).data;

    const len = BW * BH;
    const currThumb = new Uint8Array(len);
    let sumBright = 0;
    let diffSum = 0;
    let p = 0;

    for (let i = 0; i < img.length; i += 4) {
      const r = img[i];
      const g = img[i + 1];
      const b = img[i + 2];
      const gray = (r + g + b) / 3;
      currThumb[p] = gray;
      sumBright += gray;
      if (prevThumb) {
        diffSum += Math.abs(gray - prevThumb[p]);
      }
      p++;
    }

    const avgBright = sumBright / len;
    const diffAvg = prevThumb ? diffSum / len : 0;
    prevThumb = currThumb;

    const isBlocked = avgBright < 20;
    const tNow = now();
    let stable = false;

    if (diffAvg < 8) {
      if (!lastStableStart) {
        lastStableStart = tNow;
      } else if (tNow - lastStableStart >= 900) {
        stable = true;
      }
    } else {
      lastStableStart = 0;
    }

    return { blocked: isBlocked, stable: stable, avgBright: avgBright, diffAvg: diffAvg };
  }

  function analyzeLoop() {
    const a = analyzeFrame();
    blocked = a.blocked;
    requestAnimationFrame(analyzeLoop);
  }

  // =========================
  // 6) ìº¡ì²˜(ì˜ìƒ â†’ ìº”ë²„ìŠ¤) â€“ ì „ì²´ í”„ë ˆì„ (í•­ìƒ ìµœëŒ€ ì¤Œì•„ì›ƒ)
  // =========================
  function captureToCanvas() {
    const vw = video.videoWidth;
    const vh = video.videoHeight;

    if (!vw || !vh) {
      capCanvas.width = 640;
      capCanvas.height = 360;
      capCtx.fillStyle = "black";
      capCtx.fillRect(0, 0, capCanvas.width, capCanvas.height);
      return capCanvas;
    }

    const maxW = 1920;
    const scale = vw > maxW ? maxW / vw : 1;
    const outW = Math.max(360, Math.floor(vw * scale));
    const outH = Math.max(240, Math.floor(vh * scale));

    capCanvas.width = outW;
    capCanvas.height = outH;
    capCtx.drawImage(video, 0, 0, vw, vh, 0, 0, outW, outH);
    return capCanvas;
  }

  // =========================
  // 7) ëˆ„ì  OCR + ì¤‘ë³µ ì²˜ë¦¬
  // =========================
  function tokenize(text) {
    const t = (text || "").slice(0, 1500);
    const arr = t.split(/\s+/);
    const out = [];
    for (let i = 0; i < arr.length; i++) {
      if (arr[i]) out.push(arr[i]);
    }
    if (out.length > 220) return out.slice(0, 220);
    return out;
  }

  function jaccardSimilarity(a, b) {
    const A = tokenize(a);
    const B = tokenize(b);
    if (!A.length || !B.length) return 0;

    const setA = {};
    const setB = {};
    for (let i = 0; i < A.length; i++) setA[A[i]] = true;
    for (let j = 0; j < B.length; j++) setB[B[j]] = true;

    let inter = 0;
    for (const key in setA) {
      if (setB[key]) inter++;
    }

    let sizeA = 0;
    let sizeB = 0;
    for (const k1 in setA) sizeA++;
    for (const k2 in setB) sizeB++;
    const union = sizeA + sizeB - inter;
    if (!union) return 0;
    return inter / union;
  }

  function rebuildAccumulated() {
    const texts = [];
    for (let i = 0; i < segments.length; i++) {
      texts.push(segments[i].text);
    }
    accText = texts.join("\n\n");
    accEffectiveLen = effectiveLenOf(accText);

    accBestConf = 0;
    for (let i = 0; i < segments.length; i++) {
      if (typeof segments[i].conf === "number" && segments[i].conf > accBestConf) {
        accBestConf = segments[i].conf;
      }
    }

    const maxPreview = 8000;
    if (accText.length <= maxPreview) {
      ocrPreviewEl.value = accText;
    } else {
      ocrPreviewEl.value = accText.slice(-maxPreview);
    }
  }

  function updateAccumulation(newText, newConf) {
    const cleaned = normalizeOcrText(newText);
    const effLen = effectiveLenOf(cleaned);
    if (effLen < 20) {
      return { changed: false, action: "ignore_too_short" };
    }
    if (newConf < 5) {
      return { changed: false, action: "ignore_low_conf" };
    }

    if (!segments.length) {
      segments.push({ text: cleaned, effLen: effLen, conf: newConf });
      rebuildAccumulated();
      return { changed: true, action: "append_first" };
    }

    const last = segments[segments.length - 1];
    const sim = jaccardSimilarity(last.text, cleaned);
    const DUP_SIMILARITY = 0.75;

    if (sim >= DUP_SIMILARITY) {
      const better =
        (effLen > last.effLen + 60) ||
        (Math.abs(effLen - last.effLen) <= 60 && newConf > last.conf + 4);

      if (better) {
        segments[segments.length - 1] = { text: cleaned, effLen: effLen, conf: newConf };
        rebuildAccumulated();
        return { changed: true, action: "replace_last(sim=" + sim.toFixed(2) + ")" };
      } else {
        return { changed: false, action: "dup_keep_last(sim=" + sim.toFixed(2) + ")" };
      }
    }

    segments.push({ text: cleaned, effLen: effLen, conf: newConf });
    if (segments.length > 12) {
      segments = segments.slice(segments.length - 12);
    }
    rebuildAccumulated();
    return { changed: true, action: "append_new(sim=" + sim.toFixed(2) + ")" };
  }

  // =========================
  // 8) êµ¬ì¡°/ì œì‹œë¬¸ ì¸ì‹
  // =========================
  function hasProblemStructure(text) {
    const t = text || "";
    const reQ1 = /(\[\s*ë¬¸ì œ\s*1\s*\]|ë¬¸ì œ\s*1\s*[\.\)]|1\)\s)/;
    const reQ2 = /(\[\s*ë¬¸ì œ\s*2\s*\]|ë¬¸ì œ\s*2\s*[\.\)]|2\)\s)/;
    const hasQ1 = reQ1.test(t);
    const hasQ2 = reQ2.test(t);
    return hasQ1 && hasQ2;
  }

  function hasPassageHint(text) {
    const t = text || "";
    const re = /(ì œì‹œë¬¸\s*[â… I1]|\bì œì‹œë¬¸\s*\d|\bì œì‹œë¬¸\b|ë³´ê¸°|ë‹¤ìŒ\s*ê¸€|ë‹¤ìŒì€|ìë£Œ\s*\d)/;
    return re.test(t);
  }

  function isReadyToSolve() {
    if (accEffectiveLen < MIN_SOLVE_LEN_EFFECTIVE) return false;
    const structure = hasProblemStructure(accText);
    const passage = hasPassageHint(accText);
    if (structure && (passage || accEffectiveLen >= TEXT_THRESHOLD_EFFECTIVE)) {
      return true;
    }
    return false;
  }

  function buildInsufficientReason() {
    if (blocked) {
      return "ì¹´ë©”ë¼ê°€ ê°€ë ¤ì¡ŒìŠµë‹ˆë‹¤. ë Œì¦ˆë¥¼ ê°€ë¦¬ì§€ ì•Šê²Œ í•´ì£¼ì„¸ìš”.";
    }
    if (tooFar) {
      return "ì§€ë¬¸ì´ ë„ˆë¬´ ë©€ì–´ ë³´ì…ë‹ˆë‹¤. ì¢…ì´ë¥¼ í™”ë©´ì— ë” í¬ê²Œ ì±„ì›Œì£¼ì„¸ìš”.";
    }
    if (tooNear) {
      return "ì§€ë¬¸ì´ ë„ˆë¬´ ê°€ê¹Œì›Œ ë³´ì…ë‹ˆë‹¤. 5ì—ì„œ 10ì„¼í‹°ë¯¸í„° ì •ë„ë§Œ ë©€ë¦¬ ë‘ê³  ë‹¤ì‹œ ë¹„ì¶°ì£¼ì„¸ìš”.";
    }
    if (!hasProblemStructure(accText)) {
      return "ë¬¸ì œ 1ê³¼ ë¬¸ì œ 2ê°€ ì•„ì§ ì¶©ë¶„íˆ ì¸ì‹ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ë¬¸ì œ ë¶€ë¶„ì„ í™”ë©´ì— í¬ê²Œ ë¹„ì¶°ì£¼ì„¸ìš”.";
    }
    return "ì•„ì§ ì œì‹œë¬¸ì´ë‚˜ ì¼ë¶€ ë¬¸ì¥ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. í˜ì´ì§€ë¥¼ ì¡°ê¸ˆ ë” ì˜¤ë˜, í”ë“¤ë¦¼ ì—†ì´ ë¹„ì¶°ì£¼ì„¸ìš”.";
  }

  function buildStatusLines(extraLine) {
    const lines = [];
    lines.push("ìë™ OCR(ëˆ„ì , í•œê¸€ ì „ìš©) â†’ ìë™ í’€ì´");
    lines.push("ì¹´ë©”ë¼ ìƒíƒœ: " + (blocked ? "ê°€ë ¤ì§" : "ì •ìƒ"));

    let dist = "ì •ìƒ(ì¶”ì •)";
    if (tooFar) dist = "ë„ˆë¬´ ë©‚(ì¶”ì •)";
    else if (tooNear) dist = "ë„ˆë¬´ ê°€ê¹Œì›€(ì¶”ì •)";
    lines.push("ê±°ë¦¬ ìƒíƒœ: " + dist);

    lines.push("ëˆ„ì  ì„¸ê·¸ë¨¼íŠ¸ ìˆ˜: " + segments.length);
    lines.push("ëˆ„ì  ê¸¸ì´(ê³µë°±ì œì™¸): " + accEffectiveLen);
    lines.push("OCR ì°¸ê³  ì‹ ë¢°ë„(ìµœëŒ€): " + accBestConf.toFixed(1) + "%");

    const ready = isReadyToSolve();
    lines.push("ì™„ì„± íŒì •(ë¬¸ì œ1Â·2/ì œì‹œë¬¸): " + (ready ? "OK" : "ì•„ì§ ë¶€ì¡±"));

    if (notReadySince && !ready) {
      const sec = Math.floor((now() - notReadySince) / 1000);
      lines.push("ë¶€ì¡± ì§€ì†: " + sec + "ì´ˆ (5ë¶„ ì•ˆë‚´ / 8ë¶„ ìë™í’€ì´)");
    } else {
      lines.push("ë¶€ì¡± ì§€ì†: 0ì´ˆ");
    }

    if (extraLine) {
      lines.push(String(extraLine));
    }
    return lines;
  }

  // =========================
  // 9) OCR 1íšŒ
  // =========================
  function shouldTryOcr() {
    if (solved || solving) return false;
    if (ocrRunning) return false;
    if (blocked) return false;

    const tNow = now();
    if (tNow - lastOcrAt < OCR_INTERVAL_MS) return false;

    const a = analyzeFrame();
    if (!a.stable) return false;

    return true;
  }

  function doOcrOnce() {
    if (!shouldTryOcr()) return;
    ocrRunning = true;
    lastOcrAt = now();

    const canvas = captureToCanvas();
    setStatus(buildStatusLines("OCR ì§„í–‰ ì¤‘..."));

    Tesseract.recognize(canvas, OCR_LANG, {
      logger: function (m) {
        if (m && m.status === "recognizing text") {
          const p = Math.round((m.progress || 0) * 100);
          setStatus(buildStatusLines("OCR ì§„í–‰ ì¤‘... " + p + "%"));
        }
      }
    }).then(function (result) {
      const rawText =
        result && result.data && result.data.text ? result.data.text : "";
      const conf =
        result && result.data && typeof result.data.confidence === "number"
          ? result.data.confidence
          : 0;

      const cleaned = normalizeOcrText(rawText);
      const effLen = effectiveLenOf(cleaned);

      // ê±°ë¦¬ ì¶”ì • (ì¹´ë©”ë¼ê°€ ë„ˆë¬´ ë©€ê±°ë‚˜, ë„ˆë¬´ ê°€ê¹Œìš´ì§€)
      tooFar = (effLen < 400 && conf < 35);
      tooNear = (effLen >= 800 && conf < 35);

      const mergeInfo = updateAccumulation(cleaned, conf);

      const ready = isReadyToSolve();
      const tNow = now();
      if (!ready) {
        if (!notReadySince) notReadySince = tNow;
      } else {
        notReadySince = null;
      }

      setStatus(buildStatusLines("OCR ì™„ë£Œ Â· ëˆ„ì : " + mergeInfo.action));

      if (!solved && !solving) {
        if (ready) {
          autoSolve("ë¬¸ì œ/ì œì‹œë¬¸ êµ¬ì¡° ì¸ì‹ ì™„ë£Œ");
          return;
        }
        if (notReadySince) {
          const dur = tNow - notReadySince;
          if (dur >= INSUFFICIENT_WARN_MS && dur < MAX_WAIT_MS) {
            speak(buildInsufficientReason(), false);
          }
          if (dur >= MAX_WAIT_MS) {
            autoSolve("8ë¶„ ê²½ê³¼. í˜„ì¬ ì¸ì‹ëœ ë‚´ìš©ìœ¼ë¡œ í’€ì´");
            return;
          }
        }
      }
    }).catch(function (e) {
      console.error(e);
      setStatus(buildStatusLines("OCR ì—ëŸ¬: " + String(e)));
    }).finally(function () {
      ocrRunning = false;
    });
  }

  // =========================
  // 10) solve í˜¸ì¶œ
  // =========================
  function autoSolve(reason) {
    if (solved || solving) return;
    solving = true;

    let payloadText = (accText || "").trim();
    if (payloadText.length > 8000) {
      payloadText = payloadText.slice(0, 8000);
    }

    setStatus(buildStatusLines("í’€ì´ ìš”ì²­ ì¤‘... (" + reason + ")"));
    answerBoxEl.textContent = "í’€ì´ ìƒì„± ì¤‘...";

    fetch(SOLVE_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ ocrText: payloadText })
    })
      .then(function (res) {
        const ct = (res.headers.get("content-type") || "").toLowerCase();
        if (ct.indexOf("application/json") !== -1) {
          return res.json().then(function (data) {
            return { ok: res.ok, status: res.status, data: data, text: null };
          });
        }
        return res.text().then(function (text) {
          return { ok: res.ok, status: res.status, data: null, text: text };
        });
      })
      .then(function (resObj) {
        if (!resObj.ok) {
          const msg = resObj.text || JSON.stringify(resObj.data || {});
          answerBoxEl.textContent =
            "ì„œë²„ ì—ëŸ¬ (status " + resObj.status + ")\n\n" + msg.slice(0, 4000);
          speak("ì„œë²„ ì—ëŸ¬ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", true);
          solving = false;
          return;
        }

        let out = "";
        if (resObj.data && typeof resObj.data.answer === "string") {
          out = resObj.data.answer;
        } else if (resObj.data && typeof resObj.data.body === "string") {
          out = resObj.data.body;
        } else if (typeof resObj.text === "string") {
          out = resObj.text;
        } else {
          out = JSON.stringify(resObj.data || {});
        }

        solved = true;
        answerBoxEl.textContent = out;
        setStatus(buildStatusLines("í’€ì´ ì™„ë£Œ"));
        speak("ë‹µì•ˆì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.", true);
        speakLong(out);
      })
      .catch(function (e) {
        console.error(e);
        answerBoxEl.textContent = "ìš”ì²­ ì‹¤íŒ¨: " + String(e);
        speak("ìš”ì²­ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", true);
      })
      .finally(function () {
        solving = false;
      });
  }

  // =========================
  // 11) OCR ë£¨í”„ & ì¹´ë©”ë¼ ì‹œì‘
  // =========================
  function scheduleOcrLoop() {
    doOcrOnce();
    setInterval(function () {
      doOcrOnce();
    }, OCR_INTERVAL_MS);
  }

  function setupZoomFromTrack() {
    if (!stream || !zoomRangeEl) return;
    const tracks = stream.getVideoTracks();
    if (!tracks || !tracks.length) return;

    const track = tracks[0];

    const supported = navigator.mediaDevices.getSupportedConstraints
      ? navigator.mediaDevices.getSupportedConstraints()
      : {};
    const browserSupportsZoom = !!(supported && supported.zoom);

    if (!browserSupportsZoom || typeof track.getCapabilities !== "function") {
      zoomRangeEl.disabled = true;
      if (zoomLabelEl) zoomLabelEl.textContent = "ê¸°ê¸° ì¤Œ ì œì–´ ë¶ˆê°€";
      return;
    }

    let caps;
    try {
      caps = track.getCapabilities();
    } catch (e) {
      zoomRangeEl.disabled = true;
      if (zoomLabelEl) zoomLabelEl.textContent = "ê¸°ê¸° ì¤Œ ì œì–´ ë¶ˆê°€";
      return;
    }

    if (!caps || typeof caps.zoom === "undefined") {
      zoomRangeEl.disabled = true;
      if (zoomLabelEl) zoomLabelEl.textContent = "ê¸°ê¸° ì¤Œ ì œì–´ ë¶ˆê°€";
      return;
    }

    const settings =
      typeof track.getSettings === "function" ? track.getSettings() : {};

    const min = typeof caps.zoom.min === "number" ? caps.zoom.min : 1;
    const max = typeof caps.zoom.max === "number" ? caps.zoom.max : Math.max(min, 3);
    const step = typeof caps.zoom.step === "number" && caps.zoom.step > 0 ? caps.zoom.step : 0.1;
    const current = typeof settings.zoom === "number" ? settings.zoom : min;

    zoomRangeEl.min = String(min);
    zoomRangeEl.max = String(max);
    zoomRangeEl.step = String(step);
    // â€œìµœëŒ€ ì¤Œì•„ì›ƒâ€ìœ¼ë¡œ ì‹œì‘: min
    zoomRangeEl.value = String(min);

    if (zoomLabelEl) {
      zoomLabelEl.textContent = min.toFixed(2) + "x(ì¤Œì•„ì›ƒ)";
    }

    function applyZoom(v) {
      track
        .applyConstraints({ advanced: [{ zoom: v }] })
        .catch(function (e) {
          console.warn("zoom ì ìš© ì‹¤íŒ¨:", e);
        });
    }

    // ì´ˆê¸° í•œ ë²ˆ ì¤Œì•„ì›ƒ ì ìš©
    applyZoom(min);

    zoomRangeEl.disabled = false;
    zoomRangeEl.addEventListener("input", function () {
      const v = parseFloat(this.value);
      if (isNaN(v)) return;
      applyZoom(v);
      if (zoomLabelEl) {
        zoomLabelEl.textContent = v.toFixed(2) + "x";
      }
    });
  }

  function startCamera() {
    setStatus([
      "ì¹´ë©”ë¼ ìš”ì²­ ì¤‘...",
      "iOS ê¶Œí•œ íŒì—…ì´ ëœ¨ë©´ 'í—ˆìš©'ì„ ëˆŒëŸ¬ì•¼ í•©ë‹ˆë‹¤."
    ]);

    navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 },
        frameRate: { ideal: 30 },
        // ê°€ëŠ¥í•œ ê²½ìš° PTZ/zoom ê¶Œí•œê¹Œì§€ ìš”ì²­
        zoom: true
      },
      audio: false
    }).then(function (s) {
      stream = s;
      video.srcObject = stream;

      if (video.readyState >= 2) {
        afterMetadata();
      } else {
        video.onloadedmetadata = afterMetadata;
      }
    }).catch(function (e) {
      console.error(e);
      setStatus(["ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨", String(e)]);
      speak("ì¹´ë©”ë¼ ì ‘ê·¼ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", true);
    });
  }

  function afterMetadata() {
    setStatus([
      "ì¹´ë©”ë¼ ON",
      "ìë™ OCR ì‹œì‘ë¨ (3ì´ˆë§ˆë‹¤, í™”ë©´ì´ ì•ˆì •ë  ë•Œë§Œ ë™ì‘)",
      "ìŒì„±ì´ ì•ˆ ë‚˜ì˜¤ë©´: í™”ë©´ì„ í•œ ë²ˆ íƒ­ + ë¬´ìŒëª¨ë“œ í•´ì œ + ë³¼ë¥¨ ì˜¬ë¦¬ê¸°"
    ]);
    setupZoomFromTrack();      // â† ì—¬ê¸°ì„œ ì‹¤ì œ ì¹´ë©”ë¼ ì¤Œ ë°°ìœ¨ ì œì–´ (ì§€ì›ë˜ëŠ” ê¸°ê¸°ì—ì„œë§Œ)
    requestAnimationFrame(analyzeLoop);
    scheduleOcrLoop();
  }

  // =========================
  // 12) ì´ˆê¸°í™”
  // =========================
  initVoices();
  document.addEventListener("click", unlockAudioOnce, { passive: true, once: true });
  document.addEventListener("touchstart", unlockAudioOnce, { passive: true, once: true });
  startCamera();
})();
</script>


