<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>autononsul - OCR/solve</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <style>
    * { box-sizing: border-box; }
    body {
      margin:0; padding:12px;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      background:#0b0b0b; color:#fff;
    }
    h1 { font-size:16px; margin:0 0 10px; }
    #status {
      font-size:12px; color:#c4f1ff;
      white-space:pre-wrap;
      padding:8px; border:1px solid #333;
      border-radius:10px; background:#070707;
    }
    #videoBox {
      margin-top:10px; border:1px solid #333;
      border-radius:10px; overflow:hidden; background:#000;
    }
    video { width:100%; height:auto; display:block; }

    .row { display:flex; gap:8px; margin-top:10px; }
    button {
      flex:1; padding:10px 12px;
      font-size:14px;
      border-radius:10px;
      border:1px solid #555;
      background:#151515; color:#fff;
    }
    button:active { transform: scale(0.98); }
    button:disabled { opacity:0.5; }

    textarea {
      width:100%; min-height:140px;
      margin-top:8px; padding:10px;
      border-radius:10px; border:1px solid #333;
      background:#060606; color:#fff;
      font-size:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }
    .hint { font-size:11px; color:#aaa; margin-top:6px; }

    #errOverlay {
      position:fixed; inset:0;
      background:rgba(0,0,0,0.92); color:#fff;
      padding:14px;
      display:none; z-index:9999; overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }
    #errOverlay button { margin-top:10px; width:auto; }

    .smallRow {
      display:flex; gap:8px;
      margin-top:8px; align-items:center;
    }
    .badge {
      font-size:11px; padding:4px 8px;
      border-radius:999px;
      border:1px solid #444;
      background:#111; color:#ddd;
    }
    #pageDisplay {
      font-weight:bold;
      margin-left:4px;
    }
  </style>
</head>

<body>
  <div id="errOverlay"></div>

  <h1>ì—°ì„¸ëŒ€ ë…¼ìˆ  ìë™ OCR/í’€ì´</h1>
  <div id="status">í˜ì´ì§€ ë¡œë”©ë¨. ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...</div>

  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <div class="smallRow">
    <div class="badge">OCR: í•œê¸€ + ì˜ì–´ + ìˆ«ì/ê¸°í˜¸</div>
    <div style="margin-left:auto; font-size:12px; color:#ccc;">
      í˜„ì¬ í˜ì´ì§€: <span id="pageDisplay">1 / 12</span>
    </div>
  </div>

  <div class="row">
    <button id="btnShutter">ğŸ“¸ ì…”í„°(í˜ì´ì§€ ìë™ ìŠ¤ìº” ì‹œì‘)</button>
    <button id="btnSolve">ğŸ“ í’€ê¸°(ìˆ˜ë™ ì¬ì‹œì‘ìš©)</button>
  </div>

  <div class="hint">
    - ì…”í„°ë¥¼ í•œ ë²ˆ ëˆ„ë¥´ë©´, í˜ì´ì§€ 1ë¶€í„° ì‹œì‘í•´ì„œ ê° í˜ì´ì§€ë¥¼ 5ì´ˆ ê°„ê²©ìœ¼ë¡œ 5íšŒ ì´¬ì˜/OCRí•˜ê³ , ê·¸ ì¤‘ ì‹ ë¢°ë„ê°€ ê°€ì¥ ë†’ì€ ê²°ê³¼ë§Œ ì‚¬ìš©í•œë‹¤.<br/>
    - OCR ëˆ„ì  í…ìŠ¤íŠ¸ ì•ˆì— â€œì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤â€ê°€ ë“¤ì–´ì˜¤ë©´, ê·¸ í˜ì´ì§€ê¹Œì§€ ìŠ¤ìº”í•œ ë’¤ AI í’€ì´ê°€ ìë™ìœ¼ë¡œ ì‹œì‘ëœë‹¤.<br/>
    - í˜ì´ì§€ ì‚¬ì´ì—ëŠ” â€œ5 4 3 2 1â€ ì•ˆë‚´ ìŒì„±ì´ ë‚˜ì˜¤ê³ , ê·¸ ì‚¬ì´ì— ë‹¤ìŒ ì¥ìœ¼ë¡œ ë„˜ê¸°ë©´ ëœë‹¤.
  </div>

  <textarea id="ocrBox" placeholder="OCR ëˆ„ì  í…ìŠ¤íŠ¸"></textarea>
  <textarea id="answerBox" placeholder="AI ë‹µì•ˆ"></textarea>

<script>
(function() {
  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnShutter = document.getElementById("btnShutter");
  const btnSolve = document.getElementById("btnSolve");
  const ocrBox = document.getElementById("ocrBox");
  const answerBox = document.getElementById("answerBox");
  const errOverlay = document.getElementById("errOverlay");
  const pageDisplay = document.getElementById("pageDisplay");

  const OCR_URL = "/.netlify/functions/ocr";
  const SOLVE_URL = "/.netlify/functions/solve";

  const MULTI_SHOTS = 5;
  const SHOT_INTERVAL_MS = 5000;
  const MAX_PAGES = 12;

  let currentPageIndex = 1;
  let scanningAll = false;
  let autoSolveTriggered = false;

  // ----- ê³µí†µ ìœ í‹¸ -----
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  function updatePageDisplay() {
    pageDisplay.textContent = currentPageIndex + " / " + MAX_PAGES;
  }

  function showErrorOverlay(title, detail) {
    try {
      errOverlay.innerHTML = "";
      errOverlay.style.display = "block";
      const pre = document.createElement("div");
      pre.textContent = "[ERROR]\n" + (title || "") + "\n\n" + (detail || "") + "\n\n(ì•„ë˜ ë²„íŠ¼ ëˆ„ë¥´ë©´ ë‹«í˜)";
      errOverlay.appendChild(pre);

      const btn = document.createElement("button");
      btn.textContent = "ë‹«ê¸°";
      btn.onclick = () => {
        errOverlay.style.display = "none";
        errOverlay.innerHTML = "";
      };
      errOverlay.appendChild(btn);
    } catch (e) {}
  }

  window.addEventListener("error", (e) => {
    const msg = e.message || "Unknown JS error";
    const stack = e.error && e.error.stack ? e.error.stack : "";
    showErrorOverlay(msg, stack);
  });

  window.addEventListener("unhandledrejection", (e) => {
    const msg = (e && e.reason) ? (e.reason.message || String(e.reason)) : "Unhandled rejection";
    const stack = (e && e.reason && e.reason.stack) ? e.reason.stack : "";
    showErrorOverlay(msg, stack);
  });

  // ----- TTS (ìƒíƒœ vs ë‹µì•ˆ) -----
  let ttsPrimed = false;

  function primeTTS() {
    if (ttsPrimed) return;
    ttsPrimed = true;
    if (!window.speechSynthesis) return;
    try {
      const u = new SpeechSynthesisUtterance("ìŒì„± ì—°ê²° í…ŒìŠ¤íŠ¸");
      u.lang = "ko-KR";
      u.rate = 1.0;
      u.onend = () => {
        window.speechSynthesis.cancel();
      };
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  function speakOnce(text, rate, repeat) {
    if (!text) return;
    if (!window.speechSynthesis) return;

    try {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "ko-KR";
      u.rate = rate;
      u.pitch = 1.0;
      u.onend = () => {
        if (repeat) {
          setTimeout(() => {
            speakOnce(text, rate, true);
          }, 900);
        }
      };
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  function toWongojiSpeech(text) {
    let t = String(text || "");
    t = t.replace(/\r/g, "");
    t = t.replace(/\n+/g, " ì¤„ë°”ê¿ˆ ");
    t = t.replace(/ /g, " ë„ìš°ê³  ");
    t = t.replace(/\./g, " ë§ˆì¹¨í‘œ ");
    t = t.replace(/,/g, " ì‰¼í‘œ ");
    t = t.replace(/!/g, " ëŠë‚Œí‘œ ");
    t = t.replace(/\?/g, " ë¬¼ìŒí‘œ ");
    return t;
  }

  function speakStatus(text) {
    speakOnce(text, 1.0, false);
  }

  function speakAnswer(text) {
    speakOnce(toWongojiSpeech(text), 0.72, true);
  }

  async function speakCountdown() {
    // 5 4 3 2 1 ìˆ«ì ì•ˆë‚´, ì•½ 5ì´ˆ ëŒ€ê¸°
    speakStatus("ë‹¤ìŒ ì¥ì„ ì¤€ë¹„í•˜ì„¸ìš”. 5, 4, 3, 2, 1.");
    await sleep(5000);
  }

  // ----- ì¹´ë©”ë¼ -----
  let stream = null;

  async function startCamera() {
    try {
      statusEl.textContent = "ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­ ì¤‘...";
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        statusEl.textContent = "ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì¹´ë©”ë¼ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
        return;
      }
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 2560 },
          height: { ideal: 1440 }
        },
        audio: false
      });
      video.srcObject = stream;
      statusEl.textContent = "ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ. ì…”í„°ë¥¼ ëˆ„ë¥´ë©´ í˜ì´ì§€ 1ë¶€í„° ìë™ ìŠ¤ìº”ì„ ì‹œì‘í•©ë‹ˆë‹¤.";
    } catch (e) {
      statusEl.textContent = "ì¹´ë©”ë¼ ì‹¤íŒ¨: " + (e.message || String(e));
      showErrorOverlay("ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨", String(e && e.message ? e.message : e));
    }
  }

  function captureDataUrl() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) return null;
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);
    return canvas.toDataURL("image/jpeg", 0.9);
  }

  // ----- ìë™ í’€ì´ íŠ¸ë¦¬ê±° -----
  function shouldAutoSolve(allText) {
    const s = String(allText || "").replace(/\s/g, "");
    return s.includes("ì´ì œí’€ì´ë¥¼ì‹œì‘í•˜ì‹œì˜¤");
  }

  // ----- í•œ í˜ì´ì§€(5íšŒ ì´¬ì˜) OCR -----
  async function ocrOnePage(pageIndex) {
    let best = null; // { text, conf }

    for (let i = 1; i <= MULTI_SHOTS; i++) {
      statusEl.textContent = `í˜ì´ì§€ ${pageIndex} OCR: ${i}/${MULTI_SHOTS}íšŒ ì´¬ì˜ ì¤‘...`;

      const dataUrl = captureDataUrl();
      if (!dataUrl) {
        statusEl.textContent = "ì˜ìƒ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤. 1~2ì´ˆ í›„ ìë™ ì¬ì‹œë„...";
        await sleep(1200);
      } else {
        try {
          const res = await fetch(OCR_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              imageBase64: dataUrl,
              pageIndex,
              mode: "dual"
            })
          });
          const json = await res.json().catch(() => null);

          if (json && json.ok && json.text && json.text.trim()) {
            const conf = typeof json.conf === "number" ? json.conf : 0;
            if (!best || conf > best.conf) {
              best = { text: json.text, conf };
            }
          }
        } catch (e) {
          if (i === MULTI_SHOTS && !best) {
            showErrorOverlay("OCR ìš”ì²­ ì‹¤íŒ¨", String(e && e.stack ? e.stack : e));
          }
        }
      }

      if (i < MULTI_SHOTS) {
        await sleep(SHOT_INTERVAL_MS);
      }
    }

    return best;
  }

  // ----- ì „ì²´ í˜ì´ì§€ ìë™ ìŠ¤ìº” -----
  async function scanPagesFromCurrent() {
    btnShutter.disabled = true;
    btnSolve.disabled = true;

    for (; currentPageIndex <= MAX_PAGES; currentPageIndex++) {
      updatePageDisplay();
      const pageIndex = currentPageIndex;

      const best = await ocrOnePage(pageIndex);

      if (!best) {
        statusEl.textContent = `í˜ì´ì§€ ${pageIndex} OCR 5íšŒ ëª¨ë‘ ì‹¤íŒ¨. ìŠ¤ìº”ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.`;
        speakStatus("ì˜¤ì”¨ì•Œ ë‹¤ì„¯ ë²ˆ ëª¨ë‘ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì…”í„°ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.");
        break;
      }

      const block = `\n\n[í˜ì´ì§€ ${pageIndex}]-------------------\n${best.text}`;
      ocrBox.value = (ocrBox.value || "") + block;

      statusEl.textContent = `OCR ì™„ë£Œ: í˜ì´ì§€ ${pageIndex} (ìµœê³  ì‹ ë¢°ë„ ì•½ ${(best.conf || 0).toFixed(1)}%)`;
      speakStatus("ì˜¤ì”¨ì•Œ ì™„ë£Œ");

      if (shouldAutoSolve(ocrBox.value)) {
        autoSolveTriggered = true;
        statusEl.textContent += "\n\n'ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤' ë¬¸êµ¬ë¥¼ ê°ì§€í–ˆìŠµë‹ˆë‹¤. ì´ í˜ì´ì§€ê¹Œì§€ë§Œ ìŠ¤ìº”í•˜ê³  ìë™ìœ¼ë¡œ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.";
        break;
      }

      if (currentPageIndex < MAX_PAGES) {
        statusEl.textContent += "\n\në‹¤ìŒ ì¥ìœ¼ë¡œ ë„˜ê¸¸ ì¤€ë¹„ë¥¼ í•˜ì„¸ìš”.";
        await speakCountdown();
      }
    }

    btnShutter.disabled = false;
    btnSolve.disabled = false;

    if (autoSolveTriggered) {
      await doSolve();
    } else {
      statusEl.textContent += "\n\nìë™ í’€ì´ ì¡°ê±´ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. í•„ìš”í•˜ë©´ 'í’€ê¸°' ë²„íŠ¼ìœ¼ë¡œ ìˆ˜ë™ í’€ì´ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.";
    }
  }

  // ----- Solve (AI í’€ì´) -----
  async function doSolve() {
    primeTTS();

    const text = (ocrBox.value || "").trim();
    if (!text) {
      statusEl.textContent = "ë¨¼ì € ì…”í„°ë¡œ OCRì„ ìŒ“ì•„ì£¼ì„¸ìš”.";
      speakStatus("ë¨¼ì € ì˜¤ì”¨ì•Œì„ ì§„í–‰í•˜ì„¸ìš”.");
      return;
    }

    statusEl.textContent = "AI í’€ì´ ìš”ì²­ ì¤‘... (ìµœëŒ€ ìˆ˜ì‹­ ì´ˆ ê±¸ë¦´ ìˆ˜ ìˆìŒ)";
    try {
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          text,
          targetChars: 1000,
          tolerance: 120
        })
      });

      const json = await res.json().catch(() => null);
      if (!json || !json.ok) {
        const msg = (json && (json.message || json.error)) || "solve ì‹¤íŒ¨";
        statusEl.textContent = `í’€ì´ ì‹¤íŒ¨: ${msg}`;
        speakStatus("í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        return;
      }

      const answer = (json.answer || "").trim();
      answerBox.value = answer || "(ë¹ˆ ì‘ë‹µ)";
      statusEl.textContent = "í’€ì´ ì™„ë£Œ. (ì›ê³ ì§€ ëª¨ë“œë¡œ ëŠë¦¬ê²Œ ë°˜ë³µ ë‚­ë…)";
      speakAnswer(answer);
    } catch (e) {
      statusEl.textContent = "í’€ì´ ìš”ì²­ ì‹¤íŒ¨: " + (e.message || String(e));
      showErrorOverlay("solve ìš”ì²­ ì‹¤íŒ¨", String(e && e.stack ? e.stack : e));
    }
  }

  // ----- í™”ë©´ êº¼ì§ ë°©ì§€ ì‹œë„ (Wake Lock) -----
  let wakeLock = null;

  async function requestWakeLock() {
    try {
      if (!("wakeLock" in navigator)) {
        // í™•ì‹¤í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: iOS SafariëŠ” wakeLockì„ ì§€ì›í•˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ.
        return;
      }
      wakeLock = await navigator.wakeLock.request("screen");
      wakeLock.addEventListener("release", () => {
        wakeLock = null;
      });
    } catch (e) {
      // ìš”ì²­ ì‹¤íŒ¨í•´ë„ ë™ì‘ì€ ê³„ì†ë¨ (ë‹¨, í™”ë©´ ìë™êº¼ì§ì€ OS ì„¤ì •ì— ë”°ë¦„)
    }
  }

  document.addEventListener("visibilitychange", () => {
    if (wakeLock && document.visibilityState === "visible") {
      requestWakeLock();
    }
  });

  // ----- ë²„íŠ¼ ì´ë²¤íŠ¸ -----
  btnShutter.addEventListener("click", () => {
    primeTTS();
    if (scanningAll) {
      statusEl.textContent = "ì´ë¯¸ ì „ì²´ OCR ì¤‘ì…ë‹ˆë‹¤. ì ì‹œ ê¸°ë‹¤ë¦¬ì„¸ìš”.";
      speakStatus("ì´ë¯¸ ì´¬ì˜ ì¤‘ì…ë‹ˆë‹¤.");
      return;
    }
    scanningAll = true;
    autoSolveTriggered = false;
    scanPagesFromCurrent().finally(() => {
      scanningAll = false;
    });
  });

  btnSolve.addEventListener("click", () => {
    primeTTS();
    autoSolveTriggered = true;
    doSolve();
  });

  // ----- ì‹œì‘ -----
  updatePageDisplay();
  startCamera();
  requestWakeLock();
})();
</script>
</body>
</html>
