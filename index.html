<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>답안 TTS + 자동 OCR</title>
  <style>
    :root { --topbar-h: 74px; }

    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      margin: 0;
      background:#0b0f14;
      color:#e9eef5;
    }

    .spacer { height: var(--topbar-h); }

    .wrap { max-width: 920px; margin: 0 auto; padding: 18px; }

    h1 { margin: 8px 0 14px; font-size: 20px; }
    .pill {
      display:inline-block; padding:2px 8px; border-radius:999px;
      border:1px solid #22304a; background:#0e1422; font-size:12px; margin-left:6px;
    }

    .card {
      background:#121826;
      border:1px solid #22304a;
      border-radius:16px;
      padding:14px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25);
    }

    label { display:block; font-size:12px; opacity:.85; margin: 10px 0 6px; }

    input, select, button, textarea {
      width:100%;
      box-sizing:border-box;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid #22304a;
      background:#0e1422;
      color:#e9eef5;
      font-size:14px;
    }

    textarea {
      height: 120px;
      resize: none;
      overflow-y: auto;
      line-height: 1.5;
    }

    .row { display:flex; gap:10px; flex-wrap: wrap; }
    .row > * { flex: 1; min-width: 160px; }

    button { cursor:pointer; font-weight:800; }
    button.primary { background:#2563eb; border-color:#2563eb; }
    button.warn { background:#b91c1c; border-color:#b91c1c; }
    button.ghost { background:transparent; }

    .muted { font-size:12px; opacity:.8; margin-top:10px; }

    .log {
      margin-top:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
      font-size:12px;
      white-space:pre-wrap;
      background:#0e1422;
      border:1px solid #22304a;
      border-radius:12px;
      padding:10px;
    }

    .lockTitle { margin-top: 14px; font-size: 12px; opacity: .9; }
    .locked input, .locked select { opacity: .85; cursor: not-allowed; }

    .topbar {
      position: fixed;
      top: 0; left: 0; right: 0;
      z-index: 9999;
      background: rgba(18, 24, 38, 0.98);
      border-bottom: 1px solid #22304a;
      backdrop-filter: blur(8px);
      box-shadow: 0 10px 25px rgba(0,0,0,.35);
    }
    .topbarInner {
      max-width: 920px;
      margin: 0 auto;
      padding: 12px 18px;
    }
    .topbar .row > * { min-width: 120px; }
    .statusMini {
      margin-top: 8px;
      font-size: 12px;
      opacity: .85;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  </style>
</head>

<body>
  <div class="topbar">
    <div class="topbarInner">
      <div class="row">
        <div style="flex:2; min-width:220px;">
          <button class="primary" id="playBtn">▶ 재생</button>
        </div>
        <div>
          <button class="ghost" id="pauseBtn">⏸ 일시정지/재개</button>
        </div>
        <div>
          <button class="warn" id="stopBtn">■ 정지</button>
        </div>
      </div>
      <div class="statusMini" id="miniStatus">대기 중…</div>
    </div>
  </div>

  <div class="spacer"></div>

  <div class="wrap">
    <h1>답안 TTS + 자동 OCR <span class="pill">고정 설정 · 5회 반복</span></h1>

    <div class="card">
      <label for="answers">정답 넣기 (한 줄에 하나) / 또는 한 줄로 “2 3 1 4 2” 붙여넣기</label>
      <textarea id="answers" placeholder="예)
1번 2
2번 3
3번 1
4번 4
5번 2

또는 한 줄:
2 3 1 4 2"></textarea>

      <div class="muted">
        iPhone/Safari는 자동재생이 막혀서 <b>반드시 재생 버튼을 눌러야</b> 음성이 나와.
      </div>

      <div class="lockTitle">고정 설정(수정 불가)</div>
      <div class="row locked">
        <div>
          <label>반복 횟수</label>
          <input id="repeatCount" type="number" value="5" disabled />
        </div>
        <div>
          <label>문항 사이 쉬는 시간(초)</label>
          <input id="pauseSec" type="number" value="2" disabled />
        </div>
        <div>
          <label>속도 (0.5~2)</label>
          <input id="rate" type="number" value="1" disabled />
        </div>
        <div>
          <label>피치 (0~2)</label>
          <input id="pitch" type="number" value="1" disabled />
        </div>
      </div>

      <div class="row locked" style="margin-top:8px;">
        <div>
          <label>목소리(Voice) — 유나(ko-KR) 우선</label>
          <select id="voice" disabled></select>
        </div>
      </div>

      <div class="log" id="log">대기 중…</div>

      <div style="margin-top:14px; border-top:1px solid #22304a; padding-top:10px;">
        <div class="muted">
          자동 OCR/풀이 상태: <span id="autoStatus">대기 중</span>
        </div>
        <video id="video" autoplay playsinline muted
               style="width:100%; max-height:220px; margin-top:8px; border-radius:12px; background:#000;"></video>
        <canvas id="captureCanvas" style="display:none;"></canvas>
        <div class="muted">
          페이지 안 아무 곳이나 처음 한 번 탭/클릭하면 카메라 권한을 요청하고,<br/>
          <b>QOPHY</b>가 보이는 페이지부터 자동으로 풀고 읽어줘. <b>XURTH</b>가 보이면 완전히 정지.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const FIXED = {
    repeatCount: 5,
    pauseSec: 2,
    rate: 1,
    pitch: 1,
    preferVoiceKeywords: ["유나", "Yuna"],
  };

  const elAnswers = document.getElementById('answers');
  const elRepeat  = document.getElementById('repeatCount');
  const elPause   = document.getElementById('pauseSec');
  const elRate    = document.getElementById('rate');
  const elPitch   = document.getElementById('pitch');
  const elVoice   = document.getElementById('voice');
  const elLog     = document.getElementById('log');
  const elMini    = document.getElementById('miniStatus');
  const elAutoStatus = document.getElementById('autoStatus');

  const playBtn   = document.getElementById('playBtn');
  const pauseBtn  = document.getElementById('pauseBtn');
  const stopBtn   = document.getElementById('stopBtn');

  const video  = document.getElementById('video');
  const canvas = document.getElementById('captureCanvas');

  let voices = [];
  let abortFlag = false;
  let isRunning = false;

  const AUTO = {
    enabled: false,
    running: false,
    page: 1,
    wakeLock: null,
  };

  let cameraStarted = false;

  elRepeat.value = String(FIXED.repeatCount);
  elPause.value  = String(FIXED.pauseSec);
  elRate.value   = String(FIXED.rate);
  elPitch.value  = String(FIXED.pitch);

  function log(msg) {
    elLog.textContent = msg;
    elMini.textContent = msg.split('\n')[0] || msg;
  }
  function setAutoStatus(msg) {
    elAutoStatus.textContent = msg;
  }

  function normalizeLines(text) {
    return text.split(/\r?\n/g).map(s => s.trim()).filter(Boolean);
  }

  function parseWithQuestionNumbers(text) {
    const lines = normalizeLines(text);
    const items = [];
    for (const line of lines) {
      let m = line.match(/^\s*(\d+)\s*(?:번|번에|번은|번:|번\)|\)|\.|:|-)?\s*([A-Ea-e]|[1-5])\s*$/);
      if (!m) m = line.match(/^\s*(\d+)\s*[-:)\s]+\s*([A-Ea-e]|[1-5])\s*$/);
      if (!m) continue;
      const q = parseInt(m[1], 10);
      const aRaw = m[2].toString().trim();
      const a = /^[a-e]$/i.test(aRaw) ? aRaw.toUpperCase() : aRaw;
      items.push({ q, a });
    }
    items.sort((x, y) => x.q - y.q);
    return items;
  }

  function parseSequentialAnswers(text) {
    const t = text.trim();
    if (!t) return [];
    const hasNewline = /\r|\n/.test(t);
    const hasBeon = t.includes("번");
    if (hasNewline || hasBeon) return [];

    let tokens = t.split(/[^0-9A-Za-z]+/g).filter(Boolean);
    if (tokens.length === 1 && /^[1-5A-Ea-e]+$/.test(tokens[0]) && tokens[0].length >= 2) {
      tokens = tokens[0].split('');
    }

    const norm = tokens
      .map(x => x.trim())
      .filter(Boolean)
      .map(x => /^[a-e]$/i.test(x) ? x.toUpperCase() : x);

    if (!norm.length) return [];
    const ok = norm.every(x => /^[1-5]$/.test(x) || /^[A-E]$/.test(x));
    if (!ok) return [];

    return norm.map((a, i) => ({ q: i + 1, a }));
  }

  function parseAnswers(text) {
    const a = parseWithQuestionNumbers(text);
    if (a.length) return a;
    return parseSequentialAnswers(text);
  }

  elAnswers.addEventListener('paste', (e) => {
    try {
      const clip = (e.clipboardData || window.clipboardData).getData('text');
      const items = parseSequentialAnswers(clip);
      if (items.length) {
        e.preventDefault();
        const converted = items.map(x => `${x.q}번 ${x.a}`).join('\n');
        elAnswers.value = converted;
        log(`✅ 한 줄 입력 자동변환: ${items.length}개`);
      }
    } catch (_) {}
  });

  function sleep(ms) {
    return new Promise(res => setTimeout(res, ms));
  }

  function pickFixedVoice() {
    const lowerKeywords = FIXED.preferVoiceKeywords.map(k => k.toLowerCase());
    const byName = voices.find(v => lowerKeywords.some(k => (v.name || "").toLowerCase().includes(k)));
    if (byName) return byName;

    const koDefault = voices.find(v => (v.lang || '').toLowerCase().startsWith('ko') && v.default);
    if (koDefault) return koDefault;

    const koAny = voices.find(v => (v.lang || '').toLowerCase().startsWith('ko'));
    if (koAny) return koAny;

    return voices[0] || null;
  }

  function speakOnce(text, { rate, pitch, voice } = {}) {
    return new Promise((resolve, reject) => {
      if (!('speechSynthesis' in window)) {
        reject(new Error('이 브라우저는 Web Speech TTS를 지원하지 않아.'));
        return;
      }
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'ko-KR';
      u.rate = rate;
      u.pitch = pitch;
      if (voice) u.voice = voice;
      u.onend = () => resolve();
      u.onerror = (e) => reject(e);
      window.speechSynthesis.speak(u);
    });
  }

  async function runTTS() {
    abortFlag = false;
    isRunning = true;

    const items = parseAnswers(elAnswers.value);
    if (!items.length) {
      log("❌ 파싱된 답안이 없어. 예) '1번 2' 또는 한 줄 '2 3 1 4 2'로 넣어줘.");
      isRunning = false;
      return;
    }

    log(`✅ 파싱 ${items.length}개 · ${FIXED.repeatCount}회 반복 시작…`);

    const repeatCount = FIXED.repeatCount;
    const pauseMs = FIXED.pauseSec * 1000;
    const rate = FIXED.rate;
    const pitch = FIXED.pitch;

    const idx = parseInt(elVoice.value || "0", 10);
    const voice = voices[idx] || null;

    window.speechSynthesis.cancel();
    await sleep(150);

    for (let r = 1; r <= repeatCount; r++) {
      if (abortFlag) break;
      log(`▶ 진행: ${r}/${repeatCount}회 (총 ${items.length}문항)`);

      for (let i = 0; i < items.length; i++) {
        if (abortFlag) break;
        const { q, a } = items[i];
        await speakOnce(`${q}번 ${a}`, { rate, pitch, voice }).catch(() => {});
        if (abortFlag) break;
        if (pauseMs > 0) await sleep(pauseMs);
      }
    }

    isRunning = false;
    log(abortFlag ? "■ 정지됨." : "✅ 완료.");
  }

  function loadVoices() {
    voices = (window.speechSynthesis.getVoices() || []);
    elVoice.innerHTML = "";

    voices.forEach((v, i) => {
      const opt = document.createElement('option');
      opt.value = String(i);
      opt.textContent = `${v.name} (${v.lang})${v.default ? " ★" : ""}`;
      elVoice.appendChild(opt);
    });

    const fixed = pickFixedVoice();
    const idx = fixed ? voices.findIndex(v => v.name === fixed.name && v.lang === fixed.lang) : 0;
    elVoice.value = String(Math.max(0, idx));
    elVoice.disabled = true;
  }

  async function requestWakeLock() {
    if (!('wakeLock' in navigator)) return;
    try {
      if (AUTO.wakeLock) return;
      AUTO.wakeLock = await navigator.wakeLock.request('screen');
      AUTO.wakeLock.addEventListener('release', () => {
        AUTO.wakeLock = null;
      });
    } catch (e) {
      console.warn('wakeLock error', e);
    }
  }
  async function releaseWakeLock() {
    try {
      if (AUTO.wakeLock) {
        await AUTO.wakeLock.release();
        AUTO.wakeLock = null;
      }
    } catch (_) {}
  }
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'visible' && AUTO.enabled) {
      requestWakeLock();
    }
  });

  async function ensureCamera() {
    if (cameraStarted) return;
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      setAutoStatus('⚠️ 카메라를 지원하지 않는 브라우저');
      return;
    }
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' }
      });
      video.srcObject = stream;
      cameraStarted = true;
      setAutoStatus('카메라 준비 완료');
    } catch (e) {
      console.error(e);
      setAutoStatus('⚠️ 카메라 허용이 거부됨');
    }
  }

  let firstUserInteractionDone = false;
  function onFirstInteraction() {
    if (firstUserInteractionDone) return;
    firstUserInteractionDone = true;
    ensureCamera();
    startAutoMode();
  }
  document.addEventListener('click', onFirstInteraction, { once: true });
  document.addEventListener('keydown', onFirstInteraction, { once: true });

  async function captureAndOcrOnce(pageNum) {
    try {
      if (!cameraStarted) return null;
      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) return null;

      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(video, 0, 0, w, h);
      const dataUrl = canvas.toDataURL('image/jpeg', 0.9);

      const res = await fetch('/.netlify/functions/ocr', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ image: dataUrl, page: pageNum })
      });
      const json = await res.json();

      const text =
        json.text ||
        (json.data && json.data.text) ||
        (json.ocr && json.ocr.text) ||
        '';

      if (!text) return null;
      return String(text);
    } catch (e) {
      console.error('OCR 오류', e);
      return null;
    }
  }

  // ✅ (수정) solve 결과에서 XURTH 감지하지 않음. 오직 OCR 텍스트에서만 XURTH로 정지.
  async function solveFromOcrText(ocrText) {
    try {
      const res = await fetch('/.netlify/functions/solve', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ text: ocrText })
      });
      const json = await res.json();

      let raw = json.answer || json.output || json.text || '';
      if (!raw) return null;

      raw = String(raw).replace(/QOPHY/g, '').replace(/XURTH/g, '').trim();
      return { answersText: raw };
    } catch (e) {
      console.error('solve 오류', e);
      return null;
    }
  }

  async function stopAutoMode(reason) {
    AUTO.enabled = false;
    AUTO.running = false;
    abortFlag = true;
    if ('speechSynthesis' in window) {
      window.speechSynthesis.cancel();
    }
    await releaseWakeLock();
    if (reason) {
      setAutoStatus(`자동 모드 종료: ${reason}`);
      log(`■ 자동 모드 종료: ${reason}`);
    } else {
      setAutoStatus('자동 모드 종료');
      log('■ 자동 모드 종료');
    }
  }

  async function startAutoMode() {
    if (AUTO.enabled) return;
    AUTO.enabled = true;
    AUTO.page = 1;
    setAutoStatus('자동 모드 ON (QOPHY 찾는 중…)');
    await requestWakeLock();
    autoLoop();
  }

  async function autoLoop() {
    if (AUTO.running) return;
    AUTO.running = true;

    while (AUTO.enabled) {
      await ensureCamera();
      if (!cameraStarted) {
        setAutoStatus('카메라 시작 실패. 5초 후 재시도');
        await sleep(5000);
        continue;
      }

      setAutoStatus(`페이지 ${AUTO.page} OCR 중…`);
      const ocrText = await captureAndOcrOnce(AUTO.page);
      if (!ocrText) {
        setAutoStatus('OCR 실패. 5초 후 재시도');
        await sleep(5000);
        continue;
      }

      // ✅ (핵심) XURTH는 OCR 텍스트에서만 감지해서 완전 정지
      if (ocrText.includes('XURTH')) {
        await stopAutoMode('OCR에서 XURTH 감지');
        break;
      }

      if (!ocrText.includes('QOPHY')) {
        setAutoStatus('QOPHY를 찾는 중…');
        await sleep(3000);
        continue;
      }

      setAutoStatus(`페이지 ${AUTO.page} 풀이 중…`);
      const solveResult = await solveFromOcrText(ocrText);
      if (!solveResult) {
        setAutoStatus('풀이 실패. 5초 후 재시도');
        await sleep(5000);
        continue;
      }

      elAnswers.value = solveResult.answersText || '';
      log(`페이지 ${AUTO.page} 정답:\n` + (solveResult.answersText || ''));
      setAutoStatus(`페이지 ${AUTO.page} 정답 읽는 중…`);

      await runTTS();
      if (!AUTO.enabled) break;

      // 15초 대기 후 "페이지 인식 5..1" (✅ 화면 + 음성)
      setAutoStatus('다음 페이지까지 15초 대기…');
      log('다음 페이지까지 15초 대기…');
      await sleep(15000);

      const vIdx = parseInt(elVoice.value || "0", 10);
      const v = voices[vIdx] || null;

      for (let s = 5; s > 0; s--) {
        if (!AUTO.enabled) break;

        setAutoStatus(`페이지 인식 ${s}`);
        log(`페이지 인식 ${s}`);

        try {
          await speakOnce(`페이지 인식 ${s}`, { rate: FIXED.rate, pitch: FIXED.pitch, voice: v });
        } catch (_) {}

        await sleep(300);
      }

      AUTO.page += 1;
      setAutoStatus(`페이지 ${AUTO.page}로 이동해서 OCR 준비…`);
    }

    AUTO.running = false;
  }

  // 버튼 이벤트(기존 유지)
  playBtn.addEventListener('click', async () => {
    if (!('speechSynthesis' in window)) {
      log("❌ 이 브라우저는 TTS(Web Speech)를 지원하지 않아.");
      return;
    }
    if (isRunning) {
      log("이미 재생 중이야. 정지 후 다시 눌러줘.");
      return;
    }
    await runTTS();
  });

  pauseBtn.addEventListener('click', () => {
    if (!('speechSynthesis' in window)) return;
    const s = window.speechSynthesis;
    if (s.speaking && !s.paused) {
      s.pause();
      log(elLog.textContent + "\n(일시정지)");
    } else if (s.paused) {
      s.resume();
    }
  });

  stopBtn.addEventListener('click', () => {
    abortFlag = true;
    if ('speechSynthesis' in window) window.speechSynthesis.cancel();
  });

  if ('speechSynthesis' in window) {
    loadVoices();
    window.speechSynthesis.onvoiceschanged = loadVoices;
  } else {
    log("❌ 이 브라우저는 TTS(Web Speech)를 지원하지 않아.");
  }
})();
</script>
</body>
</html>

