<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <title>autononsul | Phone OCR</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <style>
    * { box-sizing: border-box; }
    body { margin:0; padding:10px; background:#000; color:#fff; font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif; }
    h3 { margin:8px 0; }
    #topStatus { font-size:13px; color:#c4f1ff; white-space:pre-wrap; }
    #videoBox { position:relative; width:100%; border:1px solid #333; border-radius:10px; overflow:hidden; background:#000; }
    #video { width:100%; height:auto; } /* 표시용 */
    #frame { position:absolute; inset:0; border:2px solid rgba(0,255,0,0.25); pointer-events:none; border-radius:10px; }
    .row { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
    button { padding:10px 12px; font-size:14px; border-radius:10px; border:1px solid #666; background:#111; color:#fff; }
    button:active { transform: scale(0.98); }
    textarea, pre {
      width:100%;
      background:#050505; color:#fff;
      border:1px solid #333; border-radius:10px;
      padding:10px; font-size:12px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }
    pre { min-height:140px; }
    .small { font-size:12px; color:#bbb; }
    .warn { color:#ffd36a; }
    .err { color:#ff7a7a; }
    .ok { color:#8dff9f; }
  </style>
</head>

<body>
  <div id="topStatus">준비 중...</div>

  <div id="videoBox" style="margin-top:10px;">
    <video id="video" autoplay playsinline muted></video>
    <div id="frame"></div>
  </div>

  <div class="row">
    <button id="btnCamera">카메라 시작(필수 탭)</button>
    <button id="btnVoice">음성 연결/테스트(필수 탭)</button>
    <button id="btnSolve">지금까지로 풀이(수동)</button>
    <button id="btnReset">리셋</button>
  </div>

  <h3 style="margin-top:14px;">실시간 OCR(누적)</h3>
  <div class="small">
    OCR은 서버(OCR.Space)에서 처리됨. 무료 키면 너무 빠른 주기에서 막힐 수 있음.
  </div>
  <textarea id="ocrBox" rows="10" placeholder="여기에 누적 텍스트가 쌓임"></textarea>

  <h3>답안</h3>
  <pre id="answerBox"></pre>

<script>
  // ---------- UI ----------
  const topStatus = document.getElementById("topStatus");
  const video = document.getElementById("video");
  const ocrBox = document.getElementById("ocrBox");
  const answerBox = document.getElementById("answerBox");
  const btnCamera = document.getElementById("btnCamera");
  const btnVoice = document.getElementById("btnVoice");
  const btnSolve = document.getElementById("btnSolve");
  const btnReset = document.getElementById("btnReset");

  // ---------- Endpoints ----------
  const OCR_URL = "/.netlify/functions/ocr";
  const SOLVE_URL = "/.netlify/functions/solve";

  // ---------- Settings (안정성 우선) ----------
  let OCR_INTERVAL_MS = 7000;      // 무료키면 2~5초는 막힐 수 있음 → 기본 7초
  const MIN_LEN = 2400;            // 공백제외 누적 길이 기준
  const LACK_START_SEC = 60;       // 1분 이상 진전 없으면 "지문 부족" 표시
  const LACK_TRIGGER_SEC = 8 * 60; // 8분 지나도 기준 미달이면 강제 풀이
  const MAX_SEND_CHARS = 8000;     // solve로 보낼 최대(초과 시 뒤쪽 유지)
  const MIN_APPEND_CORELEN = 6;    // 찌꺼기 제거

  // ---------- State ----------
  let stream = null;
  let ocrTimer = null;
  let ocrBusy = false;
  let solveBusy = false;

  let lines = [];            // 누적 라인
  let seen = new Set();      // 중복 방지
  let lastGoodAt = Date.now();
  let startedAt = 0;
  let voiceReady = false;

  // ---------- TTS ----------
  function speak(text) {
    try {
      if (!text) return;
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "ko-KR";
      u.rate = 1.0;
      u.pitch = 1.0;
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  btnVoice.addEventListener("click", () => {
    voiceReady = true;
    speak("음성 연결 완료.");
    renderStatus("음성: 준비됨", "ok");
  });

  // ---------- Camera ----------
  async function startCamera() {
    const constraints = {
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    startedAt = Date.now();
  }

  function stopCamera() {
    try {
      if (!stream) return;
      stream.getTracks().forEach(t => t.stop());
      stream = null;
    } catch (e) {}
  }

  // ---------- Capture frame -> imageDataUrl (JPEG) ----------
  function captureImageDataUrl() {
    const w = video.videoWidth || 1280;
    const h = video.videoHeight || 720;

    // 중앙 크롭(90%) + 축소(최대 1600폭)
    const cropScale = 0.90;
    const cw = Math.floor(w * cropScale);
    const ch = Math.floor(h * cropScale);
    const cx = Math.floor((w - cw) / 2);
    const cy = Math.floor((h - ch) / 2);

    const maxW = 1600;
    const outScale = Math.min(1, maxW / cw);
    const ow = Math.floor(cw * outScale);
    const oh = Math.floor(ch * outScale);

    const canvas = document.createElement("canvas");
    canvas.width = ow;
    canvas.height = oh;
    const ctx = canvas.getContext("2d");

    try {
      ctx.filter = "contrast(1.25) brightness(1.05)";
    } catch(e) {}

    ctx.drawImage(video, cx, cy, cw, ch, 0, 0, ow, oh);

    // ✅ data:image/jpeg;base64,... 형태로 반환
    return canvas.toDataURL("image/jpeg", 0.72);
  }

  // ---------- Merge OCR text ----------
  function normalizeLine(s) {
    return (s || "")
      .replace(/\u00A0/g, " ")
      .replace(/[ \t]+/g, " ")
      .trim();
  }

  function addLinesFromText(text) {
    const raw = (text || "").split(/\r?\n/).map(normalizeLine).filter(Boolean);

    let added = 0;
    for (const ln of raw) {
      const coreLen = ln.replace(/\s/g, "").length;
      if (coreLen < MIN_APPEND_CORELEN) continue;

      const key = ln.replace(/\s/g,"").slice(0, 22);
      if (seen.has(key)) continue;

      seen.add(key);
      lines.push(ln);
      added++;
    }

    if (added > 0) {
      lastGoodAt = Date.now();
      ocrBox.value = lines.join("\n");
    }
    return added;
  }

  function effectiveLen() {
    return (ocrBox.value || "").replace(/\s/g, "").length;
  }

  function lackSeconds() {
    return Math.floor((Date.now() - lastGoodAt) / 1000);
  }

  function renderStatus(extra, level) {
    const len = effectiveLen();
    const lack = lackSeconds();
    const elapsed = startedAt ? Math.floor((Date.now() - startedAt) / 1000) : 0;

    const lackMsg =
      (len < MIN_LEN && lack >= LACK_START_SEC)
        ? `지문 부족: ${lack}초 (진전 없음)`
        : "지문 부족: -";

    topStatus.textContent =
      "자동 OCR(누적) → 자동 풀이 → TTS\n" +
      "누적 OCR 길이(공백제외): " + len + " / 기준 " + MIN_LEN + "\n" +
      lackMsg + "\n" +
      "경과: " + elapsed + "초\n" +
      "카메라: " + (stream ? "연결됨" : "대기") + " | 음성: " + (voiceReady ? "준비됨" : "대기") + "\n" +
      (extra ? ("메시지: " + extra) : "");
  }

  // ---------- Solve ----------
  async function startSolve(force) {
    if (solveBusy) return;
    solveBusy = true;

    try {
      let text = (ocrBox.value || "").trim();
      if (!text) {
        answerBox.textContent = "OCR 텍스트가 비어있음";
        return;
      }

      if (text.length > MAX_SEND_CHARS) text = text.slice(-MAX_SEND_CHARS);

      const prefix = force ? "지문 부족으로 자동 풀이합니다.\n" : "";
      answerBox.textContent = prefix + "\n답안 생성 중...";

      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify({
          text,
          force: !!force,
          prefix
        })
      });

      const ct = res.headers.get("content-type") || "";
      if (!ct.includes("application/json")) {
        const t = await res.text();
        answerBox.textContent = "solve 응답이 JSON이 아님:\n" + t.slice(0, 300);
        return;
      }

      const data = await res.json();
      if (!data.ok) {
        answerBox.textContent = "solve 실패: " + (data.error || "unknown");
        return;
      }

      answerBox.textContent = data.answer || "";
      if (voiceReady) speak(data.answer || "");
      renderStatus(force ? "solve 완료(강제)" : "solve 완료", "ok");

    } catch (e) {
      answerBox.textContent = "solve 에러: " + (e.message || String(e));
    } finally {
      solveBusy = false;
    }
  }

  // ---------- OCR loop ----------
  async function runOnce() {
    if (ocrBusy || solveBusy) return;
    if (!stream || !video.videoWidth) return;

    ocrBusy = true;
    try {
      const imageDataUrl = captureImageDataUrl();

      const res = await fetch(OCR_URL, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify({ imageDataUrl, language: "kor" })
      });

      const ct = res.headers.get("content-type") || "";
      if (!ct.includes("application/json")) {
        const t = await res.text();
        renderStatus("OCR 응답이 JSON이 아님: " + t.slice(0, 160), "err");
        return;
      }

      const data = await res.json();
      if (!data.ok) {
        // OCR.Space가 막을 때 대비: 간격 조금 늘림
        OCR_INTERVAL_MS = Math.min(15000, OCR_INTERVAL_MS + 2000);
        restartOcrTimer();
        renderStatus("OCR 실패: " + (data.error || "unknown") + ` | 간격 ${OCR_INTERVAL_MS}ms로 증가`, "warn");
        return;
      }

      const text = (data.text || "").trim();
      const added = addLinesFromText(text);

      const len = effectiveLen();
      const lack = lackSeconds();
      renderStatus(added > 0 ? `OCR OK (+${added}라인)` : "OCR OK (추가 없음)", "ok");

      // 자동 풀이 트리거
      if (len >= MIN_LEN) {
        await startSolve(false);
      } else if (lack >= LACK_TRIGGER_SEC) {
        await startSolve(true);
      }

      // 지문 부족 안내(너무 자주 말하지 않게)
      if (!solveBusy && len < MIN_LEN && lack >= LACK_START_SEC && (lack % 30 === 0) && voiceReady) {
        speak("지문이 부족합니다. 종이를 화면에 더 꽉 차게 보여 주세요.");
      }

    } catch (e) {
      renderStatus("OCR 에러: " + (e.message || String(e)), "err");
    } finally {
      ocrBusy = false;
    }
  }

  function restartOcrTimer() {
    if (ocrTimer) clearInterval(ocrTimer);
    ocrTimer = setInterval(runOnce, OCR_INTERVAL_MS);
  }

  function startAutoOCR() {
    if (ocrTimer) return;
    lastGoodAt = Date.now();
    restartOcrTimer();
    runOnce();
  }

  function stopAutoOCR() {
    if (ocrTimer) clearInterval(ocrTimer);
    ocrTimer = null;
  }

  // ---------- Buttons ----------
  btnCamera.addEventListener("click", async () => {
    try {
      await startCamera();
      renderStatus("카메라 시작됨. OCR 자동 실행 중...", "ok");
      startAutoOCR();
    } catch (e) {
      topStatus.textContent = "카메라 실패: " + (e.message || String(e));
    }
  });

  btnSolve.addEventListener("click", () => startSolve(true));

  btnReset.addEventListener("click", () => {
    stopAutoOCR();
    stopCamera();
    lines = [];
    seen.clear();
    ocrBox.value = "";
    answerBox.textContent = "";
    lastGoodAt = Date.now();
    startedAt = 0;
    solveBusy = false;
    ocrBusy = false;
    renderStatus("리셋됨. 카메라 시작을 다시 누르세요.", "warn");
  });

  document.addEventListener("visibilitychange", () => {
    if (document.hidden) stopAutoOCR();
  });

  // ---------- Boot ----------
  renderStatus("카메라 시작(필수 탭)부터 누르세요.", "warn");
</script>
</body>
</html>


