<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Auto OCR â†’ Auto Solve â†’ TTS</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Noto Sans KR, sans-serif; background:#0b0f14; color:#e8eef7; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 14px; }
    .card { background:#111826; border:1px solid #1f2a3a; border-radius:16px; padding:12px; margin-bottom:12px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { padding:12px 14px; border-radius:14px; border:1px solid #2a3b55; background:#172235; color:#e8eef7; font-weight:700; cursor:pointer; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .pill { padding:6px 10px; border-radius:999px; border:1px solid #2a3b55; background:#0f1624; font-size:12px; }
    #status { font-weight:700; line-height:1.35; }
    #log { white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; line-height:1.35; max-height: 240px; overflow:auto; }
    video { width:100%; border-radius:16px; background:#000; }
    img.thumb { width: 100%; border-radius:16px; border:1px solid #22324a; }
    textarea { width:100%; min-height:120px; border-radius:12px; border:1px solid #2a3b55; background:#0f1624; color:#e8eef7; padding:10px; }
    .grid { display:grid; grid-template-columns: 1.3fr .7fr; gap:12px; }
    @media (max-width: 860px){ .grid{ grid-template-columns: 1fr; } }
    .hint { color:#9bb0cc; font-size:12px; line-height:1.35; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div id="status">ëŒ€ê¸° ì¤‘ì´ë‹¤. â€œìë™ ì‹œì‘â€ì„ ëˆ„ë¥´ë©´ ì¹´ë©”ë¼ë¥¼ ì—´ê³  ìë™ OCRì„ ì‹œì‘í•œë‹¤.</div>
      <div class="row" style="margin-top:10px">
        <button id="btnAuto">ğŸ“¸ ìë™ ì‹œì‘</button>
        <button id="btnStop" disabled>â›” ì¤‘ì§€</button>
        <span class="pill" id="pillState">IDLE</span>
        <span class="pill" id="pillPage">PAGE -</span>
        <span class="pill" id="pillShot">SHOT -</span>
      </div>
      <div class="hint" style="margin-top:10px">
        - ë§ˆì§€ë§‰ í˜ì´ì§€ ì—¬ë°±ì— <b>DONE</b>ì„ í¬ê²Œ ì“°ë©´ ì¢…ë£Œ í›„ ìë™ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br/>
        - â€œë°‘ì¤„(underlined)â€ ì •ë³´ëŠ” OCR í…ìŠ¤íŠ¸ë§Œìœ¼ë¡œëŠ” 100% ë³µì›ì´ ë¶ˆê°€ëŠ¥í•˜ë¯€ë¡œ, <b>í’€ì´ ë‹¨ê³„ì—ì„œ í˜ì´ì§€ ì‚¬ì§„(ë¹„ì „ ëª¨ë¸)</b>ì„ ê°™ì´ ì‚¬ìš©í•œë‹¤.<br/>
        - iOS ì‚¬íŒŒë¦¬ëŠ” í™”ë©´ ì ê¸ˆ/ì•± ì „í™˜ ì‹œ ì¹´ë©”ë¼/ìŒì„±ì´ ë©ˆì¶œ ìˆ˜ ìˆë‹¤.
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <video id="video" playsinline autoplay muted></video>
      </div>
      <div class="card">
        <div class="hint" style="margin-bottom:6px">ìµœê·¼ ìº¡ì²˜ ìƒ·</div>
        <img id="lastShot" class="thumb" alt="last shot" />
      </div>
    </div>

    <div class="card">
      <div class="hint" style="margin-bottom:6px">OCR ëˆ„ì  í…ìŠ¤íŠ¸</div>
      <textarea id="ocrBox" placeholder="ìë™ OCR ê²°ê³¼ê°€ ì—¬ê¸°ì— ëˆ„ì ëœë‹¤." readonly></textarea>
    </div>

    <div class="card">
      <div class="hint" style="margin-bottom:6px">ì •ë‹µ(TTSëŠ” ìë™ìœ¼ë¡œ ì½ëŠ”ë‹¤)</div>
      <textarea id="ansBox" placeholder="ìë™ í’€ì´ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œëœë‹¤." readonly></textarea>
    </div>

    <div class="card">
      <div class="hint" style="margin-bottom:6px">ë¡œê·¸</div>
      <div id="log"></div>
    </div>
  </div>

<script>
(() => {
  // ===== ì„¤ì • =====
  const MAX_PAGES = 30;          // DONEì´ ë‚˜ì˜¤ê¸° ì „ê¹Œì§€ ìµœëŒ€ í˜ì´ì§€
  const SHOTS_PER_PAGE = 3;      // í˜ì´ì§€ë‹¹ OCR ì‹œë„ íšŸìˆ˜
  const MAX_RETAKES = 2;         // "ë‹¤ì‹œ ì´¬ì˜" ë£¨í”„ ìµœëŒ€ íšŸìˆ˜(ë„ˆë¬´ ë¹¡ë¹¡í•˜ì§€ ì•Šê²Œ)
  const NEXT_PAGE_DELAY = 10;    // ë‹¤ìŒ í˜ì´ì§€ ë„˜ê¸°ê¸° ëŒ€ê¸°(ì´ˆ)
  const MIN_TEXT_LEN = 40;       // í…ìŠ¤íŠ¸ê°€ ì´ë³´ë‹¤ ë„ˆë¬´ ì§§ìœ¼ë©´ í’ˆì§ˆ ë‚®ë‹¤ê³  íŒë‹¨
  const AF_WAIT_MS = 600;        // ì˜¤í† í¬ì»¤ìŠ¤ ì•ˆì • ëŒ€ê¸°
  const OCR_LANG = "eng";        // ì„±ëŒ€/í™ìµëŒ€ í¸ì…ì˜ì–´ ê¸°ì¤€
  const USE_VISION_SOLVE = true; // ë°‘ì¤„ ë•Œë¬¸ì— ë¹„ì „ í’€ì´ ì‚¬ìš©

  // ===== DOM =====
  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const logEl = $("log");
  const video = $("video");
  const lastShotImg = $("lastShot");
  const ocrBox = $("ocrBox");
  const ansBox = $("ansBox");
  const btnAuto = $("btnAuto");
  const btnStop = $("btnStop");
  const pillState = $("pillState");
  const pillPage = $("pillPage");
  const pillShot = $("pillShot");

  // ===== ìƒíƒœ =====
  let running = false;
  let stream = null;

  // í˜ì´ì§€ë³„ ë°ì´í„°(ì €ì¥ ì•ˆ í•œë‹¤=ì„œë²„/DB ì €ì¥ ì—†ìŒ, ë¸Œë¼ìš°ì € ë©”ëª¨ë¦¬ë§Œ)
  const pages = []; // {page, text, conf, imageDataUrl}

  // ===== ìœ í‹¸ =====
  function nowK() {
    const d = new Date();
    const h = String(d.getHours()).padStart(2,"0");
    const m = String(d.getMinutes()).padStart(2,"0");
    const s = String(d.getSeconds()).padStart(2,"0");
    return `${h}:${m}:${s}`;
  }
  function log(msg) {
    logEl.textContent += `[${nowK()}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setUIState(state, page=null, shot=null) {
    pillState.textContent = state;
    pillPage.textContent = page ? `PAGE ${page}` : `PAGE -`;
    pillShot.textContent = shot ? `SHOT ${shot}` : `SHOT -`;
  }
  function setStatus(text) { statusEl.textContent = text; }

  // ===== TTS(ê°„ë‹¨ ë²„ì „) =====
  async function speak(text, rate=1.0) {
    // iOS ì‚¬íŒŒë¦¬: speakê°€ ê²¹ì¹˜ë©´ ì˜ ì•ˆ ë‚˜ì˜¬ ë•Œê°€ ìˆì–´ì„œ, í•­ìƒ cancel í›„ ì¬ìƒ
    return new Promise((resolve) => {
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "ko-KR";
        u.rate = rate;
        u.pitch = 1.0;
        u.onend = resolve;
        u.onerror = resolve;
        window.speechSynthesis.speak(u);
      } catch (_) {
        resolve();
      }
    });
  }
  async function countdown(seconds) {
    for (let i = seconds; i >= 1; i--) {
      await speak(String(i), 1.0);
      await wait(400);
    }
  }
  const wait = (ms) => new Promise(r => setTimeout(r, ms));

  // ===== ì¹´ë©”ë¼ =====
  async function startCamera() {
    if (stream) return;
    setStatus("ì¹´ë©”ë¼ë¥¼ ì—¬ëŠ” ì¤‘ì´ë‹¤.");
    const constraints = {
      audio: false,
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      }
    };
    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;
    await video.play();
    setStatus("ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œë‹¤. ì‹œí—˜ì§€ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë§ì¶°ë¼.");
  }
  async function stopCamera() {
    try {
      if (video) video.pause();
      if (stream) {
        for (const t of stream.getTracks()) t.stop();
      }
    } catch {}
    stream = null;
  }

  // ===== ìº¡ì²˜ =====
  function captureFrame() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) return "";
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d", { willReadFrequently: false });
    ctx.drawImage(video, 0, 0, w, h);
    // í’ˆì§ˆ ë„ˆë¬´ ë‚®ì¶”ë©´ ê¸€ì”¨ ê¹¨ì§. 0.9~0.95 ì¶”ì²œ
    const dataUrl = canvas.toDataURL("image/jpeg", 0.92);
    return dataUrl;
  }

  // ===== OCR í˜¸ì¶œ =====
  async function callOCR(page, shot, imageDataUrl) {
    // âœ… ì—¬ê¸°ì„œ ë°˜ë“œì‹œ imageBase64 ë¡œ ë³´ë‚¸ë‹¤ (ë„¤ ì˜¤ë¥˜ì˜ í•µì‹¬)
    const payload = {
      pageIndex: page,
      language: OCR_LANG,
      imageBase64: imageDataUrl
    };

    const r = await fetch("/.netlify/functions/ocr", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch {}
    if (!r.ok || !j || !j.ok) {
      const detail = j?.detail ? ` / ${j.detail}` : "";
      throw new Error(`OCR HTTP ${r.status}${detail}`);
    }
    return j; // {ok:true, text, conf}
  }

  function isDoneText(text) {
    if (!text) return false;
    // DONEì„ ëŒ€ë¬¸ìë¡œ í¬ê²Œ ì“´ë‹¤ê³  í–ˆìœ¼ë‹ˆ DONE ìš°ì„ 
    if (/\bDONE\b/.test(text)) return true;
    // í˜¹ì‹œ ëŒ€ë¹„ìš©(ë„¤ê°€ ì›í•˜ë©´)
    if (/ì´¬ì˜\s*ì™„ë£Œ/i.test(text)) return true;
    return false;
  }

  function looksLikeQuestions(text) {
    if (!text) return false;
    // ì˜ì–´ í¸ì…ì‹œí—˜: "1." "2." ... / ë³´ê¸°: (a)(b)... ë˜ëŠ” â‘ â‘¡ ë“±
    if (/\b\d{1,2}\.\s/.test(text)) return true;
    if (/[â‘ â‘¡â‘¢â‘£â‘¤]/.test(text)) return true;
    if (/\([a-eA-E]\)/.test(text)) return true;
    return false;
  }

  // ===== ìë™ OCR ë£¨í”„ =====
  async function runAuto() {
    running = true;
    btnAuto.disabled = true;
    btnStop.disabled = false;
    pages.length = 0;
    ocrBox.value = "";
    ansBox.value = "";
    logEl.textContent = "";

    try {
      await startCamera();
      setUIState("READY");
      log("AUTO START");

      await speak("1ë¶„ ë’¤ì— ìë™ ì˜¤ì”¨ì•Œì„ ì‹œì‘í•œë‹¤.", 1.0);
      await wait(1000);
      // ë„ˆë¬´ ì˜¤ë˜ ê¸°ë‹¤ë¦¬ê¸° ì‹«ìœ¼ë©´ ì—¬ê¸° 10ì´ˆë¡œ ì¤„ì—¬ë„ ë¨
      await speak("10ì´ˆ ë’¤ì— ì‹œì‘í•œë‹¤.", 1.0);
      await countdown(10);

      for (let page = 1; page <= MAX_PAGES && running; page++) {
        setUIState("OCRING", page);
        setStatus(`í˜ì´ì§€ ${page} OCR ì¤‘ì´ë‹¤. ì‹œí—˜ì§€ë¥¼ í”ë“¤ì§€ ë§ê³  ì ê¹ ë©ˆì¶°ë¼.`);
        log(`PAGE ${page} START`);

        let best = { text:"", conf: -1, imageDataUrl:"" };
        let retakes = 0;

        while (retakes <= MAX_RETAKES && running) {
          const results = [];

          for (let shot = 1; shot <= SHOTS_PER_PAGE && running; shot++) {
            setUIState("OCRING", page, shot);
            await wait(AF_WAIT_MS);

            const dataUrl = captureFrame();
            lastShotImg.src = dataUrl;

            if (!dataUrl || !dataUrl.startsWith("data:image")) {
              log(`CAPTURE FAIL page=${page} shot=${shot} (empty dataUrl)`);
              continue;
            }

            try {
              const res = await callOCR(page, shot, dataUrl);
              const txt = (res.text || "").trim();
              const conf = Number(res.conf || 0);
              results.push({ text: txt, conf, imageDataUrl: dataUrl });
              log(`OCR OK page=${page} shot=${shot} conf=${conf} len=${txt.length}`);
            } catch (e) {
              log(`OCR FAIL page=${page} shot=${shot} :: ${e.message}`);
            }
          }

          // best ì„ íƒ: conf ìš°ì„  + ê¸¸ì´ ë³´ì •
          for (const r of results) {
            const score = (r.conf || 0) + Math.min(r.text.length, 800) / 20;
            const bestScore = (best.conf || 0) + Math.min(best.text.length, 800) / 20;
            if (score > bestScore) best = r;
          }

          // DONE ê°ì§€(ì„±ê³µ/ì‹¤íŒ¨ì™€ ë¬´ê´€í•˜ê²Œ bestTextì—ì„œë§Œ íŒì •)
          if (isDoneText(best.text)) {
            log(`DONE DETECTED at page ${page}`);
            pages.push({ page, text: best.text, conf: best.conf, imageDataUrl: best.imageDataUrl });
            ocrBox.value += `\n[PAGE ${page}]\n${best.text}\n`;
            await speak("ì´¬ì˜ì´ ì™„ë£Œë˜ì—ˆë‹¤. ì´ì œ ìë™ìœ¼ë¡œ ë¬¸ì œë¥¼ í‘¼ë‹¤.", 1.0);
            break;
          }

          // í’ˆì§ˆ ë„ˆë¬´ ë‚®ìœ¼ë©´ ì¬ì´¬ì˜ ìš”êµ¬ (ê¸°ì¤€ì€ ë¹¡ë¹¡í•˜ì§€ ì•Šê²Œ)
          if (!best.text || best.text.length < MIN_TEXT_LEN) {
            retakes++;
            if (retakes <= MAX_RETAKES) {
              setStatus(`í˜ì´ì§€ ${page} ì¸ì‹ì´ ì•½í•˜ë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ë¼. (${retakes}/${MAX_RETAKES})`);
              await speak("ì¸ì‹ì´ ì•½í•˜ë‹¤. ê°™ì€ í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•´ë¼.", 1.0);
              continue;
            } else {
              log(`[PAGE ${page}] FORCE-ACCEPT (low text, retakes exceeded)`);
            }
          }

          // ì •ìƒ ê¸°ë¡
          pages.push({ page, text: best.text, conf: best.conf, imageDataUrl: best.imageDataUrl });
          ocrBox.value += `\n[PAGE ${page}]\n${best.text}\n`;

          // ë‹¤ìŒ í˜ì´ì§€ ì•ˆë‚´
          setStatus(`í˜ì´ì§€ ${page} ì¸ì‹ ì™„ë£Œë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ì¤˜ë¼. ${NEXT_PAGE_DELAY}ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ì–´ê°„ë‹¤.`);
          await speak(`ì´ í˜ì´ì§€ ì¸ì‹ì´ ëë‚¬ë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ì¤˜ë¼. ${NEXT_PAGE_DELAY}ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¥¼ ì¸ì‹í•œë‹¤.`, 1.0);
          await countdown(NEXT_PAGE_DELAY);
          break;
        }

        // DONEì´ë©´ for-loop ì¢…ë£Œ
        if (pages.length && isDoneText(pages[pages.length-1].text)) break;
      }

      if (!running) throw new Error("USER_STOP");

      // DONEì„ ëª» ì°¾ì•˜ìœ¼ë©´ ì—¬ê¸°ì„œ ì¢…ë£Œ
      if (!pages.some(p => isDoneText(p.text))) {
        log("FATAL :: DONE not detected within MAX_PAGES");
        setStatus("DONEì„ ì°¾ì§€ ëª»í–ˆë‹¤. ë§ˆì§€ë§‰ í˜ì´ì§€ì— DONEì„ í¬ê²Œ ì“°ê³  ë‹¤ì‹œ ì‹¤í–‰í•´ë¼.");
        await speak("DONEì„ ì°¾ì§€ ëª»í–ˆë‹¤. ë§ˆì§€ë§‰ í˜ì´ì§€ì— DONEì„ í¬ê²Œ ì“°ê³  ë‹¤ì‹œ ì‹¤í–‰í•´ë¼.", 1.0);
        throw new Error("DONE_NOT_FOUND");
      }

      // ===== ìë™ í’€ì´ =====
      await solveAll();

      setUIState("DONE");
      setStatus("ì „ì²´ ê³¼ì •ì´ ëë‚¬ë‹¤.");
      btnStop.disabled = true;
      btnAuto.disabled = false;
      running = false;

    } catch (e) {
      if (String(e.message) === "USER_STOP") {
        setStatus("ì‚¬ìš©ìê°€ ì¤‘ì§€í–ˆë‹¤.");
      } else {
        setStatus(`ì˜¤ë¥˜ë‹¤: ${e.message}`);
      }
      setUIState("ERROR");
      btnStop.disabled = true;
      btnAuto.disabled = false;
      running = false;
    }
  }

  // ===== í’€ì´(í˜ì´ì§€ ë‹¨ìœ„ë¡œ ì‘ê²Œ ìª¼ê°œì„œ íƒ€ì„ì•„ì›ƒ ì¤„ì„) =====
  async function solvePage(p) {
    const payload = {
      page: p.page,
      ocrText: p.text || "",
      imageDataUrl: USE_VISION_SOLVE ? (p.imageDataUrl || "") : ""
    };

    const r = await fetch("/.netlify/functions/solve", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });
    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch {}
    if (!r.ok || !j || !j.ok) {
      const detail = j?.detail ? ` / ${j.detail}` : "";
      throw new Error(`SOLVE HTTP ${r.status}${detail}`);
    }
    return j; // {ok:true, answers:[{q,a}], raw}
  }

  async function solveAll() {
    setUIState("SOLVING");
    setStatus("ìë™ í’€ì´ ì¤‘ì´ë‹¤. (í˜ì´ì§€ ë‹¨ìœ„ë¡œ ë¹ ë¥´ê²Œ ì²˜ë¦¬í•œë‹¤)");
    log("SOLVE START");

    const answers = new Map(); // q -> a

    for (const p of pages) {
      if (!looksLikeQuestions(p.text)) {
        log(`SOLVE SKIP page=${p.page} (no question patterns)`);
        continue;
      }

      setStatus(`í˜ì´ì§€ ${p.page} í’€ì´ ì¤‘ì´ë‹¤.`);
      log(`SOLVE page=${p.page} START`);

      // íƒ€ì„ì•„ì›ƒ/ì‹¤íŒ¨ ëŒ€ë¹„: 2íšŒ ì¬ì‹œë„
      let ok = false;
      for (let attempt = 1; attempt <= 2; attempt++) {
        try {
          const res = await solvePage(p);
          const arr = Array.isArray(res.answers) ? res.answers : [];
          for (const it of arr) {
            if (it && Number.isFinite(it.q) && Number.isFinite(it.a)) {
              answers.set(Number(it.q), Number(it.a));
            }
          }
          log(`SOLVE page=${p.page} OK answers=${arr.length}`);
          ok = true;
          break;
        } catch (e) {
          log(`SOLVE page=${p.page} FAIL attempt=${attempt} :: ${e.message}`);
          if (attempt === 2) {
            await speak(`í˜ì´ì§€ ${p.page} í’€ì´ì— ì‹¤íŒ¨í–ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ë¼.`, 1.0);
          } else {
            await wait(400);
          }
        }
      }
      if (!ok) break;
    }

    // ì •ë‹µ ì¶œë ¥
    const list = [...answers.entries()].sort((a,b)=>a[0]-b[0]).map(([q,a]) => `${q}ë²ˆ ${a}ë²ˆ`).join("\n");
    ansBox.value = list || "ì •ë‹µì„ ì¶”ì¶œí•˜ì§€ ëª»í–ˆë‹¤.";

    if (list) {
      // TTS: â€œ1ë²ˆ 3ë²ˆ, 2ë²ˆ 5ë²ˆ â€¦â€
      const speech = [...answers.entries()]
        .sort((a,b)=>a[0]-b[0])
        .map(([q,a]) => `${q}ë²ˆ ${a}ë²ˆ`)
        .join(", ");
      await speak("ì •ë‹µì„ ë§í•œë‹¤.", 1.0);
      await speak(speech, 0.95);
    } else {
      await speak("ì •ë‹µì„ ë§Œë“¤ì§€ ëª»í–ˆë‹¤.", 1.0);
    }

    log("SOLVE END");
  }

  // ===== ë²„íŠ¼ =====
  btnAuto.addEventListener("click", () => runAuto());
  btnStop.addEventListener("click", async () => {
    running = false;
    btnStop.disabled = true;
    btnAuto.disabled = false;
    setUIState("STOPPED");
    setStatus("ì¤‘ì§€ ì¤‘ì´ë‹¤.");
    await stopCamera();
  });

  // iOS ì•ˆì •í™”(í˜ì´ì§€ ìˆ¨ê¹€ ì‹œ ì¹´ë©”ë¼ ë©ˆì¶œ ìˆ˜ ìˆìŒ)
  document.addEventListener("visibilitychange", () => {
    if (document.hidden && running) {
      log("VISIBILITY hidden (iOS may pause camera/audio)");
    }
  });
})();
</script>
</body>
</html>

