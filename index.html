<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>answer-site v3 â€” Screen OCR â†’ Solver â†’ TTS</title>
  <style>
    :root { --bg:#0b0f17; --card:#111827; --ink:#e5e7eb; --muted:#94a3b8; --accent:#22d3ee; }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,Segoe UI,Apple SD Gothic Neo,sans-serif;background:var(--bg);color:var(--ink)}
    header{padding:16px 20px;border-bottom:1px solid #1f2937;display:flex;gap:12px;align-items:center}
    h1{margin:0;font-size:18px;font-weight:700}
    main{display:grid;grid-template-columns:1.2fr 1fr;gap:16px;padding:16px}
    section{background:var(--card);border:1px solid #1f2937;border-radius:16px;padding:14px}
    .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
    button,select,input,textarea{
      background:#0f172a;border:1px solid #374151;color:var(--ink);
      border-radius:12px;padding:10px 12px;font-size:14px
    }
    button.accent{border-color:#164e63;background:#042f2e}
    button:disabled{opacity:.5}
    video,canvas{width:100%;max-height:48vh;background:#000;border-radius:12px}
    textarea{width:100%;min-height:120px;resize:vertical}
    .pill{font-size:12px;color:var(--muted)}
    label{font-size:12px;color:var(--muted)}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px}
    summary{cursor:pointer}
    .badge{display:inline-flex;align-items:center;gap:6px;padding:4px 8px;border-radius:999px;background:#0f172a;border:1px solid #334155;font-size:12px;color:#cbd5e1}
  </style>
</head>
<body>
  <header>
    <h1>answer-site v3</h1>
    <span class="pill">ìº¡ì²˜ â†’ OCR(í•œÂ·ì˜) â†’ ë¬¸í•­ ë¶„ë¦¬ â†’ ì§€ë¬¸ ê²°í•© â†’ í’€ì´ â†’ â€œì •ë‹µë§Œâ€ ìŒì„±</span>
  </header>

  <main>
    <section id="cap">
      <div class="row" style="justify-content:space-between">
        <div class="row">
          <button id="btnStart" class="accent">â‘  í™”ë©´ ì„ íƒÂ·ìº¡ì²˜ ì‹œì‘</button>
          <button id="btnStop">ì¤‘ì§€</button>
          <label><input type="checkbox" id="autoOCR" checked> ìë™ OCR (2ì´ˆ)</label>
          <label><input type="checkbox" id="autoSolve" checked> ìë™ í’€ì´ & ìŒì„±</label>
        </div>
        <div class="row">
          <span id="passageBadge" class="badge">ì§€ë¬¸ë²„í¼: OFF (0 lines)</span>
          <label><input type="checkbox" id="mute"> ìŒì†Œê±°</label>
          <button id="btnTest">ğŸ”Š ì´ì–´í”¼ìŠ¤ í…ŒìŠ¤íŠ¸</button>
        </div>
      </div>

      <p class="pill">ì „ìš© ì¹´ë©”ë¼ â€œì•± ì°½(ë˜ëŠ” ì „ì²´í™”ë©´)â€ì„ ì„ íƒí•´ ê·¸ í™”ë©´ì˜ í…ìŠ¤íŠ¸ë§Œ ì¸ì‹í•©ë‹ˆë‹¤.</p>

      <video id="vid" autoplay playsinline muted></video>
      <canvas id="cvs" hidden></canvas>

      <!-- ì „ì²˜ë¦¬Â·ë¶„ë¦¬ ì»¨íŠ¸ë¡¤ -->
      <div class="row" style="margin:8px 0 0">
        <label>ì„ ëª…ë„ ì„ê³„ê°’
          <input id="sharp" type="range" min="20" max="300" value="120" step="5" style="width:180px">
        </label>
        <label><input id="bilingual" type="checkbox" checked> í•œì˜ ë™ì‹œ OCR(eng+kor)</label>
        <label><input id="preproc" type="checkbox" checked> ê³ ëŒ€ë¹„ ì „ì²˜ë¦¬</label>
        <label>ì´ì§„í™” ì„ê³„ê°’
          <input id="thresh" type="range" min="100" max="220" value="180" step="5" style="width:160px">
        </label>
      </div>

      <div class="grid" style="margin-top:8px">
        <div>
          <h3 style="margin:10px 0 6px">ìµœê·¼ OCR ê²°ê³¼</h3>
          <textarea id="ocrOut" class="mono" placeholder="ì¸ì‹ëœ ì›ë¬¸ í…ìŠ¤íŠ¸"></textarea>
          <div class="row">
            <button id="btnOnce">ì§€ê¸ˆ OCR 1íšŒ</button>
            <button id="btnClear">ì§€ì›€</button>
          </div>
        </div>
        <div>
          <h3 style="margin:10px 0 6px">ì •ë‹µ</h3>
          <textarea id="ansOut" class="mono" placeholder="ì •ë‹µë§Œ í‘œì‹œÂ·ìŒì„± ì¶œë ¥"></textarea>
          <div class="row">
            <button id="btnSolve">ë¬¸ì œ í’€ê¸°</button>
            <button id="btnSpeak">ì •ë‹µ ë‹¤ì‹œ ì½ê¸°</button>
          </div>
          <div class="row" style="margin-top:8px">
            <label>ê°ì§€ëœ ë¬¸í•­
              <select id="qList" style="min-width:260px"></select>
            </label>
            <button id="btnSolveSelected">ì„ íƒ ë¬¸í•­ í’€ê¸°</button>
          </div>
        </div>
      </div>

      <details style="margin-top:10px">
        <summary>ë¡œê·¸</summary>
        <pre id="log" class="mono"></pre>
      </details>
    </section>

    <section>
      <h3 style="margin-top:0">ì„¸íŒ… ìš”ì•½</h3>
      <ol>
        <li>ì „ìš© ì¹´ë©”ë¼ ì•±ì—ì„œ ì‹œí—˜ì§€ë¥¼ í¬ê²ŒÂ·ì„ ëª…í•˜ê²Œ í‘œì‹œ(ì¤Œ/ì´ˆì  ê³ ì •, ë°ê¸°/ëŒ€ë¹„â†‘).</li>
        <li>ì´ í˜ì´ì§€ì—ì„œ <b>â‘  í™”ë©´ ì„ íƒÂ·ìº¡ì²˜ ì‹œì‘</b> â†’ í•´ë‹¹ ì•± ì°½ ì„ íƒ.</li>
        <li>ìë™ OCR/í’€ì´ê°€ ì¼œì ¸ ìˆìœ¼ë©´ 2ì´ˆë§ˆë‹¤ ì¸ì‹â†’ë¬¸í•­ ë¶„ë¦¬â†’ì§€ë¬¸ ê²°í•©â†’ì •ë‹µ ìŒì„±.</li>
        <li>ì´ì–´í”¼ìŠ¤ë¥¼ ê¸°ê¸° ì˜¤ë””ì˜¤ì— ì—°ê²° í›„ <b>ğŸ”Š ì´ì–´í”¼ìŠ¤ í…ŒìŠ¤íŠ¸</b>ë¡œ ë³¼ë¥¨ í™•ì¸.</li>
      </ol>
      <p class="pill">â€» ì§€ë¬¸ì´ ì•/ë’·ì¥ìœ¼ë¡œ ë‚˜ë‰˜ì–´ë„ ì§€ë¬¸ë²„í¼ì— ëˆ„ì  í›„ ë¬¸í•­ê³¼ ìë™ ê²°í•©í•¨.</p>
    </section>
  </main>

  <!-- Tesseract.js -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
  <script>
    const $ = (id) => document.getElementById(id);
    const log = (m) => { const el=$('log'); el.textContent += `[${new Date().toLocaleTimeString()}] ${m}\n`; el.scrollTop = el.scrollHeight; };

    // ======= ì „ì—­ ìƒíƒœ =======
    let stream = null, ocrTimer = null;
    let lastHash = null, lastAnswer = null;

    // ì§€ë¬¸ ë²„í¼(ë©€í‹° í”„ë ˆì„ ëˆ„ì : ì•/ë’·ì¥ì— ê±¸ì¹œ ê¸´ ì§€ë¬¸)
    let passage = { active:false, lines:[], lastSeenTs:0 };

    // ë¬¸í•­ ì„¸íŠ¸(ì—°ì† ë²ˆí˜¸ 2~3ê°œ ì´ìƒ) ê°ì§€
    let qSet = { active:false, start:null, end:null, items:[] };

    // ìë™ í’€ì´ í
    const solveQueue = [];
    let solving = false;

    // ======= ìº¡ì²˜ ì œì–´ =======
    async function startCapture(){
      try{
        stream = await navigator.mediaDevices.getDisplayMedia({ video:{ frameRate:15 }, audio:false });
        $('vid').srcObject = stream;
        if($('autoOCR').checked) startAutoOCR();
        log('í™”ë©´ ìº¡ì²˜ ì‹œì‘');
      }catch(e){ log('ìº¡ì²˜ ê±°ë¶€/ì˜¤ë¥˜: '+e.message); }
    }
    function stopCapture(){
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream = null; }
      stopAutoOCR(); $('vid').srcObject = null; log('ìº¡ì²˜ ì¤‘ì§€');
    }
    function startAutoOCR(){ if(ocrTimer) return; ocrTimer = setInterval(runOCR, 2000); log('ìë™ OCR ì‹œì‘(2ì´ˆ)'); }
    function stopAutoOCR(){ if(ocrTimer){ clearInterval(ocrTimer); ocrTimer=null; log('ìë™ OCR ì¤‘ì§€'); } }

    // ======= OCR íŒŒì´í”„ë¼ì¸ =======
    async function runOCR(){
      if(!stream) return;
      const vid = $('vid'); const cvs = $('cvs');
      const vw = vid.videoWidth, vh = vid.videoHeight; if(!vw||!vh) return;

      const scale = 0.9;
      cvs.width = Math.floor(vw*scale); cvs.height = Math.floor(vh*scale);
      const ctx = cvs.getContext('2d');
      ctx.drawImage(vid, 0, 0, cvs.width, cvs.height);

      // ì „ì²˜ë¦¬(ì„ íƒ): ê³ ëŒ€ë¹„ + ì´ì§„í™”
      if ($('preproc').checked){
        const img = ctx.getImageData(0,0,cvs.width,cvs.height);
        const d = img.data; const T = parseInt($('thresh').value||'180',10);
        for(let i=0;i<d.length;i+=4){
          let g = 0.299*d[i] + 0.587*d[i+1] + 0.114*d[i+2];
          g = Math.pow(g/255, 0.8)*255; // ì•½í•œ ê°ë§ˆ
          const b = g > T ? 255 : 0;
          d[i]=d[i+1]=d[i+2]=b; d[i+3]=255;
        }
        ctx.putImageData(img,0,0);
      }

      // ì„ ëª…ë„(ë¼í”Œë¼ì‹œì•ˆ ë¶„ì‚°) â†’ íë¦¬ë©´ ìŠ¤í‚µ
      const sharpness = varianceOfLaplacian(cvs);
      const threshold = parseInt($('sharp').value || '120', 10);
      if (sharpness < threshold){ log(`íë¦¼ ê°ì§€(${sharpness.toFixed(0)}) â†’ OCR ìŠ¤í‚µ`); return; }

      const blob = await new Promise(res=>cvs.toBlob(res,'image/png',0.9));
      try{
        const lang = $('bilingual').checked ? 'eng+kor' : 'eng';
        const { data:{ text } } = await Tesseract.recognize(blob, lang, {
          tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-Ã—Ã·=().,%:;<>[]{}\\/'
        });
        const cleaned = cleanupText(text);
        if(!cleaned) return;

        // ì§€ë¬¸ í›„ë³´ í¡ìˆ˜ & ë§Œë£Œ ê´€ë¦¬
        if(looksLikePassageStart(cleaned)) absorbPassage(cleaned);
        gcPassage(); updatePassageBadge();

        // ë¬¸í•­ ë¸”ë¡ íŒŒì‹± + ì„¸íŠ¸ ê°ì§€
        const blocks = parseQuestions(cleaned);
        detectQuestionSet(blocks);
        updateQuestionList(blocks);

        // ë™ì¼ í…ìŠ¤íŠ¸ í•´ì‹œ â†’ ì¤‘ë³µ ìŠ¤í‚µ
        const h = djb2(cleaned);
        if (h === lastHash){ log('ë™ì¼ í”„ë ˆì„ í…ìŠ¤íŠ¸ â†’ í’€ì´ ìŠ¤í‚µ'); return; }
        lastHash = h;

        $('ocrOut').value = cleaned;
        log('OCR OK ('+ cleaned.slice(0,80).replace(/\n/g,' ') + '...)');

        // ìë™ í’€ì´: ë¬¸í•­ ë‹¨ìœ„ë¡œ íì‰(ì„¸íŠ¸ë©´ ê° ë¬¸í•­)
        if($('autoSolve').checked){
          if(blocks.length){
            for(const b of blocks){ queueSolveTask(b.text); }
          }
        }
      }catch(e){ log('OCR ì˜¤ë¥˜: '+e.message); }
    }

    // ======= í…ìŠ¤íŠ¸ ì „ì²˜ë¦¬/ìœ í‹¸ =======
    function cleanupText(t){
      return t.replace(/[\u200B-\u200D\uFEFF]/g,'')   // zero-width
              .replace(/\r/g,'')
              .replace(/\n{3,}/g,'\n\n')
              .replace(/[ \t]{2,}/g,' ')
              .trim();
    }
    function djb2(str){ let h=5381; for(let i=0;i<str.length;i++){ h=((h<<5)+h) ^ str.charCodeAt(i); } return h>>>0; }
    function varianceOfLaplacian(cvs){
      const ctx = cvs.getContext('2d');
      const {width:w,height:h} = cvs;
      const { data } = ctx.getImageData(0,0,w,h);
      const gray = new Float32Array(w*h);
      for(let i=0,j=0;i<data.length;i+=4,j++){
        gray[j] = 0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2];
      }
      const k = [-1,-1,-1,-1,8,-1,-1,-1,-1];
      let sum=0, sumSq=0, count=0;
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          const idx=y*w+x;
          const v = k[0]*gray[idx-w-1] + k[1]*gray[idx-w] + k[2]*gray[idx-w+1]
                  + k[3]*gray[idx-1]   + k[4]*gray[idx]   + k[5]*gray[idx+1]
                  + k[6]*gray[idx+w-1] + k[7]*gray[idx+w] + k[8]*gray[idx+w+1];
          sum += v; sumSq += v*v; count++;
        }
      }
      const mean = sum / Math.max(1,count);
      const varc = (sumSq/Math.max(1,count)) - mean*mean;
      return Math.max(0,varc);
    }

    // ======= ì§€ë¬¸ ëˆ„ì (ë©€í‹° í”„ë ˆì„) =======
    function looksLikePassageStart(t){
      // 'ì§€ë¬¸/ìœ—ê¸€/ë‹¤ìŒ ê¸€' ë˜ëŠ” ë²ˆí˜¸ì—†ëŠ” í° ë‹¨ë½
      return /ì§€ë¬¸|ìœ—ê¸€|ë‹¤ìŒ ê¸€|ë‹¤ìŒì˜ ê¸€|ìœ„ì˜ ê¸€/i.test(t) || (t.length>200 && !QPAT.test((t.split('\n')[0]||'')));
    }
    function splitLines(t){ return t.split(/\n+/).map(s=>s.trim()).filter(Boolean); }
    function absorbPassage(text){
      const lines = splitLines(text);
      for(const ln of lines){
        if(QPAT.test(ln)) continue;            // ë¬¸í•­ ì¤„ ì œì™¸
        if(ln.length<2) continue;
        // ê°„ë‹¨ ìŠ¤í‹°ì¹­(ë¬¸ì¥ ë§ë¯¸ì™€ ë‹¤ìŒ ë¬¸ì¥ ë¨¸ë¦¬ ìœ ì‚¬)
        if(passage.lines.length){
          const last = passage.lines[passage.lines.length-1];
          if(/[ê°€-í£A-Za-z0-9,)]$/.test(last) && /^[a-zê°€-í£(]/i.test(ln)){
            if(similar(last.slice(-25), ln.slice(0,25))>0.85){
              passage.lines[passage.lines.length-1] = last + ' ' + ln;
              continue;
            }
          }
        }
        passage.lines.push(ln);
      }
      passage.active = true;
      passage.lastSeenTs = Date.now();
    }
    function similar(a,b){
      const s = new Set(a.split('')); let hit=0;
      for(const ch of b.split('')) if(s.has(ch)) hit++;
      return hit/Math.max(1,Math.min(a.length,b.length));
    }
    function gcPassage(){
      if(passage.active && Date.now()-passage.lastSeenTs>30000){
        passage = { active:false, lines:[], lastSeenTs:0 };
      }
    }
    function updatePassageBadge(){
      const el = $('passageBadge');
      el.textContent = `ì§€ë¬¸ë²„í¼: ${passage.active?'ON':'OFF'} (${passage.lines.length} lines)`;
    }

    // ======= ë¬¸í•­ íŒŒì‹± & ì„¸íŠ¸ =======
    // ë²ˆí˜¸ íŒ¨í„´: 1. / (1) / â‘  / (ê°€) / A. / I. / (IV) ...
    const QPAT = /^(?:\(?\d{1,3}\)?\.|\(?\d{1,3}\)?|[â‘ -â‘³]|[A-H]\.\s|[IVX]+\.\s|\([ê°€-í•˜IVX]+\))\s*/;

    function parseQuestions(text){
      const lines = splitLines(text);
      const blocks = [];
      let cur=null, num=null;
      for(const ln of lines){
        if(QPAT.test(ln)){
          if(cur) blocks.push({ num, text: cur.join('\n') });
          const m = ln.match(QPAT);
          num = (m? m[0].replace(/[^0-9A-Za-zê°€-í£â‘ -â‘³IVX]/g,'').slice(0,8):'');
          cur = [ ln.replace(QPAT,'').trim() ];
        }else{
          if(!cur){ cur=[ln]; num=''; } else cur.push(ln);
        }
      }
      if(cur) blocks.push({ num, text: cur.join('\n') });
      return blocks;
    }
    function detectQuestionSet(blocks){
      const nums = blocks.map(b=>parseInt((b.num||'').replace(/[^0-9]/g,''),10)).filter(n=>!isNaN(n));
      if(nums.length>=2){
        nums.sort((a,b)=>a-b);
        let run=1, best=[nums[0],nums[0]];
        for(let i=1;i<nums.length;i++){
          if(nums[i]===nums[i-1]+1){ run++; best[1]=nums[i]; }
          else { if(run>=2) break; run=1; best=[nums[i],nums[i]]; }
        }
        if(run>=2){ qSet = { active:true, start:best[0], end:best[1], items:[] }; return; }
      }
      qSet = { active:false, start:null, end:null, items:[] };
    }

    // ======= UI: ë¬¸í•­ ëª©ë¡ =======
    function updateQuestionList(blocks){
      const sel = $('qList');
      sel.innerHTML = '';
      if(!blocks.length){
        const o=document.createElement('option'); o.text='(ë¬¸í•­ ë¯¸ê°ì§€)';
        sel.appendChild(o); return;
      }
      blocks.forEach((b,i)=>{
        const o=document.createElement('option');
        const prev = (b.text||'').slice(0,28).replace(/\s+/g,' ');
        o.value = i; o.text = `${b.num||i+1}. ${prev}`;
        sel.appendChild(o);
      });
    }
    function getSelectedQuestionText(){
      const sel = $('qList');
      const idx = sel.selectedIndex;
      if(idx<0) return '';
      const options = Array.from(sel.options);
      if(!options.length) return '';
      // í˜„ì¬ í‘œì‹œëœ OCR í…ìŠ¤íŠ¸ì—ì„œ ë‹¤ì‹œ íŒŒì‹±í•´ ì•ˆì „ íšë“
      const blocks = parseQuestions($('ocrOut').value||'');
      return blocks[idx]?.text || '';
    }

    // ======= í’€ì´ í & í˜¸ì¶œ =======
    function queueSolveTask(qText){
      let prompt = qText;
      const refPassage = passage.lines.join('\n');
      if( (/ìœ—ê¸€|ì§€ë¬¸|ì•ì˜ ê¸€|ìœ„ì˜ ê¸€|ë‹¤ìŒ ê¸€/.test(qText) || qSet.active) && refPassage ){
        prompt = `ì§€ë¬¸:\n${refPassage}\n\në¬¸í•­:\n${qText}`;
      }
      solveQueue.push(prompt);
    }

    async function pumpSolveQueue(){
      if(solving || !solveQueue.length) return;
      solving = true;
      const q = solveQueue.shift();
      try{
        const resp = await fetch('/.netlify/functions/solve', {
          method:'POST', headers:{'Content-Type':'application/json'},
          body: JSON.stringify({ question: q })
        });
        if(!resp.ok) throw new Error('HTTP '+resp.status);
        const data = await resp.json();
        const ans = (data.answer||'').trim();
        if(ans){
          if(ans !== lastAnswer){
            $('ansOut').value = ans; log('ì •ë‹µ: '+ans); speak(ans); lastAnswer = ans;
          } else {
            log('ê°™ì€ ì •ë‹µ â†’ ì¬ìƒ ìƒëµ');
          }
        } else { log('ì •ë‹µ ì—†ìŒ/ë¹ˆ ì‘ë‹µ'); }
      }catch(e){ log('í’€ì´ ì‹¤íŒ¨: '+e.message); }
      finally { solving=false; if(solveQueue.length) setTimeout(pumpSolveQueue, 150); }
    }
    setInterval(pumpSolveQueue, 400);

    // ======= ìˆ˜ë™/ë²„íŠ¼ =======
    async function solveNow(){
      // ìš°ì„ ìˆœìœ„: ì„ íƒ ë¬¸í•­ â†’ ì²« ë¬¸í•­ â†’ ì „ì²´ í…ìŠ¤íŠ¸
      const sel = getSelectedQuestionText();
      let coreQ = sel || (parseQuestions($('ocrOut').value||'')[0]?.text || $('ocrOut').value || '');
      if(!coreQ.trim()) return;
      queueSolveTask(coreQ);
    }

    function speak(text){
      if($('mute').checked) return;
      try{
        const u = new SpeechSynthesisUtterance(text);
        const hasKorean = /[\u3131-\uD79D]/.test(text);
        u.lang = hasKorean ? 'ko-KR' : 'en-US';
        u.rate = 1.0; u.pitch = 1.0; u.volume = 1.0;
        speechSynthesis.cancel(); speechSynthesis.speak(u);
      }catch(e){ log('TTS ì˜¤ë¥˜: '+e.message); }
    }

    // ======= ì´ë²¤íŠ¸ ë°”ì¸ë”© =======
    $('btnStart').onclick = startCapture;
    $('btnStop').onclick  = stopCapture;
    $('btnOnce').onclick  = runOCR;
    $('btnSolve').onclick = solveNow;
    $('btnClear').onclick = ()=>{ $('ocrOut').value=''; $('ansOut').value=''; lastAnswer=null; };
    $('btnSpeak').onclick = ()=>{ const t=$('ansOut').value.trim(); if(t) speak(t); };
    $('btnTest').onclick  = ()=> speak('í…ŒìŠ¤íŠ¸, ë“¤ë¦¬ë©´ ê³ ê°œë¥¼ ë„ë•ì´ì„¸ìš”');
  </script>
</body>
</html>
