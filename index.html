<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>í¸ì…ì˜ì–´ ìë™ OCR â†’ ìë™ í’€ì´ â†’ TTS</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple SD Gothic Neo","Noto Sans KR", sans-serif;
      margin: 0; padding: 14px; background:#0b0d12; color:#e9eef8; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { padding: 12px 14px; border-radius: 12px; border: 0; background: #2b6cff; color: #fff; font-weight: 900; }
    button.secondary { background:#2a2f3b; }
    button.danger { background:#ff3b3b; }
    button:disabled { opacity:0.5; }
    #status { margin-top:12px; padding:12px; border-radius: 12px; background:#121622; line-height:1.5; white-space:pre-wrap; }
    video { margin-top:10px; width:100%; max-height:55vh; border-radius:14px; background:#000; }
    .small { margin-top:10px; opacity:0.9; font-size:13px; line-height:1.55; }
    .pill { display:inline-block; padding:4px 10px; border-radius:999px; background:#1b2234; font-size:12px; font-weight:800; }
    textarea { margin-top:10px; width:100%; min-height:260px; border-radius:12px; border:1px solid #2a2f3b;
      background:#0f1320; color:#dfe7ff; padding:10px; box-sizing:border-box; }
    .warn { color:#ffda6b; font-weight:900; }
    .ok { color:#67ff9a; font-weight:900; }
    .bad { color:#ff7d7d; font-weight:900; }
  </style>
</head>
<body>
  <div class="row">
    <button id="btnStart">ğŸ“¸ ìë™ OCR ì‹œì‘</button>
    <button id="btnStop" class="danger" disabled>â›” ì •ì§€</button>
    <button id="btnVoice" class="secondary">ğŸ”Š ìŒì„± í…ŒìŠ¤íŠ¸</button>
  </div>

  <div id="status">ëŒ€ê¸° ì¤‘ì´ë‹¤. â€˜ìë™ OCR ì‹œì‘â€™ì„ ëˆ„ë¥´ë©´ ì¹´ë©”ë¼ë¥¼ ì—´ê³  ìë™ìœ¼ë¡œ OCRâ†’í’€ì´â†’ì •ë‹µ ë‚­ë…ê¹Œì§€ ì§„í–‰í•œë‹¤.</div>

  <div class="small">
    - ë§ˆì§€ë§‰ í˜ì´ì§€ ì—¬ë°±ì— <b>DONE</b>ì„ í¬ê²Œ ì“°ë©´ OCRì„ ë©ˆì¶”ê³  ìë™ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br>
    - â€œë¶ˆì•ˆì • ì¬ì´¬ì˜â€ì€ <b>ëª‡ ë²ˆê¹Œì§€ë§Œ</b> í•˜ê³ , ê³„ì† ì‹¤íŒ¨í•˜ë©´ <b>ì¼ë‹¨ ì €ì¥í•˜ê³  ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ì–´ê°„ë‹¤</b>(ìë™í™” ë©ˆì¶¤ ë°©ì§€).<br>
    - ë°‘ì¤„(underline)ì€ OCRë§Œìœ¼ë¡œ 100% ë¶ˆê°€ë‹¤. <b>ë°‘ì¤„ ë¬¸ì œë§Œ</b> ë¹„ì „ ëª¨ë¸ë¡œ â€œë°‘ì¤„ ë¶€ë¶„ í…ìŠ¤íŠ¸â€ë¥¼ ë³´ì¡° ì¶”ì¶œí•œë‹¤(ì‹¤íŒ¨í•˜ë©´ ë°‘ì¤„ ì—†ì´ í’€ì´ ê³„ì† ì§„í–‰).<br>
    - <span class="warn">iOS ì‚¬íŒŒë¦¬ëŠ” í™”ë©´ ì ê¸ˆ/ì•± ì „í™˜ ì‹œ ì¹´ë©”ë¼/ìŒì„±ì´ ë©ˆì¶œ ìˆ˜ ìˆë‹¤.</span>
  </div>

  <video id="video" autoplay playsinline muted></video>

  <div class="small">
    í˜ì´ì§€: <span class="pill" id="pillPage">-</span>
    ë‹¨ê³„: <span class="pill" id="pillPhase">IDLE</span>
    ì‹œë„: <span class="pill" id="pillTry">-</span>
    ìƒ·: <span class="pill" id="pillShot">-</span>
  </div>

  <textarea id="debug" spellcheck="false" placeholder="ë””ë²„ê·¸(ìë™ìœ¼ë¡œ ì±„ì›Œì§„ë‹¤)"></textarea>

<script>
(() => {
  "use strict";

  // ===================== ì„¤ì • =====================
  const MAX_PAGES = 80;

  // í•œ í˜ì´ì§€ë‹¹ OCR ìƒ· ìˆ˜(ì´ˆë°˜ 3, ì˜ ì•ˆ ë˜ë©´ 5ê¹Œì§€)
  const SHOTS_BASE = 3;
  const SHOTS_MAX  = 5;

  // í˜ì´ì§€ ë„˜ê¹€ ì‹œê°„
  const BETWEEN_PAGE_SEC = 10;
  const RETRY_SEC = 5;

  // OpenRouter solve í•œ ë²ˆì— ëª‡ ë¬¸í•­ ë¬¶ì„ì§€(ì‘ê²Œ ì¡ì•„ íƒ€ì„ì•„ì›ƒ/ì˜¤ë‹µ ê°ì†Œ)
  const SOLVE_CHUNK = 6;

  // TTS
  const TTS_LANG = "ko-KR";
  const TTS_RATE = 0.95;

  // OCR í’ˆì§ˆ ê¸°ì¤€(ë„ˆë¬´ ë¹¡ë¹¡í•˜ë©´ ëì—†ì´ ì¬ì´¬ì˜)
  const MIN_LEN_ACCEPT = 30;
  const MIN_LEN_GOOD   = 140;

  // ì—„ê²© ì¬ì´¬ì˜ ëª‡ ë²ˆê¹Œì§€ë§Œ í•˜ê³ , ì´í›„ì—” ê°•ì œ ì „ì§„
  const RETRY_BEFORE_FORCE_ACCEPT = 2;
  const MAX_RETRY_SAME_PAGE = 14;

  // ì´¬ì˜ ì§ì „ í¬ì»¤ìŠ¤ ì•ˆì • ì‹œê°„
  const PRE_SHOT_SETTLE_MS = 650;

  // ===================== ìƒíƒœ =====================
  let stream = null;
  let running = false;
  let phase = "IDLE";
  let pageIndex = 1;
  let triesSamePage = 0;
  let shotsThisPage = SHOTS_BASE;

  const pageTexts = [];
  const pageScores = [];

  // ===================== DOM =====================
  const $ = (id) => document.getElementById(id);
  const video = $("video");
  const statusEl = $("status");
  const debugEl = $("debug");
  const pillPage = $("pillPage");
  const pillPhase = $("pillPhase");
  const pillTry = $("pillTry");
  const pillShot = $("pillShot");
  const btnStart = $("btnStart");
  const btnStop = $("btnStop");
  const btnVoice = $("btnVoice");

  // ===================== ê³µìš© =====================
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  function setPhase(p) {
    phase = p;
    pillPhase.textContent = p;
  }
  function setStatus(msg) {
    statusEl.textContent = msg;
  }
  function updatePills() {
    pillPage.textContent = String(pageIndex);
    pillTry.textContent = String(triesSamePage);
    pillShot.textContent = String(shotsThisPage);
  }

  function writeDebug(msg) {
    const line = `[${new Date().toLocaleTimeString()}] ${msg}`;
    debugEl.value = (debugEl.value + "\n" + line).trim();
    debugEl.scrollTop = debugEl.scrollHeight;
  }

  // TTS í
  let speakChain = Promise.resolve();
  function cancelSpeech() {
    try { window.speechSynthesis.cancel(); } catch {}
  }
  function speakOnce(text) {
    return new Promise((resolve) => {
      const u = new SpeechSynthesisUtterance(String(text || ""));
      u.lang = TTS_LANG;
      u.rate = TTS_RATE;
      u.pitch = 1.0;
      u.onend = () => resolve();
      u.onerror = () => resolve();
      window.speechSynthesis.speak(u);
    });
  }
  function say(text) {
    speakChain = speakChain.then(async () => {
      if (!running) return;
      await speakOnce(text);
    });
    return speakChain;
  }
  async function sayCountdown(sec) {
    for (let i = sec; i >= 1; i--) {
      if (!running) return;
      await say(String(i));
      await sleep(80);
    }
  }

  function normNoSpace(s) {
    return String(s || "").replace(/\s+/g, "").toLowerCase();
  }
  function hasDONE(text) {
    const n = normNoSpace(text);
    return !!n && n.includes("done");
  }

  // ===================== ì¹´ë©”ë¼ =====================
  async function ensureCamera() {
    if (stream) return;
    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    });
    video.srcObject = stream;

    await new Promise((resolve) => {
      if (video.readyState >= 2) return resolve();
      video.addEventListener("loadedmetadata", () => resolve(), { once: true });
    });
    await sleep(150);
  }

  function captureJpegDataUrl() {
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if (!vw || !vh) return null;

    // âœ… ì „ì†¡ìš©ëŸ‰ ì¤„ì´ê¸°(ì´ê²Œ OCR ì‹¤íŒ¨ì˜ ê°€ì¥ í”í•œ ì›ì¸ ì¤‘ í•˜ë‚˜)
    const maxW = 1280;
    const scale = Math.min(1, maxW / vw);
    const cw = Math.floor(vw * scale);
    const ch = Math.floor(vh * scale);

    const canvas = document.createElement("canvas");
    canvas.width = cw;
    canvas.height = ch;

    const ctx = canvas.getContext("2d", { alpha: false });
    ctx.drawImage(video, 0, 0, cw, ch);

    // âœ… í’ˆì§ˆ ì¡°ê¸ˆ ë‚®ì¶°ë„ ê¸€ìëŠ” ì¶©ë¶„íˆ ì½í˜ + ì „ì†¡ ì•ˆì •ì„± ì¦ê°€
    return canvas.toDataURL("image/jpeg", 0.78);
  }

  // ===================== OCR í˜¸ì¶œ =====================
  async function callOCR(imageDataUrl) {
    const res = await fetch("/.netlify/functions/ocr", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ imageDataUrl })
    });

    let data = null;
    let raw = "";
    try {
      raw = await res.text();
      data = JSON.parse(raw);
    } catch {
      // JSON íŒŒì‹± ì‹¤íŒ¨ë„ ë””ë²„ê·¸ë¡œ ë³´ì—¬ì•¼ í•¨
      throw new Error(`OCR ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: HTTP ${res.status} / head=${raw.slice(0, 120)}`);
    }

    if (!res.ok) {
      throw new Error(`OCR HTTP ì‹¤íŒ¨: ${res.status} / ${JSON.stringify(data).slice(0, 220)}`);
    }

    if (!data || data.ok !== true) {
      throw new Error(`OCR ì²˜ë¦¬ ì‹¤íŒ¨: ${JSON.stringify(data).slice(0, 260)}`);
    }

    return data; // {ok:true, text, conf, approxBytes}
  }

  // ===================== ê°„ë‹¨ ì ìˆ˜(ë² ìŠ¤íŠ¸ ì„ íƒ) =====================
  function hasChoicesPattern(t) {
    const s = String(t || "");
    const circ = ["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"];
    let c = 0;
    for (const x of circ) if (s.includes(x)) c++;
    if (c >= 3) return true;
    if (/\(A\).*\(B\).*\(C\)/s.test(s)) return true;
    if (/\b1\)\s+.*\b2\)\s+.*\b3\)/s.test(s)) return true;
    return false;
  }
  function hasQuestionNumberPattern(t) {
    const s = String(t || "");
    if (/(^|\n)\s*\d{1,2}\s*[.)]\s+/.test(s)) return true;
    if (/(^|\n)\s*\d{1,2}\s+/.test(s)) return true;
    return false;
  }
  function quickScore(text, conf) {
    const t = String(text || "").trim();
    const len = t.length;
    const lenScore = Math.max(0, Math.min(1, (len - 60) / 900));
    const pat = (hasChoicesPattern(t) ? 0.5 : 0) + (hasQuestionNumberPattern(t) ? 0.5 : 0);
    const confScore = (typeof conf === "number" && isFinite(conf)) ? conf : 0.45;
    return Math.max(0, Math.min(1, 0.60*lenScore + 0.25*pat + 0.15*confScore));
  }

  // ===================== í˜ì´ì§€ OCR(ë©€í‹°ìƒ·) =====================
  async function ocrPageBest(page) {
    triesSamePage++;
    shotsThisPage = (triesSamePage >= 3) ? SHOTS_MAX : SHOTS_BASE;
    updatePills();

    const results = [];
    for (let s = 1; s <= shotsThisPage; s++) {
      if (!running) return null;

      setStatus(`í˜ì´ì§€ ${page} OCR ì¤‘ì´ë‹¤. (ìƒ· ${s}/${shotsThisPage})\nì´¬ì˜ ì§ì „ ì ê¹ ë©ˆì¶°ë¼(ìë™ ì´ˆì  ì•ˆì •).`);
      await sleep(PRE_SHOT_SETTLE_MS);

      const img = captureJpegDataUrl();
      if (!img) throw new Error("ì¹´ë©”ë¼ ìº¡ì²˜ ì‹¤íŒ¨(ë¹„ë””ì˜¤ ì¤€ë¹„ ì „).");

      try {
        const o = await callOCR(img);
        const text = String(o.text || "");
        const conf = (typeof o.conf === "number" && isFinite(o.conf)) ? o.conf : 0.45;
        const score = quickScore(text, conf);
        results.push({ ok:true, text, conf, score, approxBytes: o.approxBytes || 0 });
        writeDebug(`OCR OK page=${page} shot=${s} len=${text.trim().length} conf=${conf.toFixed(2)} score=${score.toFixed(3)} bytes~${o.approxBytes||0}`);
      } catch (e) {
        const err = String(e && (e.message || e));
        results.push({ ok:false, text:"", conf:0, score:0, error: err });
        writeDebug(`OCR FAIL page=${page} shot=${s} :: ${err}`);
      }
      await sleep(120);
    }

    let best = null;
    for (const r of results) {
      if (!r.ok) continue;
      if (!best || r.score > best.score) best = r;
    }
    if (!best) return { ok:false, text:"", conf:0, score:0 };

    return { ok:true, ...best };
  }

  function pageLooksVeryBad(text) {
    const t = String(text || "").trim();
    return t.length < MIN_LEN_ACCEPT;
  }

  // ===================== ì „ì²´ í…ìŠ¤íŠ¸ ì¡°ë¦½ =====================
  function buildFullText() {
    let out = "";
    for (let i = 1; i < pageTexts.length; i++) {
      const t = pageTexts[i];
      if (!t) continue;
      out += `\n\n[PAGE ${i}]\n` + t;
    }
    return out.trim();
  }

  // ===================== ë¬¸í•­ íŒŒì‹±(ì›ë³¸ ìœ ì§€) =====================
  const CHOICE_SETS = [
    ["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"],
    ["(A)","(B)","(C)","(D)","(E)"],
    ["A.","B.","C.","D.","E."],
    ["A)","B)","C)","D)","E)"],
    ["1)","2)","3)","4)","5)"]
  ];

  function findChoiceSet(seg) {
    for (const set of CHOICE_SETS) {
      const ok = set.slice(0,3).every(m => seg.includes(m));
      if (ok) return set;
    }
    return null;
  }

  function splitByMarkers(seg, markers) {
    const idxs = markers.map(m => seg.indexOf(m));
    if (idxs.some(i => i < 0)) return null;
    for (let i = 1; i < idxs.length; i++) if (idxs[i] <= idxs[i-1]) return null;

    const stem = seg.slice(0, idxs[0]).trim();
    const c1 = seg.slice(idxs[0] + markers[0].length, idxs[1]).trim();
    const c2 = seg.slice(idxs[1] + markers[1].length, idxs[2]).trim();
    const c3 = seg.slice(idxs[2] + markers[2].length, idxs[3]).trim();
    const c4 = seg.slice(idxs[3] + markers[3].length, idxs[4]).trim();
    const c5 = seg.slice(idxs[4] + markers[4].length).trim();
    const choices = [c1,c2,c3,c4,c5].map(s => s.replace(/\s+/g, " ").trim()).filter(Boolean);
    if (choices.length !== 5) return null;
    return { stem, choices };
  }

  function normalizeTextForParse(t) {
    return String(t || "")
      .replace(/\r/g, "\n")
      .replace(/[ \t]+/g, " ")
      .replace(/\n{3,}/g, "\n\n");
  }

  function detectQuestionAnchors(full) {
    const lines = full.split("\n");
    let offset = 0;
    const anchors = [];
    for (const line of lines) {
      const m = line.match(/^\s*(\d{1,2})\s*[.)]\s+/) || line.match(/^\s*(\d{1,2})\s+/);
      if (m) {
        const n = Number(m[1]);
        if (Number.isFinite(n) && n >= 1 && n <= 60) {
          if (!anchors.some(a => a.n === n)) anchors.push({ n, idx: offset + line.indexOf(m[1]) });
        }
      }
      offset += line.length + 1;
    }
    anchors.sort((a,b) => a.idx - b.idx);
    return anchors;
  }

  function extractPassageContextBefore(full, qStartIdx) {
    const endMarkers = ["â‘¤", "(E)", "E.", "E)", "5)"];
    let last = -1;
    for (const m of endMarkers) {
      const j = full.lastIndexOf(m, qStartIdx);
      if (j > last) last = j + m.length;
    }
    const start = (last >= 0) ? last : Math.max(0, qStartIdx - 2200);
    const ctx = full.slice(start, qStartIdx).trim();
    if (ctx.length >= 180) return ctx;
    return "";
  }

  function parseQuestions(fullText) {
    const full = normalizeTextForParse(fullText);
    const anchors = detectQuestionAnchors(full);
    const issues = [];
    const questions = [];

    let currentContext = "";
    for (let i = 0; i < anchors.length; i++) {
      const a = anchors[i];
      const start = a.idx;
      const end = (i + 1 < anchors.length) ? anchors[i+1].idx : full.length;
      let seg = full.slice(start, end).trim();
      seg = seg.replace(/^\s*\d{1,2}\s*[.)]?\s+/, "");

      const ctx = extractPassageContextBefore(full, start);
      if (ctx) currentContext = ctx;

      const set = findChoiceSet(seg);
      if (!set) {
        issues.push({ type:"choices_missing", n:a.n });
        questions.push({ n:a.n, context: currentContext, stem: seg.slice(0, 260), choices: [], needsUnderline: false });
        continue;
      }

      const spl = splitByMarkers(seg, set);
      if (!spl) {
        issues.push({ type:"choices_split_fail", n:a.n });
        questions.push({ n:a.n, context: currentContext, stem: seg.slice(0, 260), choices: [], needsUnderline: false });
        continue;
      }

      const stem = spl.stem.replace(/\s+/g, " ").trim();
      const choices = spl.choices;

      // underline ìš”êµ¬ í‘œí˜„(ì‹œí—˜ë§ˆë‹¤ ë‹¤ë¥´ë¯€ë¡œ ì•½í•˜ê²Œ íƒì§€)
      const needsUnderline = /underlin/i.test(seg) || /underline/i.test(seg) || /underlined/i.test(seg);
      questions.push({ n:a.n, context: currentContext, stem, choices, needsUnderline });
    }

    if (questions.length < 10) issues.push({ type:"too_few_questions", got: questions.length });
    return { questions, issues };
  }

  function findLikelyPageForQuestion(n) {
    const n2 = String(n).padStart(2,"0");
    const re1 = new RegExp(`(^|\\n)\\s*${n2}\\s*[.)]?\\s`, "m");
    const re2 = new RegExp(`(^|\\n)\\s*${n}\\s*[.)]?\\s`, "m");
    for (let p = 1; p < pageTexts.length; p++) {
      const t = pageTexts[p] || "";
      if (!t) continue;
      if ((re1.test(t) || re2.test(t)) && hasChoicesPattern(t)) return p;
    }
    return Math.max(1, pageTexts.length - 1);
  }

  // ===================== OpenRouter í˜¸ì¶œ =====================
  async function callUnderline(imageDataUrl, questionNumbers, hintText) {
    const res = await fetch("/.netlify/functions/underline", {
      method: "POST",
      headers: { "content-type":"application/json" },
      body: JSON.stringify({ imageDataUrl, questionNumbers, hintText })
    });
    const raw = await res.text().catch(()=> "");
    let data = null;
    try { data = JSON.parse(raw); } catch { throw new Error(`UNDERLINE ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: HTTP ${res.status} head=${raw.slice(0,120)}`); }
    if (!res.ok) throw new Error(`UNDERLINE HTTP ì‹¤íŒ¨: ${res.status} ${JSON.stringify(data).slice(0,220)}`);
    if (!data.ok) throw new Error(`UNDERLINE ì²˜ë¦¬ ì‹¤íŒ¨: ${JSON.stringify(data).slice(0,220)}`);
    return data.underlined;
  }

  async function callSolve(items) {
    const res = await fetch("/.netlify/functions/solve", {
      method: "POST",
      headers: { "content-type":"application/json" },
      body: JSON.stringify({ items })
    });
    const raw = await res.text().catch(()=> "");
    let data = null;
    try { data = JSON.parse(raw); } catch { throw new Error(`SOLVE ì‘ë‹µ íŒŒì‹± ì‹¤íŒ¨: HTTP ${res.status} head=${raw.slice(0,120)}`); }
    if (!res.ok) throw new Error(`SOLVE HTTP ì‹¤íŒ¨: ${res.status} ${JSON.stringify(data).slice(0,220)}`);
    if (!data.ok) throw new Error(`SOLVE ì²˜ë¦¬ ì‹¤íŒ¨: ${JSON.stringify(data).slice(0,220)}`);
    return data.answers;
  }

  // ===================== ë°‘ì¤„ ì¶”ì¶œìš© ì´¬ì˜ =====================
  async function captureUnderlineMapForPage(page, qNums) {
    await say(`ë°‘ì¤„ ì¶”ì¶œì´ í•„ìš”í•©ë‹ˆë‹¤. ${page}í˜ì´ì§€ë¥¼ í™”ë©´ì— ë³´ì—¬ ì£¼ì„¸ìš”. ${BETWEEN_PAGE_SEC}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
    await sayCountdown(BETWEEN_PAGE_SEC);

    let best = null;
    for (let s = 1; s <= 2; s++) {
      if (!running) return null;
      setStatus(`ë°‘ì¤„ ì¶”ì¶œìš© ì´¬ì˜ ì¤‘ì´ë‹¤. (í˜ì´ì§€ ${page}, ìƒ· ${s}/2)\nì´¬ì˜ ì§ì „ ì ê¹ ë©ˆì¶°ë¼.`);
      await sleep(PRE_SHOT_SETTLE_MS);

      const img = captureJpegDataUrl();
      if (!img) throw new Error("ì¹´ë©”ë¼ ìº¡ì²˜ ì‹¤íŒ¨");

      try {
        const hint = pageTexts[page] || "";
        const underlined = await callUnderline(img, qNums, hint);
        const count = underlined ? Object.keys(underlined).length : 0;
        const score = count;
        if (!best || score > best.score) best = { underlined, score };
        writeDebug(`UNDERLINE OK page=${page} shot=${s} got=${count}`);
      } catch (e) {
        writeDebug(`UNDERLINE FAIL page=${page} shot=${s} :: ${String(e && (e.message||e))}`);
      }
      await sleep(200);
    }
    return best ? best.underlined : null;
  }

  // ===================== OCR ë£¨í”„ =====================
  async function ocrLoopUntilDONE() {
    setPhase("OCRING");
    pageIndex = 1;
    triesSamePage = 0;
    updatePills();

    await say("ìë™ ì˜¤ì”¨ì•Œì„ ì‹œì‘í•©ë‹ˆë‹¤. ì²« í˜ì´ì§€ë¥¼ í™”ë©´ì— ë³´ì—¬ ì£¼ì„¸ìš”.");

    while (running && pageIndex <= MAX_PAGES) {
      updatePills();
      setStatus(`í˜ì´ì§€ ${pageIndex}ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë§ì¶”ê³  ê°€ë§Œíˆ ìœ ì§€í•˜ë¼.`);

      const r = await ocrPageBest(pageIndex);
      if (!running) return false;

      if (!r || !r.ok) {
        if (triesSamePage <= RETRY_BEFORE_FORCE_ACCEPT) {
          await say(`ì¸ì‹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${RETRY_SEC}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
          await sayCountdown(RETRY_SEC);
          continue;
        }

        pageTexts[pageIndex] = "";
        pageScores[pageIndex] = 0;
        writeDebug(`[PAGE ${pageIndex}] FORCE-ACCEPT (OCR failed too many times)`);
        await say(`ì´ í˜ì´ì§€ ì¸ì‹ì´ ê³„ì† ì‹¤íŒ¨í•©ë‹ˆë‹¤. ì¼ë‹¨ ë„˜ì–´ê°‘ë‹ˆë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”. ${BETWEEN_PAGE_SEC}ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¥¼ ì¸ì‹í•©ë‹ˆë‹¤.`);
        await sayCountdown(BETWEEN_PAGE_SEC);
        triesSamePage = 0;
        pageIndex++;
        continue;
      }

      const text = String(r.text || "");
      pageScores[pageIndex] = r.score;
      writeDebug(`[PAGE ${pageIndex}] BEST score=${r.score.toFixed(3)} conf=${r.conf.toFixed(2)} len=${text.trim().length}`);

      if (hasDONE(text)) {
        pageTexts[pageIndex] = text;
        await say("DONEì„ í™•ì¸í–ˆìŠµë‹ˆë‹¤. ì´¬ì˜ì„ ì¢…ë£Œí•˜ê³  ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
        return true;
      }

      if (pageLooksVeryBad(text)) {
        if (triesSamePage <= RETRY_BEFORE_FORCE_ACCEPT) {
          await say(`ì§€ê¸ˆ í˜ì´ì§€ ì¸ì‹ì´ ì•½í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${RETRY_SEC}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
          await sayCountdown(RETRY_SEC);
          continue;
        }
        pageTexts[pageIndex] = text;
        await say(`ì´ í˜ì´ì§€ ì¸ì‹ì´ ì•½í•˜ì§€ë§Œ ìë™í™”ë¥¼ ìœ„í•´ ì €ì¥í•˜ê³  ë„˜ì–´ê°‘ë‹ˆë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”. ${BETWEEN_PAGE_SEC}ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¥¼ ì¸ì‹í•©ë‹ˆë‹¤.`);
      } else {
        pageTexts[pageIndex] = text;
        if (text.trim().length >= MIN_LEN_GOOD) {
          await say(`ì´ í˜ì´ì§€ ì¸ì‹ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”. ${BETWEEN_PAGE_SEC}ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¥¼ ì¸ì‹í•©ë‹ˆë‹¤.`);
        } else {
          await say(`ì´ í˜ì´ì§€ë¥¼ ì €ì¥í–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”. ${BETWEEN_PAGE_SEC}ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¥¼ ì¸ì‹í•©ë‹ˆë‹¤.`);
        }
      }

      await sayCountdown(BETWEEN_PAGE_SEC);
      triesSamePage = 0;
      pageIndex++;
    }

    return false;
  }

  async function validateAndFix(fullText) {
    setPhase("VALIDATING");
    setStatus("ë¬¸í•­ êµ¬ì¡°ë¥¼ ê²€ì¦ ì¤‘ì´ë‹¤â€¦");
    await say("ë¬¸í•­ êµ¬ì¡°ë¥¼ ê²€ì¦í•©ë‹ˆë‹¤.");

    for (let loop = 0; loop < 12 && running; loop++) {
      const { questions, issues } = parseQuestions(fullText);

      const bad = issues.find(x => x.type === "choices_missing" || x.type === "choices_split_fail");
      const tooFew = issues.find(x => x.type === "too_few_questions");

      if (!bad && !tooFew) return questions;

      let targetN = null;
      if (bad) targetN = bad.n;
      else if (questions.length > 0) targetN = questions[Math.max(0, questions.length - 1)].n;

      if (!targetN) throw new Error("Parsing failed");

      const targetPage = findLikelyPageForQuestion(targetN);
      await say(`${targetN}ë²ˆ ë¬¸ì œ í…ìŠ¤íŠ¸ê°€ ì´ìƒí•©ë‹ˆë‹¤. ${targetPage}í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${BETWEEN_PAGE_SEC}ì´ˆ ë’¤ì— ìë™ ì´¬ì˜í•©ë‹ˆë‹¤.`);
      await sayCountdown(BETWEEN_PAGE_SEC);

      triesSamePage = 0;
      for (let t = 0; t < MAX_RETRY_SAME_PAGE && running; t++) {
        const r = await ocrPageBest(targetPage);
        if (!r || !r.ok) {
          await say(`ì¬ì´¬ì˜ ì¸ì‹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ${RETRY_SEC}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
          await sayCountdown(RETRY_SEC);
          continue;
        }
        const tx = String(r.text || "");
        if (tx.trim().length < MIN_LEN_ACCEPT) {
          await say(`ì¬ì´¬ì˜ ì¸ì‹ì´ ì•½í•©ë‹ˆë‹¤. ${RETRY_SEC}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
          await sayCountdown(RETRY_SEC);
          continue;
        }
        pageTexts[targetPage] = tx;
        writeDebug(`[RECAPTURE PAGE ${targetPage}] score=${r.score.toFixed(3)} len=${tx.trim().length}`);
        break;
      }

      fullText = buildFullText();
      await sleep(200);
    }

    throw new Error("Validation loop exceeded");
  }

  async function extractUnderlinesIfNeeded(questions) {
    const needs = questions.filter(q => q.needsUnderline).map(q => q.n);
    if (needs.length === 0) return {};

    setPhase("UNDERLINE");
    await say("ë°‘ì¤„ í‘œí˜„ì„ ì¶”ì¶œí•©ë‹ˆë‹¤.");

    const byPage = new Map();
    for (const n of needs) {
      const p = findLikelyPageForQuestion(n);
      if (!byPage.has(p)) byPage.set(p, []);
      byPage.get(p).push(n);
    }

    const underlineMap = {};
    for (const [p, nums] of byPage.entries()) {
      if (!running) break;

      let got = null;
      for (let attempt = 0; attempt < 4 && running; attempt++) {
        got = await captureUnderlineMapForPage(p, nums);
        if (got && Object.keys(got).length > 0) break;
        await say("ë°‘ì¤„ ì¶”ì¶œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.");
        await sleep(400);
      }

      // âœ… ì—¬ê¸°ì„œ ë©ˆì¶”ì§€ ë§ê³ (ìë™í™” ìœ ì§€), ë°‘ì¤„ ì—†ì´ ì§„í–‰
      if (!got || Object.keys(got).length === 0) {
        writeDebug(`UNDERLINE GIVEUP page=${p} nums=${nums.join(",")}`);
        await say("ë°‘ì¤„ ì¶”ì¶œì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë°‘ì¤„ ì—†ì´ í’€ì´ë¥¼ ê³„ì†í•©ë‹ˆë‹¤.");
        continue;
      }

      for (const k of Object.keys(got)) underlineMap[Number(k)] = String(got[k] || "").trim();
    }

    return underlineMap;
  }

  async function solveAll(questions, underlineMap) {
    setPhase("SOLVING");
    setStatus("ìë™ í’€ì´ ì¤‘ì´ë‹¤â€¦");
    await say("ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");

    const qs = questions
      .filter(q => q && q.choices && q.choices.length === 5 && q.stem)
      .sort((a,b)=>a.n-b.n);

    const answers = {};
    for (let i = 0; i < qs.length && running; i += SOLVE_CHUNK) {
      const chunk = qs.slice(i, i + SOLVE_CHUNK);
      const range = `${chunk[0].n}ë²ˆë¶€í„° ${chunk[chunk.length-1].n}ë²ˆê¹Œì§€`;
      setStatus(`í’€ì´ ì¤‘ì´ë‹¤. (${Math.floor(i/SOLVE_CHUNK)+1}/${Math.ceil(qs.length/SOLVE_CHUNK)}) ${range}`);
      await say(`${range}ë¥¼ í’‰ë‹ˆë‹¤.`);

      const items = chunk.map(q => ({
        n: q.n,
        context: q.context || "",
        stem: q.stem,
        choices: q.choices,
        underlined: underlineMap[q.n] || ""
      }));

      let got = null;
      for (let attempt = 0; attempt < 6 && running; attempt++) {
        try {
          got = await callSolve(items);
          writeDebug(`SOLVE OK ${range} -> ${JSON.stringify(got)}`);
          break;
        } catch (e) {
          const msg = String(e && (e.message || e));
          writeDebug(`SOLVE FAIL ${range} :: ${msg}`);
          setStatus(`í’€ì´ ì‹¤íŒ¨(${range}). ìë™ ì¬ì‹œë„ ì¤‘ì´ë‹¤.\n${msg}`);
          await say("í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.");
          await sleep(700);
        }
      }
      if (!got) throw new Error("Solve failed persistently");

      for (const q of chunk) {
        const v = Number(got[String(q.n)]);
        if (![1,2,3,4,5].includes(v)) throw new Error(`Invalid answer for ${q.n}`);
        answers[q.n] = v;
      }
    }

    return answers;
  }

  async function speakAnswers(answers) {
    setPhase("SPEAK");
    setStatus("ì •ë‹µì„ ìŒì„±ìœ¼ë¡œ ì½ëŠ”ë‹¤.");
    await say("ì •ë‹µì„ ì½ìŠµë‹ˆë‹¤.");

    const nums = Object.keys(answers).map(Number).filter(n => Number.isFinite(n)).sort((a,b)=>a-b);
    for (const n of nums) {
      if (!running) return;
      await say(`${n}ë²ˆ ì •ë‹µì€ ${answers[n]}ë²ˆì…ë‹ˆë‹¤.`);
      await sleep(140);
    }
    await say("ì •ë‹µ ë‚­ë…ì´ ëë‚¬ìŠµë‹ˆë‹¤.");
  }

  async function runAll() {
    debugEl.value = "";
    pageTexts.length = 0;
    pageScores.length = 0;
    pageIndex = 1;
    triesSamePage = 0;
    shotsThisPage = SHOTS_BASE;
    updatePills();

    setStatus("ì¹´ë©”ë¼ë¥¼ ì—¬ëŠ” ì¤‘ì´ë‹¤â€¦");
    await ensureCamera();

    await say("ì£¼ì˜. ë§ˆì§€ë§‰ í˜ì´ì§€ì— DONEì„ í¬ê²Œ ì“°ë©´ ìë™ìœ¼ë¡œ ì¢…ë£Œë©ë‹ˆë‹¤.");
    await say("ì´ì œ ì²« í˜ì´ì§€ë¥¼ í™”ë©´ì— ë³´ì—¬ ì£¼ì„¸ìš”.");

    const okDone = await ocrLoopUntilDONE();
    if (!okDone) {
      await say("DONEì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ìë™ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.");
      throw new Error("DONE not detected within MAX_PAGES");
    }

    let fullText = buildFullText().replace(/DONE/gi, "");

    const questions = await validateAndFix(fullText);
    const underlineMap = await extractUnderlinesIfNeeded(questions);
    const answers = await solveAll(questions, underlineMap);

    const nums = Object.keys(answers).map(Number).sort((a,b)=>a-b);
    writeDebug("\n[ANSWERS]");
    for (const n of nums) writeDebug(`${n}=${answers[n]}`);

    await speakAnswers(answers);

    setPhase("IDLE");
    setStatus("ì™„ë£Œ.");
  }

  async function stopAll(msg) {
    running = false;
    setPhase("IDLE");
    btnStart.disabled = false;
    btnStop.disabled = true;
    cancelSpeech();
    setStatus(msg || "ì •ì§€í–ˆë‹¤.");
    pillPage.textContent = "-";
    pillTry.textContent = "-";
    pillShot.textContent = "-";
  }

  // ===================== ë²„íŠ¼ =====================
  btnVoice.addEventListener("click", async () => {
    running = true;
    await say("ìŒì„± í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤. ìë™ ì˜¤ì”¨ì•Œ ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
    running = false;
    cancelSpeech();
  });

  btnStop.addEventListener("click", async () => {
    await stopAll("ì •ì§€í–ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ â€˜ìë™ OCR ì‹œì‘â€™ì„ ëˆ„ë¥´ë¼.");
  });

  btnStart.addEventListener("click", async () => {
    if (running) return;
    running = true;
    btnStart.disabled = true;
    btnStop.disabled = false;
    cancelSpeech();

    try {
      await runAll();
    } catch (e) {
      const msg = String(e && (e.message || e));
      writeDebug(`FATAL :: ${msg}`);
      setStatus("ì˜¤ë¥˜:\n" + msg);
      try { await say("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”."); } catch {}
    } finally {
      await stopAll(statusEl.textContent);
    }
  });

})();
</script>
</body>
</html>

