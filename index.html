<!-- index.html  (루트에 그대로 저장) -->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Auto OCR → Solve → TTS</title>
  <style>
    :root { color-scheme: dark; }
    body { margin: 0; font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; background:#0b1020; color:#e8eefc; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 14px; }
    h1 { font-size: 18px; margin: 0 0 10px; }
    .row { display: grid; grid-template-columns: 1fr; gap: 12px; }
    .card { background: rgba(255,255,255,0.06); border:1px solid rgba(255,255,255,0.12); border-radius: 14px; padding: 12px; }
    .btns { display:flex; gap:10px; flex-wrap: wrap; }
    button {
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.08);
      color:#e8eefc;
      padding: 10px 12px;
      border-radius: 12px;
      font-weight: 700;
    }
    button:active { transform: translateY(1px); }
    .pill { display:inline-flex; gap:10px; align-items:center; padding:8px 10px; border-radius:999px; background:rgba(255,255,255,0.07); border:1px solid rgba(255,255,255,0.12); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    textarea { width:100%; min-height: 160px; background:#070b16; color:#e8eefc; border:1px solid rgba(255,255,255,0.14); border-radius: 12px; padding:10px; font-size: 13px; line-height: 1.3; }
    .log { min-height: 180px; }
    video, img { width:100%; border-radius: 14px; background:#000; }
    .small { opacity: 0.86; font-size: 12px; line-height: 1.35; }
    .warn { color:#ffd479; }
    .ok { color:#7cffc2; }
    .bad { color:#ff8e8e; }
  </style>
</head>
<body>
<div class="wrap">
  <h1>자동 촬영 → OCR 누적 → DONE 감지 → 자동 풀이 → 자동 TTS</h1>

  <div class="card small">
    <div class="warn">중요</div>
    <div>• iOS 사파리는 보안 정책 때문에 <b>TTS가 “완전 무터치 자동”으로 시작</b>이 안 될 수 있다. 그래서 <b>처음 1회만</b> “오디오 활성화” 버튼을 눌러 잠금 해제한다(그 후엔 자동으로 읽는다).</div>
    <div>• 마지막 페이지 여백에 <b>DONE</b>을 크게 쓰면, OCR에서 DONE을 찾는 즉시 촬영을 멈추고 자동 풀이로 넘어간다.</div>
  </div>

  <div class="card btns">
    <button id="btnAudio">오디오 활성화(1회)</button>
    <button id="btnStart">AUTO START</button>
    <button id="btnStop">STOP</button>
    <button id="btnReset">RESET</button>
    <span class="pill mono" id="status">idle</span>
    <span class="pill mono" id="stage">stage: -</span>
    <span class="pill mono" id="page">page: 1</span>
    <span class="pill mono" id="shot">shot: 0</span>
  </div>

  <div class="row">
    <div class="card">
      <div class="small">카메라</div>
      <video id="video" autoplay playsinline muted></video>
    </div>

    <div class="card">
      <div class="small">최근 캡처 샷</div>
      <img id="lastImg" alt="last shot" />
    </div>

    <div class="card">
      <div class="small">OCR 누적 텍스트</div>
      <textarea id="ocrText" readonly>자동 OCR 결과가 여기에 누적된다.</textarea>
    </div>

    <div class="card">
      <div class="small">정답(TTS는 자동으로 읽는다)</div>
      <textarea id="answer" readonly>자동 풀이 결과가 여기에 표시된다.</textarea>
    </div>

    <div class="card">
      <div class="small">로그</div>
      <textarea class="log mono" id="log" readonly></textarea>
    </div>
  </div>
</div>

<script>
/** =========================
 *  설정 (너 기준 “너무 빡빡” 문제 해결)
 *  ========================= */
const CFG = {
  MAX_PAGES: 30,              // DONE 못 찾을 때 무한루프 방지
  SHOTS_PER_PAGE: 3,          // 같은 페이지를 3번 찍고 “가장 좋은 OCR” 채택
  GAP_BETWEEN_SHOTS_MS: 900,  // 연속샷 간격
  WAIT_BEFORE_SHOT_MS: 900,   // 촬영 직전 잠깐 멈춤(자동초점 안정)
  NEXT_PAGE_DELAY_MS: 650,    // 페이지 넘어가기 텀
  AUTO_INTERVAL_MS: 0,        // 0이면 내부 루프로 굴림(촬영→OCR→다음)
  JPEG_QUALITY: 0.78,
  MAX_W: 1600,                // 전송량 줄이기(중요)
  MAX_H: 2200,
  // “불안정 기준” 완화: 점수가 낮아도 몇 번은 시도하고, 계속 실패하면 강제 채택 후 다음
  MIN_GOOD_SCORE: 0.38,
  MAX_RETRY_PER_PAGE: 2,      // 페이지당 재시도(자동). 넘어가며 멈추지 않게.
  DONE_REGEX: /\bDONE\b/i,
  // 문제 패턴(성대/홍대 스타일)
  QUESTION_HINT_REGEX: /(?:\(\d{2}-\d{2}\)|\[\d{2}-\d{2}\]|\b0?\d{1,2}\b.*Choose|\b0?\d{1,2}\b|•|@)/i
};

let stream = null;
let running = false;
let pageNo = 1;
let shotNo = 0;
let ocrPages = []; // {page, text}
let audioUnlocked = false;

const $ = (id) => document.getElementById(id);
const logEl = $("log");
const ocrEl = $("ocrText");
const ansEl = $("answer");
const statusEl = $("status");
const stageEl = $("stage");
const pageEl = $("page");
const shotEl = $("shot");
const video = $("video");
const lastImg = $("lastImg");

function log(msg) {
  const t = new Date();
  const hh = String(t.getHours()).padStart(2,'0');
  const mm = String(t.getMinutes()).padStart(2,'0');
  const ss = String(t.getSeconds()).padStart(2,'0');
  logEl.value += `[${hh}:${mm}:${ss}] ${msg}\n`;
  logEl.scrollTop = logEl.scrollHeight;
}

function setStatus(s) { statusEl.textContent = s; }
function setStage(s) { stageEl.textContent = "stage: " + s; }
function setPage(n) { pageEl.textContent = "page: " + n; }
function setShot(n) { shotEl.textContent = "shot: " + n; }

async function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

/** 캔버스로 리사이즈 + JPEG base64(dataURL) */
function captureToDataURL() {
  const w = video.videoWidth || 0;
  const h = video.videoHeight || 0;
  if (!w || !h) throw new Error("video not ready");

  const scale = Math.min(CFG.MAX_W / w, CFG.MAX_H / h, 1);
  const cw = Math.round(w * scale);
  const ch = Math.round(h * scale);

  const canvas = document.createElement("canvas");
  canvas.width = cw;
  canvas.height = ch;
  const ctx = canvas.getContext("2d", { willReadFrequently: true });
  ctx.drawImage(video, 0, 0, cw, ch);

  // 약간의 대비/샤프닝은 브라우저에서 과하면 오히려 깨짐 → 여기선 건드리지 않음
  const dataURL = canvas.toDataURL("image/jpeg", CFG.JPEG_QUALITY);
  return dataURL;
}

/** OCR 호출 */
async function callOCR(dataURL, page, shot) {
  const res = await fetch("/.netlify/functions/ocr", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ imageBase64: dataURL, page, shot })
  });
  const j = await res.json().catch(() => ({}));
  if (!res.ok || !j.ok) {
    const detail = j?.detail ? ` / ${j.detail}` : "";
    throw new Error(`OCR HTTP 실패: ${res.status} / ${JSON.stringify(j)}${detail}`);
  }
  return j;
}

/** solve 호출 */
async function callSolve(fullText) {
  const res = await fetch("/.netlify/functions/solve", {
    method: "POST",
    headers: {"Content-Type":"application/json"},
    body: JSON.stringify({ text: fullText })
  });
  const j = await res.json().catch(() => ({}));
  if (!res.ok || !j.ok) throw new Error(`SOLVE 실패: ${res.status} / ${JSON.stringify(j)}`);
  return j;
}

/** iOS TTS 잠금 해제(한 번 탭 필요) */
function unlockAudioOnce() {
  try {
    const u = new SpeechSynthesisUtterance("오디오 활성화 완료");
    u.rate = 1.0;
    u.pitch = 1.0;
    u.lang = "ko-KR";
    speechSynthesis.speak(u);
    audioUnlocked = true;
    log("AUDIO unlocked");
  } catch (e) {
    log("AUDIO unlock failed: " + e.message);
  }
}

function speakKorean(text) {
  if (!audioUnlocked) {
    log("TTS blocked (audio not unlocked). '오디오 활성화(1회)' 버튼을 한 번 눌러야 함.");
    return;
  }
  try {
    speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "ko-KR";
    u.rate = 1.05;
    speechSynthesis.speak(u);
  } catch (e) {
    log("TTS error: " + e.message);
  }
}

async function ensureCamera() {
  if (stream) return;
  stream = await navigator.mediaDevices.getUserMedia({
    video: {
      facingMode: "environment",
      width: { ideal: 1920 },
      height: { ideal: 1080 }
    },
    audio: false
  });
  video.srcObject = stream;
  await new Promise(r => video.onloadedmetadata = r);
}

/** 페이지 1장에 대해: 3연속 샷 OCR → 가장 좋은 결과 선택 */
async function ocrOnePageAuto(page) {
  setStage("OCRING");
  let best = null; // {score, text, doneDetected}
  let fails = 0;

  for (let i=1; i<=CFG.SHOTS_PER_PAGE; i++) {
    shotNo += 1;
    setShot(shotNo);

    await sleep(CFG.WAIT_BEFORE_SHOT_MS);

    let dataURL;
    try {
      dataURL = captureToDataURL();
    } catch (e) {
      log(`[PAGE ${page}] 캡처 실패: ${e.message}`);
      fails++;
      continue;
    }

    lastImg.src = dataURL;

    try {
      log(`페이지 ${page} OCR 중이다. (샷 ${i}/${CFG.SHOTS_PER_PAGE}) 촬영 직전 잠깐 멈춰라(자동 초점 안정).`);
      const out = await callOCR(dataURL, page, i);

      // 점수 산정: confidence(0~1) + 길이 가점
      const len = (out.text || "").trim().length;
      const score = Math.min(1, (out.confidence || 0) * 0.75 + Math.min(1, len/2500) * 0.25);

      log(`OCR OK page=${page} shot=${i} conf=${(out.confidence||0).toFixed(2)} len=${len} score=${score.toFixed(2)} done=${out.doneDetected ? "Y":"N"}`);

      if (!best || score > best.score) {
        best = { score, text: out.text || "", doneDetected: !!out.doneDetected };
      }

    } catch (e) {
      fails++;
      log(`OCR FAIL page=${page} shot=${i} :: ${e.message}`);
    }

    await sleep(CFG.GAP_BETWEEN_SHOTS_MS);
  }

  if (!best) {
    return { ok:false, forced:false, text:"", done:false };
  }

  // “너무 빡빡해서 계속 재촬영” 문제 해결: 기준 완화 + 자동 재시도 제한
  const okQuality = best.score >= CFG.MIN_GOOD_SCORE && (best.text.trim().length >= 150);

  return {
    ok: true,
    forced: !okQuality,
    text: best.text,
    done: best.doneDetected
  };
}

function appendPageText(page, text) {
  ocrPages.push({ page, text });
  const merged = ocrPages
    .slice()
    .sort((a,b)=>a.page-b.page)
    .map(p => `[PAGE ${p.page}]\n${p.text}` )
    .join("\n\n");

  ocrEl.value = merged;
  ocrEl.scrollTop = ocrEl.scrollHeight;
}

function buildFullText() {
  return ocrPages
    .slice()
    .sort((a,b)=>a.page-b.page)
    .map(p => `[PAGE ${p.page}]\n${p.text}` )
    .join("\n\n");
}

async function runAuto() {
  running = true;
  setStatus("running");
  setStage("START");
  log("AUTO START");

  await ensureCamera();

  for (pageNo = 1; pageNo <= CFG.MAX_PAGES; pageNo++) {
    if (!running) break;
    setPage(pageNo);

    let attempt = 0;
    let result = null;

    while (attempt <= CFG.MAX_RETRY_PER_PAGE) {
      attempt++;

      result = await ocrOnePageAuto(pageNo);

      if (!result.ok) {
        log(`[PAGE ${pageNo}] OCR 결과 없음. (attempt ${attempt}/${CFG.MAX_RETRY_PER_PAGE+1})`);
        continue;
      }

      if (result.forced) {
        log(`[PAGE ${pageNo}] FORCE-ACCEPT (품질 낮음) - 자동화 멈춤 방지`);
      }

      appendPageText(pageNo, result.text);

      // DONE 감지(텍스트에서)
      const doneInText = CFG.DONE_REGEX.test(result.text || "");
      if (result.done || doneInText) {
        log(`DONE detected on page=${pageNo}. 이제 자동 풀이로 넘어간다.`);
        setStage("SOLVING");
        break;
      }

      // “문제 패턴이 하나도 없으면” 다음 샷에서 보완될 수 있음.
      // 여기서는 자동화 우선: 그냥 다음 페이지로 진행.
      break;
    }

    if (!result) {
      log(`[PAGE ${pageNo}] FATAL :: no OCR result`);
      continue;
    }

    if (result.done || CFG.DONE_REGEX.test(result.text || "")) {
      break;
    }

    await sleep(CFG.NEXT_PAGE_DELAY_MS);
  }

  if (!running) {
    setStatus("stopped");
    setStage("-");
    return;
  }

  // 풀기 전에 최소한의 텍스트 검증
  const full = buildFullText();
  const hintOk = CFG.QUESTION_HINT_REGEX.test(full) && full.length >= 400;

  if (!hintOk) {
    log("SOLVE ABORT: OCR 텍스트가 너무 짧거나 문제 패턴이 약함. 그래도 강제로 한 번 시도한다.");
  }

  try {
    const solved = await callSolve(full);
    ansEl.value = solved.answerText || "(빈 결과)";
    ansEl.scrollTop = 0;

    log("SOLVE OK");
    setStage("DONE");
    setStatus("idle");

    // TTS: 너무 길면 앞부분만 읽고, 나머지는 화면으로.
    const speakText = solved.ttsText || solved.answerText || "";
    if (speakText) speakKorean(speakText);

  } catch (e) {
    log("SOLVE ERROR: " + e.message);
    ansEl.value = "풀이 실패: " + e.message;
    setStage("ERROR");
    setStatus("idle");
  }

  running = false;
}

function stopAll() {
  running = false;
  setStatus("stopped");
  setStage("-");
  log("STOP");
}

function resetAll() {
  stopAll();
  pageNo = 1;
  shotNo = 0;
  ocrPages = [];
  setPage(1);
  setShot(0);
  ocrEl.value = "자동 OCR 결과가 여기에 누적된다.";
  ansEl.value = "자동 풀이 결과가 여기에 표시된다.";
  logEl.value = "";
  lastImg.removeAttribute("src");
  log("RESET");
  setStatus("idle");
}

$("btnAudio").addEventListener("click", unlockAudioOnce);
$("btnStart").addEventListener("click", () => runAuto());
$("btnStop").addEventListener("click", stopAll);
$("btnReset").addEventListener("click", resetAll);

// 초기 상태
setStatus("idle");
setStage("-");
setPage(1);
setShot(0);
</script>
</body>
</html>
