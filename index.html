<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>í¸ì…ì˜ì–´ ìë™ OCR â†’ ìë™ í’€ì´ â†’ TTS</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; margin: 0; padding: 16px; background: #0b0d12; color: #e9eef8; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button { padding: 12px 14px; border-radius: 10px; border: 0; background: #2b6cff; color: white; font-weight: 700; }
    button.secondary { background: #2a2f3b; }
    button.danger { background: #ff3b3b; }
    #status { padding: 12px; border-radius: 12px; background: #121622; line-height: 1.5; white-space: pre-wrap; }
    video { width: 100%; max-height: 52vh; border-radius: 14px; background: #000; }
    .small { opacity: 0.8; font-size: 13px; line-height: 1.45; }
    textarea { width: 100%; min-height: 190px; border-radius: 12px; border: 1px solid #2a2f3b; background: #0f1320; color: #dfe7ff; padding: 10px; box-sizing: border-box; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
    .pill { display: inline-block; padding: 4px 8px; border-radius: 999px; background: #1b2234; font-size: 12px; }
    .ok { color: #7dffb2; }
    .warn { color: #ffd36a; }
    .bad { color: #ff8080; }
  </style>
</head>
<body>
  <div class="row">
    <button id="btnAuto">ğŸ“¸ ìë™ OCR ì‹œì‘</button>
    <button id="btnStop" class="danger" disabled>â›” ì •ì§€</button>
    <button id="btnTestVoice" class="secondary">ğŸ”Š ìŒì„± í…ŒìŠ¤íŠ¸</button>
  </div>

  <div style="margin-top:12px" id="status">ëŒ€ê¸° ì¤‘ì´ë‹¤. â€˜ìë™ OCR ì‹œì‘â€™ì„ ëˆ„ë¥´ë©´ ì¹´ë©”ë¼ë¥¼ ì—°ë‹¤.</div>
  <div class="small" style="margin-top:8px">
    - í˜ì´ì§€ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë§ì¶”ê³ , í”ë“¤ë¦¼/ë°˜ì‚¬ê´‘ì„ ì¤„ì´ë¼.<br/>
    - ë§ˆì§€ë§‰ í˜ì´ì§€ì—ëŠ” <b>â€œì´¬ì˜ì™„ë£Œâ€</b>ë¥¼ í¬ê²Œ ì“°ê³ (ê¶Œì¥: â€œì´¬ì˜ì™„ë£Œ DONEâ€), ê°ì§€ë˜ë©´ ìë™ìœ¼ë¡œ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br/>
    - OCRì´ ë¶ˆì•ˆì •í•˜ë©´ â€œë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”â€ë¼ê³  ë§í•˜ë©° ê°™ì€ í˜ì´ì§€ë¥¼ ìë™ ì¬ì´¬ì˜í•œë‹¤(ìˆ˜ë™ í¸ì§‘ ì—†ìŒ).
  </div>

  <div class="grid">
    <video id="video" autoplay playsinline muted></video>

    <div class="small">
      í˜„ì¬ í˜ì´ì§€(ìº¡ì²˜ ìˆœì„œ): <span class="pill" id="pagePill">1</span>
      &nbsp;|&nbsp; ìƒíƒœ: <span class="pill" id="phasePill">IDLE</span>
    </div>

    <textarea id="ocrAll" placeholder="OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸ìš©). ìë™ìœ¼ë¡œ ì±„ì›Œì§„ë‹¤." spellcheck="false"></textarea>
  </div>

<script>
(() => {
  "use strict";

  // ====== ì„¤ì • ======
  const SHOTS_PER_PAGE = 3;              // í˜ì´ì§€ë‹¹ ë©€í‹°ìƒ·
  const BETWEEN_PAGES_SECONDS = 10;      // ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ê¸¸ ì‹œê°„(ìŒì„± ì¹´ìš´íŠ¸ë‹¤ìš´ í¬í•¨)
  const RETRY_SECONDS = 5;               // OCR ë¶ˆëŸ‰ ì‹œ ê°™ì€ í˜ì´ì§€ ì¬ì‹œë„ê¹Œì§€ ì‹œê°„
  const MAX_RETRY_SAME_PAGE = 999;       // â€œì™„ì „ ìë™â€ ìš”êµ¬ â†’ ì‚¬ì‹¤ìƒ ë¬´í•œ ì¬ì‹œë„
  const OCR_CONF_THRESHOLD = 0.78;       // OCR.Space confê°€ ë“¤ì–´ì˜¬ ê²½ìš° í•©ê²© ê¸°ì¤€(ìƒí™© ë”°ë¼ ì¡°ì ˆ)
  const MIN_TEXT_LEN = 220;              // ë„ˆë¬´ ì§§ìœ¼ë©´ ì‹¤íŒ¨ë¡œ ê°„ì£¼(ìƒí™© ë”°ë¼ ì¡°ì ˆ)

  // í’€ì´ í˜¸ì¶œ: 10ë¬¸í•­ì”©
  const SOLVE_CHUNK_SIZE = 10;

  // iOS ì‚¬íŒŒë¦¬ TTS ì•ˆì •í™”ë¥¼ ìœ„í•´ ë„ˆë¬´ ê¸´ utteranceë¥¼ í”¼í•˜ëŠ” í¸ì´ ë‚«ë‹¤.
  const TTS_RATE = 0.95;
  const TTS_LANG = "ko-KR";

  // ====== ìƒíƒœ ======
  let stream = null;
  let running = false;
  let phase = "IDLE"; // IDLE | OCRING | VALIDATING | SOLVING | SPEAKING
  let currentPageIndex = 1; // 1-based capture order
  let retryCountSamePage = 0;

  // pages[1..] = { pageIndex, bestText, bestConf, bestScore, rawShots: [...] }
  const pages = [];

  // ====== DOM ======
  const video = document.getElementById("video");
  const statusEl = document.getElementById("status");
  const pagePill = document.getElementById("pagePill");
  const phasePill = document.getElementById("phasePill");
  const ocrAll = document.getElementById("ocrAll");

  const btnAuto = document.getElementById("btnAuto");
  const btnStop = document.getElementById("btnStop");
  const btnTestVoice = document.getElementById("btnTestVoice");

  // ====== ìœ í‹¸ ======
  function setPhase(p) {
    phase = p;
    phasePill.textContent = p;
  }
  function setStatus(msg) {
    statusEl.textContent = msg;
  }
  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  // iOSì—ì„œ ì²« TTSëŠ” ë°˜ë“œì‹œ ì‚¬ìš©ì ì œìŠ¤ì²˜ ì´í›„ê°€ ì•ˆì •ì ì´ë‹¤.
  async function speak(text) {
    try { window.speechSynthesis.cancel(); } catch {}
    return new Promise((resolve) => {
      const u = new SpeechSynthesisUtterance(text);
      u.lang = TTS_LANG;
      u.rate = TTS_RATE;
      u.pitch = 1.0;
      u.onend = () => resolve();
      u.onerror = () => resolve(); // ëŠê¸°ë”ë¼ë„ íë¦„ì€ ìœ ì§€
      window.speechSynthesis.speak(u);
    });
  }

  async function speakCountdown(seconds) {
    // "10, 9, ... 1" ì„ ë§í•œë‹¤.
    for (let i = seconds; i >= 1; i--) {
      if (!running) return;
      await speak(String(i));
      // ìˆ«ì ì½ê¸° ì‚¬ì´ í…œí¬
      await sleep(120);
    }
  }

  function normalizeForMarker(s) {
    // ê³µë°±/ê°œí–‰ ì œê±°, íŠ¹ìˆ˜ë¬¸ì ì œê±°, ì†Œë¬¸ìí™”(ì˜ë¬¸ ëŒ€ë¹„)
    return (s || "")
      .replace(/\s+/g, "")
      .replace(/[^\p{L}\p{N}]/gu, "")
      .toLowerCase();
  }

  // Levenshtein distance (ì§§ì€ ë¬¸ìì—´ êµ¬ê°„ ë¹„êµì—ë§Œ ì‚¬ìš©)
  function levenshtein(a, b) {
    if (a === b) return 0;
    const al = a.length, bl = b.length;
    if (al === 0) return bl;
    if (bl === 0) return al;
    const dp = Array.from({ length: al + 1 }, () => new Array(bl + 1).fill(0));
    for (let i = 0; i <= al; i++) dp[i][0] = i;
    for (let j = 0; j <= bl; j++) dp[0][j] = j;
    for (let i = 1; i <= al; i++) {
      for (let j = 1; j <= bl; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        dp[i][j] = Math.min(
          dp[i - 1][j] + 1,
          dp[i][j - 1] + 1,
          dp[i - 1][j - 1] + cost
        );
      }
    }
    return dp[al][bl];
  }

  function hasCompletionMarker(text) {
    // ê°•í•œ ê·œì¹™: "ì´¬ì˜ì™„ë£Œ" ì •í™• í¬í•¨
    // ë³´ì¡°ë£°1: "ì´¬ì˜"ê³¼ "ì™„ë£Œ"ê°€ ê°€ê¹Œì´ ì¡´ì¬
    // ë³´ì¡°ë£°2: "ì´¬ì˜ì™„ë£Œ"ì™€ í¸ì§‘ê±°ë¦¬ <= 1ì¸ 4ê¸€ì êµ¬ê°„ ì¡´ì¬
    // ë³´ì¡°ë£°3: DONE/END ê°™ì´ ì˜ì–´ í† í°ë„ í—ˆìš©(ê¶Œì¥)
    const norm = normalizeForMarker(text);

    if (norm.includes("ì´¬ì˜ì™„ë£Œ")) return true;
    if (norm.includes("ì´¬ì˜ì™„ë£Œdone") || norm.includes("ì´¬ì˜ì™„ë£Œend")) return true;
    if (norm.includes("done") && norm.includes("ì´¬ì˜") && norm.includes("ì™„ë£Œ")) return true;

    const idx1 = norm.indexOf("ì´¬ì˜");
    const idx2 = norm.indexOf("ì™„ë£Œ");
    if (idx1 !== -1 && idx2 !== -1 && Math.abs(idx2 - idx1) <= 10) return true;

    // í¸ì§‘ê±°ë¦¬ ë³´ì¡°ë£°: norm ì „ì²´ì—ì„œ 4ê¸€ì êµ¬ê°„ì„ í›‘ëŠ”ë‹¤(ì§§ì•„ì„œ ë¶€ë‹´ ì ìŒ)
    const target = "ì´¬ì˜ì™„ë£Œ";
    for (let i = 0; i <= norm.length - target.length; i++) {
      const sub = norm.slice(i, i + target.length);
      if (levenshtein(sub, target) <= 1) return true;
    }
    return false;
  }

  function makeCanvasFromVideo() {
    const canvas = document.createElement("canvas");
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    // ë¹„ë””ì˜¤ê°€ ì•„ì§ ì¤€ë¹„ ì•ˆ ëë‹¤ë©´ ì‹¤íŒ¨
    if (!vw || !vh) return null;

    // iOS ë©”ëª¨ë¦¬ ì´ìŠˆë¥¼ ì¤„ì´ê¸° ìœ„í•´ ë„ˆë¬´ í° ìº”ë²„ìŠ¤ëŠ” ì œí•œí•œë‹¤.
    const maxW = 1600;
    const scale = Math.min(1, maxW / vw);
    canvas.width = Math.floor(vw * scale);
    canvas.height = Math.floor(vh * scale);

    const ctx = canvas.getContext("2d", { alpha: false });
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    return canvas;
  }

  function canvasToJpegBase64(canvas) {
    // data:image/jpeg;base64,xxxx
    return canvas.toDataURL("image/jpeg", 0.92);
  }

  function textQualityScore(text) {
    // OCR í’ˆì§ˆ íœ´ë¦¬ìŠ¤í‹± ì ìˆ˜(0~1 ê·¼ì‚¬)
    // - ê¸¸ì´, ì„ íƒì§€ ê¸°í˜¸(â‘ ~â‘¤) ì¡´ì¬, ë¬¸í•­ ë²ˆí˜¸(01~50) ì¡´ì¬ ë¹„ìœ¨ ë“±ì„ ë°˜ì˜
    const t = (text || "").trim();
    if (!t) return 0;

    const len = t.length;
    const lenScore = Math.max(0, Math.min(1, (len - 150) / 1200)); // ëŒ€ì¶© 150~1350ì—ì„œ 0~1

    // â‘ ~â‘¤ ì¶œí˜„
    const circled = ["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"];
    let circCount = 0;
    for (const c of circled) if (t.includes(c)) circCount++;
    const choiceScore = circCount >= 5 ? 1 : (circCount / 5);

    // ë¬¸í•­ ë²ˆí˜¸(01~50) ì¶œí˜„
    // ë„ˆë¬´ ê³µê²©ì ì´ë©´ ì˜¤íƒì´ ìƒê¸°ë¯€ë¡œ ê°€ë³ê²Œë§Œ ë°˜ì˜
    let qHits = 0;
    for (let i = 1; i <= 50; i++) {
      const n2 = String(i).padStart(2,"0");
      const re = new RegExp(`(^|\\D)${n2}(\\D)`);
      if (re.test(t)) qHits++;
    }
    const qScore = Math.max(0, Math.min(1, qHits / 10)); // í˜ì´ì§€ì— 10ê°œì¯¤ ìˆìœ¼ë©´ 1

    // ì˜ì–´ ë¹„ìœ¨(ë„ˆë¬´ í•œê¸€/ê¸°í˜¸ë§Œì´ë©´ ê¹¨ì¡Œì„ ê°€ëŠ¥ì„±)
    const letters = (t.match(/[A-Za-z]/g) || []).length;
    const ratio = letters / Math.max(1, len);
    const engScore = Math.max(0, Math.min(1, (ratio - 0.08) / 0.25)); // 0.08~0.33 ì‚¬ì´ì—ì„œ 0~1

    // ì¢…í•©(ê°€ì¤‘ì¹˜)
    const score = 0.35*lenScore + 0.25*choiceScore + 0.2*qScore + 0.2*engScore;
    return Math.max(0, Math.min(1, score));
  }

  function combinedScore(conf, text) {
    // conf: 0~1 ë˜ëŠ” null
    const q = textQualityScore(text);
    if (typeof conf === "number" && isFinite(conf)) {
      return 0.62*conf + 0.38*q;
    }
    return q;
  }

  async function callOCR(imageDataUrl) {
    const res = await fetch("/.netlify/functions/ocr", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ imageDataUrl })
    });
    if (!res.ok) {
      const t = await res.text().catch(() => "");
      throw new Error(`OCR HTTP ${res.status}: ${t.slice(0,200)}`);
    }
    const data = await res.json();
    if (!data || !data.ok) {
      throw new Error(data?.error || "OCR failed");
    }
    return data; // {ok, text, conf}
  }

  function appendDebugAllText() {
    let out = "[OCR ëˆ„ì ]\n";
    for (let i = 1; i < pages.length; i++) {
      const p = pages[i];
      out += `\n[í˜ì´ì§€ ${p.pageIndex}] conf=${(p.bestConf ?? "null")} score=${p.bestScore.toFixed(3)}\n`;
      out += (p.bestText || "").trim() + "\n";
    }
    ocrAll.value = out.trim();
  }

  async function ensureCamera() {
    if (stream) return;
    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    });
    video.srcObject = stream;

    // video ë©”íƒ€ ì¤€ë¹„ ëŒ€ê¸°
    await new Promise((resolve) => {
      const onReady = () => resolve();
      if (video.readyState >= 2) resolve();
      else video.addEventListener("loadedmetadata", onReady, { once: true });
    });

    // ìë™ ì¬ìƒ ì•ˆì •í™” ì•½ê°„ ëŒ€ê¸°
    await sleep(250);
  }

  async function stopAll() {
    running = false;
    setPhase("IDLE");
    btnAuto.disabled = false;
    btnStop.disabled = true;
    btnStop.textContent = "â›” ì •ì§€";
    try { window.speechSynthesis.cancel(); } catch {}

    // ì¹´ë©”ë¼ëŠ” ìœ ì§€(ì›í•˜ë©´ ë„ê²Œ ë³€ê²½ ê°€ëŠ¥)
    setStatus("ì •ì§€í–ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ â€˜ìë™ OCR ì‹œì‘â€™ì„ ëˆ„ë¥´ë¼.");
  }

  // ====== OCR ë£¨í”„(í˜ì´ì§€ ì´¬ì˜) ======
  async function ocrOnePage(pageIndex) {
    pagePill.textContent = String(pageIndex);

    // ë©€í‹°ìƒ·
    const shots = [];
    for (let s = 1; s <= SHOTS_PER_PAGE; s++) {
      if (!running) return null;

      const canvas = makeCanvasFromVideo();
      if (!canvas) throw new Error("ì¹´ë©”ë¼ í”„ë ˆì„ì„ ìº¡ì²˜í•  ìˆ˜ ì—†ë‹¤(ë¹„ë””ì˜¤ ì¤€ë¹„ ì „).");

      const imageDataUrl = canvasToJpegBase64(canvas);

      setStatus(`í˜ì´ì§€ ${pageIndex} OCR ì¤‘ì´ë‹¤. (ìƒ· ${s}/${SHOTS_PER_PAGE})`);
      let ocr;
      try {
        ocr = await callOCR(imageDataUrl);
      } catch (e) {
        // OCR API ìˆœê°„ ì˜¤ë¥˜ë„ ìˆì„ ìˆ˜ ìˆìœ¼ë‹ˆ ìƒ· ë‹¨ìœ„ë¡œëŠ” ë„˜ì–´ê°€ë˜ ê¸°ë¡
        shots.push({ ok: false, error: String(e), conf: null, score: 0, text: "" });
        continue;
      }

      const conf = (typeof ocr.conf === "number" && isFinite(ocr.conf)) ? ocr.conf : null;
      const text = (ocr.text || "");
      const score = combinedScore(conf, text);

      shots.push({ ok: true, conf, score, text });
      // ìƒ· ì‚¬ì´ ì•½ê°„ ëŒ€ê¸°(ì—°ì† í˜¸ì¶œ í­ì£¼ ë°©ì§€)
      await sleep(120);
    }

    // best ì„ íƒ
    let best = null;
    for (const sh of shots) {
      if (!sh.ok) continue;
      if (!best || sh.score > best.score) best = sh;
    }
    if (!best) {
      return { ok: false, reason: "OCR ê²°ê³¼ê°€ ì „ë¶€ ì‹¤íŒ¨í–ˆë‹¤.", bestConf: null, bestScore: 0, bestText: "", shots };
    }

    return {
      ok: true,
      bestConf: best.conf,
      bestScore: best.score,
      bestText: best.text,
      shots
    };
  }

  function pagePassesThreshold(bestText, bestConf, bestScore) {
    const t = (bestText || "").trim();
    if (t.length < MIN_TEXT_LEN) return false;
    // confê°€ ìˆìœ¼ë©´ conf ê¸°ì¤€, ì—†ìœ¼ë©´ score ê¸°ì¤€ìœ¼ë¡œ íŒë‹¨
    if (typeof bestConf === "number") {
      return bestConf >= OCR_CONF_THRESHOLD;
    }
    return bestScore >= 0.62; // conf ì—†ì„ ë•Œì˜ ë³´ìˆ˜ì  ê¸°ì¤€
  }

  async function handlePageLoopSequential() {
    setPhase("OCRING");
    retryCountSamePage = 0;

    while (running) {
      setStatus(`í˜ì´ì§€ ${currentPageIndex}ë¥¼ ì¸ì‹í•  ì¤€ë¹„ë¥¼ í•˜ë¼.`);
      await sleep(150);

      const result = await ocrOnePage(currentPageIndex);
      if (!result) return; // stopped

      const { ok, bestText, bestConf, bestScore, shots } = result;

      if (!ok || !pagePassesThreshold(bestText, bestConf, bestScore)) {
        retryCountSamePage++;
        const confMsg = (typeof bestConf === "number") ? `ì‹ ë¢°ë„ ${Math.round(bestConf*100)}%` : `í’ˆì§ˆì ìˆ˜ ${bestScore.toFixed(2)}`;
        setStatus(`í˜ì´ì§€ ${currentPageIndex} OCR ë¶ˆí•©ê²©ì´ë‹¤. (${confMsg})\në‹¤ì‹œ ì´¬ì˜ì„ ìš”êµ¬í•œë‹¤.`);
        await speak(`ì§€ê¸ˆ í˜ì´ì§€ ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${RETRY_SECONDS}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
        await speakCountdown(RETRY_SECONDS);
        if (!running) return;
        // ê°™ì€ í˜ì´ì§€ ë‹¤ì‹œ ì‹œë„
        continue;
      }

      // ì €ì¥(1-based)
      pages[currentPageIndex] = {
        pageIndex: currentPageIndex,
        bestText,
        bestConf,
        bestScore,
        shots
      };
      appendDebugAllText();

      // ì´¬ì˜ì™„ë£Œ ê°ì§€
      if (hasCompletionMarker(bestText)) {
        setStatus(`â€œì´¬ì˜ì™„ë£Œâ€ë¥¼ ê°ì§€í–ˆë‹¤. OCRì„ ì¢…ë£Œí•˜ê³  í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.`);
        await speak("ì´¬ì˜ ì™„ë£Œë¥¼ í™•ì¸í–ˆìŠµë‹ˆë‹¤. ì´ì œ ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
        break;
      }

      // ë‹¤ìŒ í˜ì´ì§€ ì•ˆë‚´
      await speak(`ì´ í˜ì´ì§€ ì¸ì‹ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”. ${BETWEEN_PAGES_SECONDS}ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¥¼ ì¸ì‹í•©ë‹ˆë‹¤.`);
      await speakCountdown(BETWEEN_PAGES_SECONDS);
      if (!running) return;

      currentPageIndex++;
    }

    if (!running) return;

    // OCR ì¢…ë£Œ â†’ ê²€ì¦/ë³´ì • â†’ í’€ì´
    await validateAndAutofixThenSolve();
  }

  // ====== ë¬¸í•­ íŒŒì‹±/ê²€ì¦ ======
  function normalizeTextForParsing(t) {
    return (t || "")
      .replace(/\r/g, "\n")
      .replace(/[ \t]+/g, " ")
      .replace(/\n{3,}/g, "\n\n");
  }

  function parseQuestionsFromFullText(fullText) {
    // ëª©í‘œ: 1~50 ë¬¸í•­(ì„±ëŒ€/í™ìµ í¸ì…ì˜ì–´) íŒŒì‹±
    // ê°€ì •: ë¬¸í•­ë²ˆí˜¸ëŠ” 01~50 ë˜ëŠ” 1~50 í˜•íƒœê°€ ë“±ì¥
    // ì„ íƒì§€ëŠ” â‘ ~â‘¤ê°€ ì£¼ë¡œ ì“°ì„. (OCRì´ 1) í˜•íƒœë¡œ ê¹¨ì§ˆ ìˆ˜ ìˆì–´ ì¼ë¶€ ë³´ì •)
    const text = normalizeTextForParsing(fullText);

    // (1) ë³´ê¸° ê¸°í˜¸ ë³´ì •(ê°€ë²¼ìš´ ìˆ˜ì¤€)
    // "1)" "2)" ... ê°€ ìˆì„ ë•Œ â‘ ..â‘¤ë¡œ ë°”ê¾¸ëŠ” ë³´ì •(ì˜¤íƒ ë°©ì§€ ìœ„í•´ ë§¤ìš° ì œí•œì ìœ¼ë¡œ)
    let t = text;
    t = t.replace(/(^|\s)1\)(?=\S)/g, "$1â‘ ");
    t = t.replace(/(^|\s)2\)(?=\S)/g, "$1â‘¡");
    t = t.replace(/(^|\s)3\)(?=\S)/g, "$1â‘¢");
    t = t.replace(/(^|\s)4\)(?=\S)/g, "$1â‘£");
    t = t.replace(/(^|\s)5\)(?=\S)/g, "$1â‘¤");

    // (2) ë¬¸í•­ ì‹œì‘ ì¸ë±ìŠ¤ ì°¾ê¸°: 01~50 ë˜ëŠ” 1~50 (ë„ˆë¬´ ë§ì€ ìˆ«ì ì˜¤íƒ ë°©ì§€)
    // â€œë¬¸í•­ë²ˆí˜¸ ë’¤ì— ê³§ë°”ë¡œ ì„ íƒì§€ â‘ ê°€ ê°€ê¹Œì´ ë“±ì¥â€í•˜ëŠ” íŒ¨í„´ì„ ìš°ì„ ì‹œí•œë‹¤.
    const starts = [];
    for (let n = 1; n <= 50; n++) {
      const nn2 = String(n).padStart(2, "0");
      const patterns = [
        new RegExp(`(^|\\n)\\s*${nn2}\\s+(?=\\S)`, "g"),
        new RegExp(`(^|\\n)\\s*${n}\\s+(?=\\S)`, "g")
      ];
      for (const re of patterns) {
        let m;
        while ((m = re.exec(t)) !== null) {
          const idx = m.index + (m[1] ? m[1].length : 0);
          // ê°€ê¹Œìš´ ë²”ìœ„ì— â‘ ê°€ ìˆìœ¼ë©´ ë” ì‹ ë¢°
          const window = t.slice(m.index, Math.min(t.length, m.index + 600));
          const hasChoice = window.includes("â‘ ") && window.includes("â‘¡") && window.includes("â‘¢");
          starts.push({ n, idx: m.index, bonus: hasChoice ? 1 : 0 });
        }
      }
    }

    // ì •ë ¬ í›„ ì¤‘ë³µ ì œê±°(ê°€ê¹Œìš´ ìœ„ì¹˜ì˜ ì¤‘ë³µ ì‹œì‘ì€ í•˜ë‚˜ë¡œ)
    starts.sort((a,b) => (a.idx - b.idx) || (b.bonus - a.bonus));
    const filtered = [];
    for (const s of starts) {
      const last = filtered[filtered.length - 1];
      if (last && Math.abs(s.idx - last.idx) < 6) continue;
      filtered.push(s);
    }

    // (3) ì‹¤ì œë¡œëŠ” ìˆœì„œê°€ ë’¤ì„ì¼ ìˆ˜ ìˆìœ¼ë‹ˆ,
    // ì¸ë±ìŠ¤ ìˆœìœ¼ë¡œ segmentë¥¼ ë§Œë“  ë‹¤ìŒ, segment ë‚´ë¶€ì—ì„œ â€œë¬¸í•­ë²ˆí˜¸â€ë¥¼ ì¬í™•ì¸í•œë‹¤.
    const segments = [];
    for (let i = 0; i < filtered.length; i++) {
      const start = filtered[i].idx;
      const end = (i + 1 < filtered.length) ? filtered[i+1].idx : t.length;
      const seg = t.slice(start, end).trim();
      segments.push(seg);
    }

    // (4) segmentì—ì„œ ë¬¸í•­ë²ˆí˜¸/ì§€ë¬¸/ì„ ì§€ ì¶”ì¶œ
    const questions = [];
    const issues = []; // {type, n, reason}
    const seen = new Set();

    for (const seg of segments) {
      // seg ì‹œì‘ì˜ ë²ˆí˜¸ ì½ê¸°
      const m = seg.match(/^\s*(0?[1-9]|[1-4]\d|50)\b/);
      if (!m) continue;
      const n = Number(m[1]);
      if (!(n >= 1 && n <= 50)) continue;
      if (seen.has(n)) continue;
      seen.add(n);

      // ì„ íƒì§€ split
      const idx1 = seg.indexOf("â‘ ");
      const idx2 = seg.indexOf("â‘¡");
      const idx3 = seg.indexOf("â‘¢");
      const idx4 = seg.indexOf("â‘£");
      const idx5 = seg.indexOf("â‘¤");

      if ([idx1,idx2,idx3,idx4,idx5].some(x => x === -1)) {
        issues.push({ type: "choices_missing", n, reason: "ì„ íƒì§€(â‘ ~â‘¤) ì¼ë¶€ê°€ ì—†ë‹¤." });
        questions.push({ n, stem: seg.slice(0, Math.min(seg.length, 260)).trim(), choices: [] });
        continue;
      }

      // stem: ë²ˆí˜¸~â‘  ì „ê¹Œì§€
      const stem = seg.slice(m[0].length, idx1).trim();

      const c1 = seg.slice(idx1 + 1, idx2).trim();
      const c2 = seg.slice(idx2 + 1, idx3).trim();
      const c3 = seg.slice(idx3 + 1, idx4).trim();
      const c4 = seg.slice(idx4 + 1, idx5).trim();
      const c5 = seg.slice(idx5 + 1).trim();

      const choices = [c1,c2,c3,c4,c5].map(s => s.replace(/\s+/g," ").trim());

      // ê¸°ë³¸ ê²€ì¦
      if (stem.length < 8) issues.push({ type: "stem_short", n, reason: "ë¬¸í•­ ë³¸ë¬¸ì´ ë„ˆë¬´ ì§§ë‹¤." });
      const tooShort = choices.filter(c => c.length < 3).length;
      if (tooShort > 0) issues.push({ type: "choice_short", n, reason: "ì„ íƒì§€ ì¤‘ ë„ˆë¬´ ì§§ì€ í•­ëª©ì´ ìˆë‹¤." });

      questions.push({ n, stem, choices });
    }

    // ëˆ„ë½ ë¬¸í•­ ì²´í¬(ìµœì†Œ 30ê°œ ì´ìƒì€ ë‚˜ì™€ì•¼ ì •ìƒ. ì‹œí—˜ì€ 50ë¬¸í•­)
    if (questions.length < 40) {
      issues.push({ type: "too_few_questions", n: null, reason: `ë¬¸í•­ íŒŒì‹± ê°œìˆ˜ê°€ ë„ˆë¬´ ì ë‹¤(${questions.length}). OCRì´ ë’¤ì„ì˜€ê±°ë‚˜ ëˆ„ë½ ê°€ëŠ¥ì„±ì´ í¬ë‹¤.` });
    }

    // ì •ë ¬
    questions.sort((a,b) => a.n - b.n);

    return { questions, issues, normalizedText: t };
  }

  function findPageForQuestion(pagesArr, qNumber) {
    // í˜ì´ì§€ í…ìŠ¤íŠ¸ì—ì„œ í•´ë‹¹ ë¬¸í•­ë²ˆí˜¸(01~50)ê°€ ë“±ì¥í•˜ê³  â‘ ê°€ ê·¼ì²˜ì— ìˆëŠ” í˜ì´ì§€ë¥¼ ì°¾ëŠ”ë‹¤.
    const n2 = String(qNumber).padStart(2,"0");
    const re1 = new RegExp(`(^|\\D)${n2}(\\D)`);
    const re2 = new RegExp(`(^|\\D)${qNumber}(\\D)`);
    for (let i = 1; i < pagesArr.length; i++) {
      const txt = pagesArr[i]?.bestText || "";
      if (!txt) continue;
      const window = txt.slice(0, 5000);
      if ((re1.test(window) || re2.test(window)) && window.includes("â‘ ")) return i;
    }
    // ëª» ì°¾ìœ¼ë©´ ë§ˆì§€ë§‰ ìª½ì„ ë°˜í™˜(ë³´ìˆ˜ì )
    return Math.max(1, pagesArr.length - 1);
  }

  async function recaptureSpecificPage(pageIndex) {
    currentPageIndex = pageIndex;
    pagePill.textContent = String(pageIndex);

    await speak(`ì§€ê¸ˆë¶€í„° ${pageIndex}í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤. í•´ë‹¹ í˜ì´ì§€ë¥¼ í™”ë©´ì— ë³´ì—¬ ì£¼ì„¸ìš”. ${BETWEEN_PAGES_SECONDS}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
    await speakCountdown(BETWEEN_PAGES_SECONDS);
    if (!running) return false;

    // ê°™ì€ í˜ì´ì§€ ì¬ì´¬ì˜ë„ ë©€í‹°ìƒ·/í’ˆì§ˆê²€ì‚¬ ì ìš©
    retryCountSamePage = 0;
    while (running) {
      const result = await ocrOnePage(pageIndex);
      if (!result) return false;

      const { ok, bestText, bestConf, bestScore, shots } = result;

      if (!ok || !pagePassesThreshold(bestText, bestConf, bestScore)) {
        retryCountSamePage++;
        const confMsg = (typeof bestConf === "number") ? `ì‹ ë¢°ë„ ${Math.round(bestConf*100)}%` : `í’ˆì§ˆì ìˆ˜ ${bestScore.toFixed(2)}`;
        setStatus(`ì¬ì´¬ì˜(í˜ì´ì§€ ${pageIndex}) OCR ë¶ˆí•©ê²©ì´ë‹¤. (${confMsg})\në‹¤ì‹œ ì´¬ì˜ì„ ìš”êµ¬í•œë‹¤.`);
        await speak(`ì§€ê¸ˆ í˜ì´ì§€ ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${RETRY_SECONDS}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
        await speakCountdown(RETRY_SECONDS);
        continue;
      }

      pages[pageIndex] = { pageIndex, bestText, bestConf, bestScore, shots };
      appendDebugAllText();
      await speak(`í˜ì´ì§€ ${pageIndex} ì¬ì´¬ì˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
      return true;
    }
    return false;
  }

  async function validateAndAutofixThenSolve() {
    setPhase("VALIDATING");

    while (running) {
      // fullText ìƒì„±
      let fullText = "";
      for (let i = 1; i < pages.length; i++) {
        const p = pages[i];
        if (!p?.bestText) continue;
        // ì´¬ì˜ì™„ë£Œ ì´í›„ëŠ” ì˜ë¼ë‚¸ë‹¤(í˜¹ì‹œ marker í˜ì´ì§€ì— ë¤ì´ ì„ì˜€ì„ ë•Œ)
        const txt = p.bestText;
        fullText += `\n\n[í˜ì´ì§€ ${i}]\n` + txt;
      }

      const { questions, issues } = parseQuestionsFromFullText(fullText);

      // â€œì¹˜ëª…ì â€ ì´ìŠˆ íŒë‹¨: ë¬¸í•­ ìˆ˜ ë„ˆë¬´ ì ê±°ë‚˜, choices_missingê°€ ë‹¤ìˆ˜ë©´ ì¬ì´¬ì˜
      const missingChoices = issues.filter(x => x.type === "choices_missing");
      const tooFew = issues.some(x => x.type === "too_few_questions");

      if (!tooFew && missingChoices.length === 0) {
        setStatus(`ê²€ì¦ í†µê³¼. íŒŒì‹±ëœ ë¬¸í•­ ìˆ˜: ${questions.length}ê°œ. ìë™ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.`);
        await speak("ê²€ì¦ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
        await solveQuestionsInChunks(questions);
        return;
      }

      // ì¬ì´¬ì˜ ëŒ€ìƒ í˜ì´ì§€ ì„ ì •:
      // 1) choices_missingê°€ ìˆìœ¼ë©´ í•´ë‹¹ ë¬¸í•­ì´ ìˆëŠ” í˜ì´ì§€ë¶€í„° ì¬ì´¬ì˜
      // 2) tooFewë©´ ë§ˆì§€ë§‰ 2~3í˜ì´ì§€ ì¤‘ í•˜ë‚˜ê°€ ëˆ„ë½/ë’¤ì„ì„ ê°€ëŠ¥ â†’ ìµœê·¼ í˜ì´ì§€ë¶€í„° ì¬ì´¬ì˜
      let targetPage = null;
      let reason = "";

      if (missingChoices.length > 0) {
        // ê°€ì¥ ì• ë¬¸í•­ë¶€í„° ì²˜ë¦¬
        const qn = missingChoices[0].n;
        targetPage = findPageForQuestion(pages, qn);
        reason = `${qn}ë²ˆ ë¬¸ì œ ì¸ì‹ì´ ë¹„ì •ìƒ`;
      } else {
        targetPage = Math.max(1, pages.length - 1);
        reason = `ë¬¸í•­ íŒŒì‹± ê°œìˆ˜ ë¶€ì¡±`;
      }

      setStatus(`ê²€ì¦ ì‹¤íŒ¨: ${reason}. í˜ì´ì§€ ${targetPage} ì¬ì´¬ì˜ì„ ì§„í–‰í•œë‹¤.`);
      await speak(`ê²€ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ${reason}ì…ë‹ˆë‹¤. ${targetPage}í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”.`);
      const ok = await recaptureSpecificPage(targetPage);
      if (!ok) return;

      // ì¬ì´¬ì˜ í›„ ë£¨í”„ ê³„ì†(ìë™)
      await sleep(200);
    }
  }

  // ====== ìë™ í’€ì´(10ë¬¸í•­ì”© í˜¸ì¶œ) ======
  function buildSolvePayloadChunk(chunk) {
    // solve.jsë¡œ ë³´ë‚¼ êµ¬ì¡°
    return {
      items: chunk.map(q => ({
        n: q.n,
        stem: q.stem,
        choices: q.choices
      }))
    };
  }

  function normalizeAnswerValue(v) {
    // 1~5 ìˆ«ìë¡œ ì •ê·œí™”(ë¬¸ì/ê¸°í˜¸ ëŒ€ì‘)
    if (v == null) return null;
    const s = String(v).trim();
    if (/^[1-5]$/.test(s)) return Number(s);
    // "â‘¢" ê°™ì€ ê²½ìš°
    const map = { "â‘ ":1,"â‘¡":2,"â‘¢":3,"â‘£":4,"â‘¤":5 };
    if (map[s]) return map[s];
    // "3ë²ˆ" í˜•íƒœ
    const m = s.match(/([1-5])/);
    if (m) return Number(m[1]);
    return null;
  }

  async function callSolve(itemsChunk) {
    const res = await fetch("/.netlify/functions/solve", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify(buildSolvePayloadChunk(itemsChunk))
    });
    if (!res.ok) {
      const t = await res.text().catch(() => "");
      throw new Error(`SOLVE HTTP ${res.status}: ${t.slice(0,200)}`);
    }
    const data = await res.json();
    if (!data || !data.ok) {
      throw new Error(data?.error || "SOLVE failed");
    }
    return data.answers; // { "1":3, ... }
  }

  async function solveQuestionsInChunks(questions) {
    setPhase("SOLVING");

    // 1~50ë§Œ ëŒ€ìƒìœ¼ë¡œ(í˜¹ì‹œ íŒŒì‹±ì´ ë” ë§ìœ¼ë©´ ìƒí•œ)
    const qs = questions.filter(q => q.n >= 1 && q.n <= 50 && q.choices && q.choices.length === 5);

    // chunk ë¶„í• 
    const chunks = [];
    for (let i = 0; i < qs.length; i += SOLVE_CHUNK_SIZE) {
      chunks.push(qs.slice(i, i + SOLVE_CHUNK_SIZE));
    }

    const answers = {}; // number -> 1..5
    for (let ci = 0; ci < chunks.length; ci++) {
      if (!running) return;
      const chunk = chunks[ci];
      const range = `${chunk[0].n}~${chunk[chunk.length-1].n}`;

      setStatus(`ìë™ í’€ì´ ì¤‘ì´ë‹¤. (${ci+1}/${chunks.length}) ë¬¸í•­ ${range}`);
      await speak(`ë¬¸í•­ ${range}ë¥¼ í’€ì´í•©ë‹ˆë‹¤.`);

      // ìë™ ì¬ì‹œë„
      let done = false;
      let attempt = 0;
      while (running && !done) {
        attempt++;
        try {
          const resAns = await callSolve(chunk);
          // ë³‘í•© + ëˆ„ë½ ì²´í¬
          for (const q of chunk) {
            const v = normalizeAnswerValue(resAns?.[String(q.n)]);
            if (!v) throw new Error(`ì‘ë‹µì— ${q.n}ë²ˆ ì •ë‹µì´ ì—†ë‹¤/í˜•ì‹ì´ ì´ìƒí•˜ë‹¤.`);
            answers[q.n] = v;
          }
          done = true;
        } catch (e) {
          setStatus(`í’€ì´ ì‹¤íŒ¨(ë¬¸í•­ ${range}) - ì¬ì‹œë„í•œë‹¤.\nì›ì¸: ${String(e)}`);
          await speak(`ë¬¸í•­ ${range} í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.`);
          // ì•½ê°„ ëŒ€ê¸° í›„ ì¬ì‹œë„
          await sleep(900);
          // â€œì™„ì „ ìë™â€ ìš”êµ¬ â†’ ê³„ì† ì¬ì‹œë„(ì‹¤ì§ˆ ë¬´í•œ)
        }
      }
    }

    // TTSë¡œ ì •ë‹µ ì½ê¸°
    await speakAnswers(answers);
  }

  async function speakAnswers(answers) {
    setPhase("SPEAKING");
    setStatus("ì •ë‹µì„ ìŒì„±ìœ¼ë¡œ ì½ëŠ”ë‹¤.");

    // 1~50 ìˆœì„œëŒ€ë¡œ ì½ë˜, ì¡´ì¬í•˜ëŠ” ê²ƒë§Œ
    for (let n = 1; n <= 50; n++) {
      if (!running) return;
      const a = answers[n];
      if (!a) continue;
      // â€œì •ë‹µ ì •í™•â€ì€ ëª¨ë¸ ì„±ëŠ¥/ë¬¸ì œ ë‚œì´ë„ì— ì¢Œìš°ëœë‹¤(ë³´ì¥ ë¶ˆê°€).
      await speak(`${n}ë²ˆ ì •ë‹µì€ ${a}ë²ˆì…ë‹ˆë‹¤.`);
      await sleep(180);
    }

    await speak("ì •ë‹µ ë‚­ë…ì´ ëë‚¬ìŠµë‹ˆë‹¤.");
    setStatus("ì™„ë£Œ.");
    setPhase("IDLE");
    btnAuto.disabled = false;
    btnStop.disabled = true;
  }

  // ====== ë²„íŠ¼ í•¸ë“¤ëŸ¬ ======
  btnTestVoice.addEventListener("click", async () => {
    await speak("ìŒì„± í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤. ì§€ê¸ˆë¶€í„° ìë™ OCR ì‹œìŠ¤í…œì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
  });

  btnStop.addEventListener("click", async () => {
    await stopAll();
  });

  btnAuto.addEventListener("click", async () => {
    if (running) return;

    try {
      running = true;
      btnAuto.disabled = true;
      btnStop.disabled = false;
      btnStop.textContent = "â›” ì •ì§€";
      setPhase("OCRING");

      // ìƒíƒœ ì´ˆê¸°í™”
      pages.length = 0;
      currentPageIndex = 1;
      retryCountSamePage = 0;
      ocrAll.value = "";

      setStatus("ì¹´ë©”ë¼ë¥¼ ì—¬ëŠ” ì¤‘ì´ë‹¤â€¦");
      await ensureCamera();

      // iOSì—ì„œ ì˜¤ë””ì˜¤ ê¶Œí•œ/ì•ˆì •í™”ë¥¼ ìœ„í•´ ì²« ì•ˆë‚´ë¥¼ ì—¬ê¸°ì„œ ë§í•œë‹¤.
      await speak("ìë™ OCRì„ ì‹œì‘í•©ë‹ˆë‹¤. ì²« í˜ì´ì§€ë¥¼ í™”ë©´ì— ë³´ì—¬ ì£¼ì„¸ìš”.");

      await handlePageLoopSequential();
    } catch (e) {
      // ì¹˜ëª…ì  ì—ëŸ¬ ì²˜ë¦¬
      setStatus("ì¹˜ëª…ì  ì˜¤ë¥˜ê°€ ë°œìƒí–ˆë‹¤:\n" + String(e));
      try { await speak("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”."); } catch {}
      await stopAll();
    }
  });

})();
</script>
</body>
</html>
