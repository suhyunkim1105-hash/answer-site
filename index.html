

<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Auto OCR (누적) → Auto Solve + TTS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <!-- Tesseract v5 -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 10px;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    .wrap { max-width: 980px; margin: 0 auto; }
    #videoBox {
      position: relative;
      width: 100%;
      border: 1px solid #333;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
    }
    #video { width: 100%; height: auto; display: block; }
    #overlay {
      position: absolute;
      inset: 0;
      border: 2px solid rgba(0, 255, 0, 0.35);
      pointer-events: none;
    }
    #status {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #111;
      font-size: 13px;
      line-height: 1.45;
      white-space: pre-wrap;
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .panel {
      border: 1px solid #333;
      border-radius: 10px;
      background: #0b0b0b;
      padding: 10px;
    }
    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #cfcfcf;
      font-weight: 600;
    }
    textarea, pre {
      width: 100%;
      border: 1px solid #222;
      border-radius: 8px;
      background: #000;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 10px;
      margin: 0;
    }
    textarea { height: 240px; resize: vertical; }
    pre { min-height: 240px; white-space: pre-wrap; }
    .hint {
      margin-top: 6px;
      font-size: 12px;
      color: #aaa;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="videoBox">
      <video id="video" autoplay playsinline></video>
      <div id="overlay"></div>
    </div>

    <div id="status">초기화 중...</div>

    <!-- 배율(디지털 줌) 슬라이더: 줌 아웃 중심 (0.85 ~ 1.00) -->
    <div style="margin-top:10px; padding:10px; border:1px solid #333; border-radius:10px; background:#111;">
      <div style="font-size:13px; margin-bottom:6px; color:#cfcfcf;">배율(디지털 줌)</div>
      <div style="display:flex; gap:10px; align-items:center;">
        <!-- 기본값 1.00 = 최대 줌 아웃(종이 전체 보이게) -->
        <input id="zoomRange" type="range" min="0.85" max="1.00" step="0.01" value="1.00" style="flex:1;">
        <div id="zoomLabel" style="width:90px; font-size:12px; color:#aaa; text-align:right;">1.00</div>
      </div>
      <div style="margin-top:6px; font-size:12px; color:#888;">
        1.00 = 최대 줌 아웃(종이 전체), 0.85 = 살짝 확대. 기본은 1.00에 두고 시작한 뒤, 필요하면 0.90~0.95 정도로만 조절.
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <h3>누적 OCR 미리보기</h3>
        <textarea id="ocrPreview" readonly></textarea>
        <div class="hint">
          iOS 음성(TTS) 팁: 화면을 한 번 탭 + 무음모드 해제 + 볼륨 올리기.
        </div>
      </div>

      <div class="panel">
        <h3>답안</h3>
        <pre id="answerBox"></pre>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // 0) 설정값
  // =========================
  const OCR_INTERVAL_MS = 3000;

  // 글자수 기반 최소치(구조 인식이 우선이지만, 완전 짧은 건 막음)
  const MIN_SOLVE_LEN_EFFECTIVE = 900;

  // 권장 기준 2000자
  const TEXT_THRESHOLD_EFFECTIVE = 2000;

  // 부족 안내: 연속 5분
  const INSUFFICIENT_WARN_MS = 5 * 60 * 1000;

  // 최대 대기: 연속 8분이면 부족해도 자동풀이
  const MAX_WAIT_MS = 8 * 60 * 1000;

  // solve 함수 (solve.js는 {ocrText} 받는 버전 기준)
  const SOLVE_URL = "/.netlify/functions/solve";

  // OCR 언어
  const OCR_LANG = "kor+eng";

  // TTS
  const TTS_ENABLED = true;
  const TTS_RATE = 1.03;
  const TTS_PITCH = 1.0;
  const TTS_STATUS_COOLDOWN_MS = 15000;

  // 디지털 줌(크롭) - 줌 아웃 중심: 0.85 ~ 1.00
  let cropFactor = 1.00;  // 기본: 최대 줌 아웃(전체 프레임)
  const CROP_MIN = 0.85;
  const CROP_MAX = 1.00;

  // 중복 판정(같은 페이지 반복 OCR 흡수)
  const DUP_SIMILARITY = 0.75;

  // =========================
  // 1) DOM
  // =========================
  const video = document.getElementById("video");
  const statusEl = document.getElementById("status");
  const ocrPreviewEl = document.getElementById("ocrPreview");
  const answerBoxEl = document.getElementById("answerBox");

  const zoomRangeEl = document.getElementById("zoomRange");
  const zoomLabelEl = document.getElementById("zoomLabel");

  function setCropFactor(v) {
    const num = Number(v);
    if (!Number.isFinite(num)) return;

    cropFactor = Math.min(CROP_MAX, Math.max(CROP_MIN, num));

    if (zoomLabelEl) {
      zoomLabelEl.textContent = cropFactor.toFixed(2);
    }

    if (video) {
      video.style.transformOrigin = "center center";
      const scale = 1 / cropFactor; // cropFactor 작을수록(0.85) 화면 확대, 1.00이면 원본
      video.style.transform = `scale(${scale})`;
    }
  }

  if (zoomRangeEl) {
    setCropFactor(zoomRangeEl.value);
    zoomRangeEl.addEventListener("input", () => setCropFactor(zoomRangeEl.value));
  }

  // =========================
  // 2) 상태
  // =========================
  let stream = null;
  let ocrRunning = false;
  let lastOcrAt = 0;

  // 누적 OCR
  let segments = []; // { text, effLen, conf }
  let accText = "";
  let accEffectiveLen = 0;
  let accBestConf = 0;

  // 카메라 상태
  let blocked = false;
  let tooNear = false;
  let tooFar = false;

  // "아직 완성 아님" 연속 시간
  let notReadySince = null;

  // solve 상태
  let solved = false;
  let solving = false;

  // TTS 상태
  let lastStatusSpokenAt = 0;
  let audioUnlocked = false;
  let voicesReady = false;

  // 거리 음성 힌트 상태
  let lastDistHint = "ok";
  const DIST_HINT_COOLDOWN_MS = 8000;
  let lastDistHintAt = 0;

  // =========================
  // 3) iOS 음성 언락 + voice 로딩
  // =========================
  function initVoices() {
    if (!("speechSynthesis" in window)) return;
    const tryLoad = () => {
      const v = window.speechSynthesis.getVoices();
      if (v && v.length) voicesReady = true;
    };
    tryLoad();
    window.speechSynthesis.onvoiceschanged = () => {
      const v = window.speechSynthesis.getVoices();
      if (v && v.length) voicesReady = true;
    };
  }
  initVoices();

  function unlockAudioOnce() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    if (!TTS_ENABLED) return;
    speak("음성이 활성화되었습니다.", true);
  }
  document.addEventListener("click", unlockAudioOnce, { passive: true, once: true });
  document.addEventListener("touchstart", unlockAudioOnce, { passive: true, once: true });

  // =========================
  // 4) 유틸
  // =========================
  function now() { return Date.now(); }
  function effectiveLenOf(text) { return (text || "").replace(/\s/g, "").length; }

  function setStatus(lines) {
    statusEl.textContent = lines.join("\n");
  }

  function chooseKoreanVoice() {
    if (!("speechSynthesis" in window)) return null;
    const voices = window.speechSynthesis.getVoices() || [];
    let v = voices.find(x => (x.lang || "").toLowerCase().startsWith("ko"));
    if (v) return v;
    return voices.length ? voices[0] : null;
  }

  function speak(text, force = false) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const t = (text || "").trim();
    if (!t) return;

    const tNow = now();
    if (!force && tNow - lastStatusSpokenAt < TTS_STATUS_COOLDOWN_MS) return;

    const doSpeak = () => {
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(t);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        const v = chooseKoreanVoice();
        if (v) u.voice = v;
        lastStatusSpokenAt = tNow;
        window.speechSynthesis.speak(u);
      } catch (e) {}
    };

    if (!voicesReady) setTimeout(doSpeak, 250);
    else doSpeak();
  }

  function speakLong(text) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const t = (text || "").trim();
    if (!t) return;

    const chunkSize = 900;
    const chunks = [];
    for (let i = 0; i < t.length; i += chunkSize) chunks.push(t.slice(i, i + chunkSize));

    try {
      window.speechSynthesis.cancel();
      let idx = 0;
      const v = chooseKoreanVoice();

      const speakNext = () => {
        if (idx >= chunks.length) return;
        const u = new SpeechSynthesisUtterance(chunks[idx]);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        if (v) u.voice = v;
        u.onend = () => { idx += 1; speakNext(); };
        window.speechSynthesis.speak(u);
      };

      setTimeout(speakNext, voicesReady ? 0 : 300);
    } catch (e) {}
  }

  function normalizeOcrText(text) {
    let t = String(text || "");
    t = t.replace(/-\s*\n\s*/g, "");
    t = t.replace(/[ \t]+\n/g, "\n");
    t = t.replace(/\n[ \t]+/g, "\n");
    t = t.replace(/[ \t]{2,}/g, " ");
    t = t.replace(/[\u0000-\u001F\u007F]/g, "");
    t = t.replace(/[■□▢●◆◇]{2,}/g, " ");
    return t.trim();
  }

  // =========================
  // 5) 카메라 시작
  // =========================
  async function startCamera() {
    try {
      setStatus([
        "카메라 요청 중...",
        "iOS 권한 팝업이 뜨면 '허용'을 눌러야 함."
      ]);

      const constraints = {
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          frameRate: { ideal: 30 }
        },
        audio: false
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      await new Promise((resolve) => {
        if (video.readyState >= 2) return resolve();
        video.onloadedmetadata = () => resolve();
      });

      setStatus([
        "카메라 ON",
        "자동 OCR 시작됨 (3초마다, 화면이 안정될 때만)",
        "음성(TTS)이 안 나오면: 화면 탭 + 무음모드 해제 + 볼륨 올리기"
      ]);

      requestAnimationFrame(analyzeLoop);
      scheduleOcrLoop();
    } catch (e) {
      console.error(e);
      setStatus(["카메라 접근 실패", String(e)]);
      speak("카메라 접근에 실패했습니다.", true);
    }
  }

  // =========================
  // 6) 밝기/움직임/가려짐
  // =========================
  const BW = 64, BH = 36;
  const bCanvas = document.createElement("canvas");
  bCanvas.width = BW; bCanvas.height = BH;
  const bCtx = bCanvas.getContext("2d", { willReadFrequently: true });
  let prevThumb = null;
  let lastStableStart = 0;

  function analyzeFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      return { blocked: false, stable: false, avgBright: 255, diffAvg: 0 };
    }

    bCtx.drawImage(video, 0, 0, BW, BH);
    const img = bCtx.getImageData(0, 0, BW, BH).data;

    const len = BW * BH;
    const currThumb = new Uint8Array(len);

    let sumBright = 0;
    let diffSum = 0;

    for (let i = 0, p = 0; i < img.length; i += 4, p++) {
      const r = img[i], g = img[i + 1], b = img[i + 2];
      const gray = (r + g + b) / 3;
      currThumb[p] = gray;
      sumBright += gray;
      if (prevThumb) diffSum += Math.abs(gray - prevThumb[p]);
    }

    const avgBright = sumBright / len;
    const diffAvg = prevThumb ? (diffSum / len) : 0;
    prevThumb = currThumb;

    const isBlocked = avgBright < 20;

    const tNow = now();
    let stable = false;
    if (diffAvg < 8) {
      if (!lastStableStart) lastStableStart = tNow;
      if (tNow - lastStableStart >= 900) stable = true;
    } else {
      lastStableStart = 0;
    }

    return { blocked: isBlocked, stable, avgBright, diffAvg };
  }

  function analyzeLoop() {
    const a = analyzeFrame();
    blocked = a.blocked;
    requestAnimationFrame(analyzeLoop);
  }

  // =========================
  // 7) 캡처 + 중앙 크롭(사용자 슬라이더 cropFactor)
  // =========================
  const capCanvas = document.createElement("canvas");
  const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

  function captureToCanvas() {
    const vw = video.videoWidth;
    const vh = video.videoHeight;

    if (!vw || !vh) {
      capCanvas.width = 640;
      capCanvas.height = 360;
      capCtx.fillStyle = "black";
      capCtx.fillRect(0, 0, capCanvas.width, capCanvas.height);
      return capCanvas;
    }

    const scaleCrop = cropFactor;
    const cropW = Math.floor(vw * scaleCrop);
    const cropH = Math.floor(vh * scaleCrop);
    const cropX = Math.floor((vw - cropW) / 2);
    const cropY = Math.floor((vh - cropH) / 2);

    const maxW = 1920;
    const scale = Math.min(1, maxW / cropW);
    const outW = Math.max(360, Math.floor(cropW * scale));
    const outH = Math.max(240, Math.floor(cropH * scale));

    capCanvas.width = outW;
    capCanvas.height = outH;

    capCtx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, outW, outH);
    return capCanvas;
  }

  // =========================
  // 8) 중복/유사도 + 누적 merge
  // =========================
  function tokenize(text) {
    const t = (text || "").slice(0, 1500);
    const arr = t.split(/\s+/).filter(Boolean);
    return arr.slice(0, 220);
  }

  function jaccardSimilarity(a, b) {
    const A = tokenize(a);
    const B = tokenize(b);
    if (!A.length || !B.length) return 0;

    const setA = new Set(A);
    const setB = new Set(B);

    let inter = 0;
    for (const x of setA) if (setB.has(x)) inter++;

    const union = setA.size + setB.size - inter;
    return union ? (inter / union) : 0;
  }

  function updateAccumulation(newText, newConf) {
    const cleaned = normalizeOcrText(newText);
    const effLen = effectiveLenOf(cleaned);
    if (effLen < 20) return { changed: false, action: "ignore_too_short" };
    if (newConf < 5) return { changed: false, action: "ignore_low_conf" };

    if (segments.length === 0) {
      segments.push({ text: cleaned, effLen, conf: newConf });
      rebuildAccumulated();
      return { changed: true, action: "append_first" };
    }

    const last = segments[segments.length - 1];
    const sim = jaccardSimilarity(last.text, cleaned);

    if (sim >= DUP_SIMILARITY) {
      const better =
        (effLen > last.effLen + 60) ||
        (Math.abs(effLen - last.effLen) <= 60 && newConf > last.conf + 4);

      if (better) {
        segments[segments.length - 1] = { text: cleaned, effLen, conf: newConf };
        rebuildAccumulated();
        return { changed: true, action: `replace_last(sim=${sim.toFixed(2)})` };
      } else {
        return { changed: false, action: `dup_keep_last(sim=${sim.toFixed(2)})` };
      }
    }

    segments.push({ text: cleaned, effLen, conf: newConf });

    if (segments.length > 12) segments = segments.slice(segments.length - 12);

    rebuildAccumulated();
    return { changed: true, action: `append_new(sim=${sim.toFixed(2)})` };
  }

  function rebuildAccumulated() {
    accText = segments.map(s => s.text).join("\n\n");
    accEffectiveLen = effectiveLenOf(accText);

    accBestConf = 0;
    for (const s of segments) {
      if (typeof s.conf === "number" && s.conf > accBestConf) accBestConf = s.conf;
    }

    const maxPreview = 8000;
    if (accText.length <= maxPreview) ocrPreviewEl.value = accText;
    else ocrPreviewEl.value = accText.slice(-maxPreview);
  }

  // =========================
  // 9) “완성” 구조 판단(문제1/2 + 제시문 힌트)
  // =========================
  function hasProblemStructure(text) {
    const t = text || "";
    const hasQ1 = /(\[?\s*문제\s*1\s*\]?)/.test(t) || /(\n\s*1\)\s*)/.test(t);
    const hasQ2 = /(\[?\s*문제\s*2\s*\]?)/.test(t) || /(\n\s*2\)\s*)/.test(t);
    return hasQ1 && hasQ2;
  }

  function hasPassageHint(text) {
    const t = text || "";
    return /(제시문\s*\d*|보기|다음\s*글|다음은|자료\s*\d*)/.test(t);
  }

  function isReadyToSolve() {
    if (accEffectiveLen < MIN_SOLVE_LEN_EFFECTIVE) return false;

    const structure = hasProblemStructure(accText);
    const passage = hasPassageHint(accText);

    if (structure && (passage || accEffectiveLen >= TEXT_THRESHOLD_EFFECTIVE)) return true;

    return false;
  }

  function buildInsufficientReason() {
    if (blocked) return "카메라가 가려졌습니다. 렌즈를 가리지 않게 해주세요.";
    if (tooFar) return "지문이 너무 멀어 보입니다. 종이를 화면에 더 크게 채워주세요.";
    if (tooNear) return "지문이 너무 가까워 보입니다. 5에서 10센티미터 정도만 멀리 두고 다시 비춰주세요.";
    const structure = hasProblemStructure(accText);
    if (!structure) return "문제 1과 문제 2가 아직 충분히 인식되지 않았습니다. 문제 부분을 화면에 크게 비춰주세요.";
    return "아직 제시문이나 일부 문장이 부족합니다. 페이지를 조금 더 오래, 흔들림 없이 비춰주세요.";
  }

  function buildStatusLines(extraLine) {
    const lines = [];
    lines.push("자동 OCR(누적) → 자동 풀이");
    lines.push(`카메라 상태: ${blocked ? "가려짐" : "정상"}`);

    let dist = "정상(추정)";
    if (tooFar) dist = "너무 멂(추정)";
    else if (tooNear) dist = "너무 가까움(추정)";
    lines.push(`거리 상태: ${dist}`);

    lines.push(`배율(디지털 줌): ${cropFactor.toFixed(2)} (1.00=최대 줌 아웃, 0.85=살짝 확대)`);
    lines.push(`누적 세그먼트 수: ${segments.length}`);
    lines.push(`누적 길이(공백제외): ${accEffectiveLen}`);
    lines.push(`OCR 참고 신뢰도(최대): ${accBestConf.toFixed(1)}%`);

    const ready = isReadyToSolve();
    lines.push(`완성 판정(문제1·2/제시문): ${ready ? "OK" : "아직 부족"}`);

    if (notReadySince && !ready) {
      const sec = Math.floor((now() - notReadySince) / 1000);
      lines.push(`부족 지속: ${sec}초 (5분 안내 / 8분 자동풀이)`);
    } else {
      lines.push("부족 지속: 0초");
    }

    if (extraLine) lines.push(String(extraLine));
    return lines;
  }

  // =========================
  // 10) OCR 1회
  // =========================
  function shouldTryOcr() {
    if (solved || solving) return false;
    if (ocrRunning) return false;
    if (blocked) return false;

    const tNow = now();
    if (tNow - lastOcrAt < OCR_INTERVAL_MS) return false;

    const a = analyzeFrame();
    if (!a.stable) return false;

    return true;
  }

  async function doOcrOnce() {
    if (!shouldTryOcr()) return;
    ocrRunning = true;
    lastOcrAt = now();

    try {
      const canvas = captureToCanvas();
      setStatus(buildStatusLines("OCR 진행 중..."));

      const result = await Tesseract.recognize(canvas, OCR_LANG, {
        logger: (m) => {
          if (m && m.status === "recognizing text") {
            const p = Math.round((m.progress || 0) * 100);
            setStatus(buildStatusLines(`OCR 진행 중... ${p}%`));
          }
        }
      });

      const rawText = (result && result.data && result.data.text) ? result.data.text : "";
      const conf = (result && result.data && typeof result.data.confidence === "number")
        ? result.data.confidence
        : 0;

      const cleaned = normalizeOcrText(rawText);
      const effLen = effectiveLenOf(cleaned);

      // 거리 추정(휴리스틱)
      tooFar = (effLen < 400 && conf < 35);
      tooNear = (effLen >= 800 && conf < 35);

      // 거리/가려짐 즉시 음성 힌트
      const tNowHint = now();
      let distState = "ok";
      if (blocked) distState = "blocked";
      else if (tooFar) distState = "far";
      else if (tooNear) distState = "near";

      if (
        distState !== "ok" &&
        distState !== lastDistHint &&
        (tNowHint - lastDistHintAt) > DIST_HINT_COOLDOWN_MS
      ) {
        let msg;
        if (distState === "far") {
          msg = "지문이 너무 멀어 보입니다. 종이를 화면에 더 크게 채워주세요.";
        } else if (distState === "near") {
          msg = "지문이 너무 가까워 보입니다. 5에서 10센티미터 정도만 멀리 두고 다시 비춰주세요.";
        } else {
          msg = "카메라가 가려졌습니다. 렌즈를 가리지 않게 해주세요.";
        }
        speak(msg, false);
        lastDistHint = distState;
        lastDistHintAt = tNowHint;
      }
      if (distState === "ok") {
        lastDistHint = "ok";
      }

      // 누적 업데이트(중복이면 교체, 아니면 append)
      const mergeInfo = updateAccumulation(cleaned, conf);

      const ready = isReadyToSolve();
      const tNow = now();

      if (!ready) {
        if (!notReadySince) notReadySince = tNow;
      } else {
        notReadySince = null;
      }

      setStatus(buildStatusLines(`OCR 완료 · 누적:${mergeInfo.action}`));

      if (!solved && !solving) {
        if (ready) {
          await autoSolve("문제/제시문 구조 인식 완료");
          return;
        }

        if (notReadySince) {
          const dur = tNow - notReadySince;

          if (dur >= INSUFFICIENT_WARN_MS && dur < MAX_WAIT_MS) {
            speak(buildInsufficientReason(), false);
          }

          if (dur >= MAX_WAIT_MS) {
            await autoSolve("8분 경과. 현재 인식된 내용으로 풀이");
            return;
          }
        }
      }

    } catch (e) {
      console.error(e);
      setStatus(buildStatusLines("OCR 에러: " + String(e)));
    } finally {
      ocrRunning = false;
    }
  }

  // =========================
  // 11) solve 호출
  // =========================
  async function autoSolve(reason) {
    if (solved || solving) return;
    solving = true;

    let payloadText = (accText || "").trim();
    if (payloadText.length > 8000) payloadText = payloadText.slice(0, 8000);

    setStatus(buildStatusLines(`풀이 요청 중... (${reason})`));
    answerBoxEl.textContent = "풀이 생성 중...";

    try {
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ocrText: payloadText })
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();
      let out = "";

      if (ct.includes("application/json")) {
        let data;
        try { data = await res.json(); }
        catch (e) { out = "JSON 파싱 에러: " + String(e); }

        if (!out) {
          if (data && typeof data.answer === "string") out = data.answer;
          else if (data && typeof data.body === "string") out = data.body;
          else out = JSON.stringify(data);
        }
      } else {
        out = await res.text();
      }

      if (!res.ok) {
        answerBoxEl.textContent = `서버 에러 (status ${res.status})\n\n${out.slice(0, 4000)}`;
        speak("서버 에러가 발생했습니다.", true);
        solving = false;
        return;
      }

      solved = true;
      answerBoxEl.textContent = out;

      setStatus(buildStatusLines("풀이 완료"));
      speak("답안이 생성되었습니다.", true);
      speakLong(out);

    } catch (e) {
      console.error(e);
      answerBoxEl.textContent = "요청 실패: " + String(e);
      speak("요청에 실패했습니다.", true);
    } finally {
      solving = false;
    }
  }

  // =========================
  // 12) OCR 루프
  // =========================
  function scheduleOcrLoop() {
    doOcrOnce();
    setInterval(() => { doOcrOnce(); }, OCR_INTERVAL_MS);
  }

  // =========================
  // 13) 시작
  // =========================
  startCamera();

})();
</script>
</body>
</html>
