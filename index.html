<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>autononsul - OCR + ë³µë¶™ + TTS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <style>
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin:0; padding:12px;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      background:#0b0b0b; color:#fff;
      -webkit-text-size-adjust: 100%;
      touch-action: manipulation;
    }
    h1 { font-size:16px; margin:0 0 10px; }
    #status {
      font-size:12px; color:#c4f1ff;
      white-space:pre-wrap;
      padding:8px; border:1px solid #333;
      border-radius:10px; background:#070707;
      line-height: 1.35;
    }
    #videoBox {
      margin-top:10px; border:1px solid #333;
      border-radius:10px; overflow:hidden;
      background:#000;
    }
    video { width:100%; height:auto; display:block; }

    .row { display:flex; gap:8px; margin-top:10px; }
    button {
      flex:1;
      padding:10px 12px;
      font-size:14px;
      border-radius:10px;
      border:1px solid #555;
      background:#151515;
      color:#fff;
    }
    button:active { transform: scale(0.98); }
    button:disabled { opacity:0.45; }

    textarea {
      width:100%; min-height:140px;
      margin-top:8px; padding:10px;
      border-radius:10px;
      border:1px solid #333;
      background:#060606; color:#fff;
      font-size:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
      line-height: 1.35;
    }

    .hint { font-size:11px; color:#aaa; margin-top:6px; line-height: 1.4; }
    .sectionTitle { margin-top:14px; font-size:13px; font-weight:600; }

    #shotsWrap {
      margin-top:8px;
      border:1px dashed #444;
      border-radius:10px;
      padding:8px;
      font-size:11px;
      color:#aaa;
      max-height:180px;
      overflow-y:auto;
    }
    .shotItem {
      margin-top:6px;
      border-radius:8px;
      border:1px solid #333;
      padding:4px;
      background:#050505;
    }
    .shotLabel {
      font-size:11px;
      color:#ddd;
      margin-bottom:4px;
      display:block;
    }
    .shotImg {
      width:100%;
      border-radius:6px;
      display:block;
      background:#000;
    }

    #errOverlay {
      position:fixed; inset:0; background:rgba(0,0,0,0.92); color:#fff;
      padding:14px; display:none; z-index:9999; overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }
    #errOverlay button { margin-top:10px; width:auto; }

    .pill {
      display:inline-block;
      padding:2px 8px;
      border:1px solid #444;
      border-radius:999px;
      font-size:11px;
      color:#ddd;
      background:#111;
      margin-left:6px;
    }

    .miniNote {
      font-size: 11px;
      color: #9aa;
      margin-top: 6px;
    }
  </style>
</head>

<body>
  <div id="errOverlay"></div>

  <h1>ì—°ì„¸ëŒ€ ë…¼ìˆ  OCR â†’ ë³µë¶™ â†’ TTS</h1>
  <div id="status">
    ë¡œë”©ë¨. ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...
  </div>

  <div class="hint">
    1) <b>ìë™ OCR ì‹œì‘</b>ì„ í•œ ë²ˆ ëˆ„ë¥´ë©´, ê° ì¥ë§ˆë‹¤ ìë™ìœ¼ë¡œ ì´¬ì˜+OCR 3íšŒ ì§„í–‰<br/>
    2) OCR ì‹ ë¢°ë„ì™€ í…ìŠ¤íŠ¸ì—ì„œ <b>ë¬¸ì œ + "ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤"</b>ê°€ ì¡íˆë©´<br/>
       ìŒì„±ìœ¼ë¡œ <b>"ì´ í˜ì´ì§€ ì¸ì‹ ì™„ë£Œ, ì´ì œ ë§ˆì§€ë§‰ í˜ì´ì§€ì…ë‹ˆë‹¤"</b> ì•ˆë‚´ í›„ ìë™ OCR ì¢…ë£Œ<br/>
    3) ëª¨ë“  ì¥ ëë‚˜ë©´ <b>OCR ì „ì²´ í…ìŠ¤íŠ¸ ë³µì‚¬</b> â†’ ChatGPT 5.2 ë°©ì— ë¶™ì—¬ë„£ê¸° + ì‚¬ì§„ ì²¨ë¶€<br/>
    4) ë‹µì•ˆ ë°›ìœ¼ë©´ ì•„ë˜ ë°•ìŠ¤ì— ë¶™ì—¬ë„£ê¸° â†’ <b>TTSë¡œ ê³„ì† ë°˜ë³µ ì¬ìƒ</b><br/>
    â€» <b>TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼</b>
  </div>

  <div class="row">
    <button id="btnAuto">ğŸ“¸ ìë™ OCR ì‹œì‘/ì •ì§€</button>
    <button id="btnCopyAll">ğŸ“‹ OCR ì „ì²´ í…ìŠ¤íŠ¸ ë³µì‚¬</button>
  </div>

  <div class="row">
    <button id="btnCopyLastImg">ğŸ–¼ ë§ˆì§€ë§‰ ì´ë¯¸ì§€ ë³µì‚¬(ì‹¤í—˜)</button>
    <button id="btnClearOcr">ğŸ§¹ OCR í…ìŠ¤íŠ¸ ì§€ìš°ê¸°</button>
  </div>

  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <div id="shotsWrap">
    ì´¬ì˜ëœ ëª¨ë“  ìƒ· ë¯¸ë¦¬ë³´ê¸° (ê° ì´ë¯¸ì§€ë¥¼ ê¸¸ê²Œ ëˆŒëŸ¬ ë³µì‚¬/ì €ì¥ ê°€ëŠ¥)
    <span class="pill" id="shotCountLabel">ìƒ· 0ê°œ</span>
    <div class="miniNote">
      â€» ìë™ OCR ì¤‘ì—ëŠ” í˜ì´ì§€ë¥¼ ë„˜ê²¨ ë‹¬ë¼ëŠ” ìŒì„±ì´ ë‚˜ì˜¤ë©´ ë°”ë¡œ ë‹¤ìŒ ì¥ì„ í¼ì¹˜ë©´ ëœë‹¤.
    </div>
    <div id="shotsContainer"></div>
  </div>

  <div class="sectionTitle">â‘  OCR ëˆ„ì  í…ìŠ¤íŠ¸</div>
  <textarea id="ocrBox" placeholder="ìë™ OCRì´ ì§„í–‰ë˜ë©´ [ìƒ· 1], [ìƒ· 2]... ìˆœì„œëŒ€ë¡œ ëˆ„ì ë©ë‹ˆë‹¤."></textarea>

  <div class="sectionTitle">â‘¡ ë‹µì•ˆ(TTSìš©) ë°•ìŠ¤ (ChatGPT ë‹µì•ˆì„ ì—¬ê¸° ë¶™ì—¬ë„£ê¸°)</div>
  <textarea id="ttsInput" placeholder="[ë¬¸ì œ 1] ... [ë¬¸ì œ 2] ... ë‹µì•ˆì„ ì—¬ê¸° ë¶™ì—¬ë„£ìœ¼ë©´, ìë™ìœ¼ë¡œ ì½ê¸° ì‹œì‘í•˜ê³ , 'ì½ê¸° ì‹œì‘' ë²„íŠ¼ìœ¼ë¡œ ë‹¤ì‹œ ì¬ìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤."></textarea>

  <div class="row">
    <button id="btnTtsStart">ğŸ”Š ì½ê¸° ì‹œì‘(ë°˜ë³µ)</button>
    <button id="btnTtsStop">â¹ ì½ê¸° ì •ì§€</button>
  </div>

  <div class="hint">
    - TTSëŠ” <b>0.9ë°°ì†</b>ìœ¼ë¡œ ì½ê³ , ë‹¨ì–´ ì‚¬ì´ì— <b>ì•½ 6ì´ˆ ì¹¨ë¬µ</b> ê°„ê²©ì„ ë‘”ë‹¤.<br/>
    - ì¤„ë°”ê¿ˆì€ <b>"ì¤„ë°”ê¿ˆ"</b>, ë§ˆì¹¨í‘œëŠ” <b>"ë§ˆì¹¨í‘œ"</b>ë¼ê³  ì½ëŠ”ë‹¤. ë„ì–´ì“°ê¸°ëŠ” ë§í•˜ì§€ ì•ŠëŠ”ë‹¤(ì¡°ìš©íˆ ì‰¬ê¸°ë§Œ í•¨).<br/>
    - ë‹µì•ˆ ì „ì²´ë¥¼ ë‹¤ ì½ê³  ë‚˜ë©´, <b>ì ì‹œ ì‰¬ì—ˆë‹¤ê°€ ì²˜ìŒë¶€í„° ë‹¤ì‹œ ë°˜ë³µ</b>í•œë‹¤.<br/>
    - ì•± ì „í™˜ í›„ ëŒì•„ì™”ëŠ”ë° TTSê°€ ì•ˆ ë“¤ë¦¬ë©´: <b>'ì½ê¸° ì‹œì‘' ë‹¤ì‹œ ëˆ„ë¥´ê³ </b>, ê·¸ë˜ë„ ì•ˆ ë˜ë©´ <b>ìƒˆë¡œê³ ì¹¨</b>.<br/>
    - <b>TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼</b>
  </div>

<script>
(function(){
  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnAuto = document.getElementById("btnAuto");
  const btnCopyAll = document.getElementById("btnCopyAll");
  const btnCopyLastImg = document.getElementById("btnCopyLastImg");
  const btnClearOcr = document.getElementById("btnClearOcr");
  const ocrBox = document.getElementById("ocrBox");
  const ttsInput = document.getElementById("ttsInput");
  const btnTtsStart = document.getElementById("btnTtsStart");
  const btnTtsStop = document.getElementById("btnTtsStop");
  const errOverlay = document.getElementById("errOverlay");
  const shotsContainer = document.getElementById("shotsContainer");
  const shotCountLabel = document.getElementById("shotCountLabel");

  const OCR_URL = "/.netlify/functions/ocr";

  const CAP_MAX_W = 1600;
  const JPEG_QUALITY = 0.86;
  const OCR_ATTEMPTS = 3;

  const DONE_CONF_THRESHOLD = 70;
  const DONE_LEN_THRESHOLD = 400;

  let ocrAutoRunning = false;
  let shotCount = 0;
  let lastShotDataUrl = null;
  let shotList = [];

  // TTS ê´€ë ¨
  const synth = window.speechSynthesis || null;
  let ttsTokens = [];
  let ttsIndex = 0;
  let ttsLoopActive = false;
  let ttsStopFlag = false;
  const WORD_GAP_MS = 6000;
  const LOOP_GAP_MS = 7000;
  const TTS_RATE = 0.9; // ìš”ì²­: 0.9 ì†ë„

  // ===== ì—ëŸ¬ ì˜¤ë²„ë ˆì´ =====
  function showErrorOverlay(title, detail){
    try{
      errOverlay.style.display = "block";
      errOverlay.textContent = "[ERROR]\n" + title + "\n\n" + (detail || "") + "\n\n(ì•„ë˜ ë²„íŠ¼ ëˆ„ë¥´ë©´ ë‹«í˜)";
      const btn = document.createElement("button");
      btn.textContent = "ë‹«ê¸°";
      btn.onclick = () => { errOverlay.style.display = "none"; errOverlay.innerHTML = ""; };
      errOverlay.appendChild(document.createElement("br"));
      errOverlay.appendChild(btn);
    }catch(e){}
  }

  window.addEventListener("error", (e) => {
    showErrorOverlay(e.message || "Unknown JS error", (e.error && e.error.stack) ? e.error.stack : "");
  });

  window.addEventListener("unhandledrejection", (e) => {
    const msg = (e && e.reason) ? (e.reason.message || String(e.reason)) : "Unhandled rejection";
    const stack = (e && e.reason && e.reason.stack) ? e.reason.stack : "";
    showErrorOverlay(msg, stack);
  });

  // ===== ì¹´ë©”ë¼ ì‹œì‘ =====
  let stream = null;
  async function startCamera(){
    try{
      statusEl.textContent = "ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­ ì¤‘...";
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        },
        audio: false
      });
      video.srcObject = stream;
      statusEl.textContent =
        "ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ.\n" +
        "í•œ ì¥ì´ ê½‰ ì°¨ê²Œ ë³´ì´ë„ë¡ ë§ì¶˜ ë’¤ 'ìë™ OCR ì‹œì‘'ì„ ëˆ„ë¥´ì„¸ìš”.\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
    }catch(e){
      statusEl.textContent = "ì¹´ë©”ë¼ ì‹¤íŒ¨: " + (e.message || String(e));
      showErrorOverlay("ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨", String(e && e.message ? e.message : e));
    }
  }

  // ===== ìº¡ì³ =====
  function captureDataUrlOptimized(){
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) return null;

    let outW = w;
    let outH = h;
    if (w > CAP_MAX_W){
      const ratio = CAP_MAX_W / w;
      outW = Math.round(w * ratio);
      outH = Math.round(h * ratio);
    }

    const canvas = document.createElement("canvas");
    canvas.width = outW;
    canvas.height = outH;
    const ctx = canvas.getContext("2d");
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(video, 0, 0, outW, outH);

    return canvas.toDataURL("image/jpeg", JPEG_QUALITY);
  }

  // ===== OCR 1íšŒ í˜¸ì¶œ =====
  async function callOcrOnce(dataUrl){
    try{
      const res = await fetch(OCR_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          imageBase64: dataUrl,
          mode: "dual"
        })
      });
      const json = await res.json().catch(() => null);
      if (!json || !json.ok){
        const msg = (json && (json.message || json.error)) || "OCR ì‹¤íŒ¨";
        return { ok:false, msg, text:"", conf:0 };
      }
      const text = (json.text || "").trim();
      const conf = (typeof json.conf === "number") ? json.conf : 0;
      if (!text){
        return { ok:false, msg:"OCR ê²°ê³¼ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.", text:"", conf };
      }
      return { ok:true, text, conf };
    }catch(e){
      return { ok:false, msg:(e.message || String(e)), text:"", conf:0 };
    }
  }

  function pickBest(best, cand){
    if (!cand || !cand.ok) return best;
    if (!best || !best.ok) return cand;
    if ((cand.conf || 0) > (best.conf || 0)) return cand;
    if ((cand.conf || 0) === (best.conf || 0)){
      if ((cand.text || "").length > (best.text || "").length) return cand;
    }
    return best;
  }

  // ===== ë§ˆì§€ë§‰ í˜ì´ì§€ íŒì • =====
  function isDonePage(text, conf){
    if (!text) return false;
    if (typeof conf !== "number" || conf < DONE_CONF_THRESHOLD) return false;
    const norm = text.replace(/\s/g, "");
    const hasMunje = norm.includes("ë¬¸ì œ");
    const hasStart =
      norm.includes("ì´ì œí’€ì´ë¥¼ì‹œì‘í•˜ì‹œì˜¤") ||
      norm.includes("ì´ì œí’€ì´ë¥¼ì‹œì‘í•˜ì‹­ì‹œì˜¤");
    if (!hasMunje || !hasStart) return false;
    if (text.length < DONE_LEN_THRESHOLD) return false;
    return true;
  }

  // ===== ì§§ì€ ì•ˆë‚´ ìŒì„± =====
  function speakShort(text){
    if (!synth) return;
    if (!text) return;
    try{
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "ko-KR";
      u.rate = TTS_RATE;
      u.pitch = 1.0;
      synth.speak(u);
    }catch(e){}
  }

  function speakNextPageCountdown(){
    if (!synth) return;
    try{
      const seq = ["ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”.", "5", "4", "3", "2", "1"];
      let idx = 0;
      function speakOne(){
        if (idx >= seq.length) return;
        const u = new SpeechSynthesisUtterance(seq[idx]);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = 1.0;
        u.onend = () => {
          idx++;
          if (idx < seq.length){
            setTimeout(speakOne, 500);
          }
        };
        synth.speak(u);
      }
      speakOne();
    }catch(e){}
  }

  // ===== ìƒ· ë¯¸ë¦¬ë³´ê¸° =====
  function appendShotPreview(dataUrl, conf){
    try{
      const item = document.createElement("div");
      item.className = "shotItem";
      const label = document.createElement("span");
      label.className = "shotLabel";
      const confStr = (typeof conf === "number" && conf > 0) ? conf.toFixed(1) + "%" : "ì •ë³´ ì—†ìŒ";
      label.textContent = "ìƒ· " + shotCount + " (ì‹ ë¢°ë„ ëŒ€ëµ " + confStr + ")";
      const img = document.createElement("img");
      img.className = "shotImg";
      img.src = dataUrl;
      img.alt = "ìƒ· " + shotCount;
      item.appendChild(label);
      item.appendChild(img);
      shotsContainer.appendChild(item);
      shotCountLabel.textContent = "ìƒ· " + shotCount + "ê°œ";
    }catch(e){}
  }

  async function copyLastImageToClipboard(){
    if (!lastShotDataUrl){
      statusEl.textContent =
        "ë³µì‚¬í•  ì´ë¯¸ì§€ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ìë™ OCRì„ í•œ ë²ˆì´ë¼ë„ ì§„í–‰í•˜ì„¸ìš”.\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      return;
    }
    try{
      if (!navigator.clipboard || !window.ClipboardItem){
        statusEl.textContent =
          "ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì´ë¯¸ì§€ í´ë¦½ë³´ë“œ ë³µì‚¬ê°€ ì™„ì „íˆ ì§€ì›ë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n" +
          "ì´ë¯¸ì§€ë¥¼ ê¸¸ê²Œ ëˆŒëŸ¬ 'ë³µì‚¬' ë˜ëŠ” 'ì‚¬ì§„ ì €ì¥'ì„ ì‚¬ìš©í•˜ì„¸ìš”.\n" +
          "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
        return;
      }
      const res = await fetch(lastShotDataUrl);
      const blob = await res.blob();
      const item = new ClipboardItem({ [blob.type]: blob });
      await navigator.clipboard.write([item]);
      statusEl.textContent =
        "ë§ˆì§€ë§‰ ìƒ· ì´ë¯¸ì§€ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆìŠµë‹ˆë‹¤. ChatGPT ì…ë ¥ì°½ì— ë°”ë¡œ ë¶™ì—¬ë„£ê¸°ë¥¼ ì‹œë„í•´ ë³´ì„¸ìš”.\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
    }catch(e){
      statusEl.textContent =
        "ì´ë¯¸ì§€ ë³µì‚¬ ì‹¤íŒ¨. ì‚¬íŒŒë¦¬ì—ì„œ ì§€ì›ì´ ë¶€ì¡±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n" +
        "ì´ë¯¸ì§€ë¥¼ ê¸¸ê²Œ ëˆŒëŸ¬ 'ë³µì‚¬' ë˜ëŠ” 'ì‚¬ì§„ ì €ì¥'ì„ ì‚¬ìš©í•˜ì„¸ìš”.\n" +
        "ì˜¤ë¥˜: " + (e.message || String(e)) + "\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
    }
  }

  // ===== ë‹¨ì¼ ìƒ· ìº¡ì³ + OCR(3íšŒ) =====
  async function captureAndOcrSingleShot(){
    const dataUrl = captureDataUrlOptimized();
    if (!dataUrl){
      statusEl.textContent =
        "ì˜ìƒ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤. 1~2ì´ˆ í›„ ë‹¤ì‹œ ì‹œë„ë©ë‹ˆë‹¤.\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      return { ok:false, done:false };
    }

    shotCount += 1;
    lastShotDataUrl = dataUrl;
    shotList.push({ index: shotCount, dataUrl });

    appendShotPreview(dataUrl, 0);

    statusEl.textContent =
      "ìƒ· " + shotCount + ": ì´¬ì˜ ì™„ë£Œ. OCR ìë™ " + OCR_ATTEMPTS + "íšŒ ì§„í–‰ ì¤‘...\n" +
      "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";

    let best = null;
    let lastErr = "";

    for (let attempt = 1; attempt <= OCR_ATTEMPTS; attempt++){
      if (!ocrAutoRunning) break;
      statusEl.textContent =
        "ìƒ· " + shotCount + ": OCR " + attempt + "íšŒì°¨ ì²˜ë¦¬ ì¤‘...\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      const r = await callOcrOnce(dataUrl);
      if (!r.ok) lastErr = r.msg || lastErr;
      best = pickBest(best, r);
    }

    if (!best || !best.ok){
      statusEl.textContent =
        "ìƒ· " + shotCount + ": OCR " + OCR_ATTEMPTS + "íšŒ ëª¨ë‘ ì‹¤íŒ¨.\n" +
        "ì¡°ëª…/ê±°ë¦¬/ì´ˆì  ë‹¤ì‹œ ë§ì¶”ê³  ìë™ OCRì„ ë‹¤ì‹œ ì‹œì‘í•˜ê±°ë‚˜, ì ì‹œ í›„ ì¬ì‹œë„í•˜ì„¸ìš”.\n" +
        "ë§ˆì§€ë§‰ ì˜¤ë¥˜: " + (lastErr || "ì •ë³´ ì—†ìŒ") + "\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      speakShort("ì˜¤ ì”¨ ì•Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì¡°ëª…ê³¼ ê±°ë¦¬ë¥¼ ì¡°ì •í•˜ê³  ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.");
      return { ok:false, done:false };
    }

    const text = best.text || "";
    const confValue = (typeof best.conf === "number") ? best.conf : 0;
    const confStr = confValue ? confValue.toFixed(1) + "%" : "ì •ë³´ ì—†ìŒ";
    const lengthStr = text.length;

    const header =
      "\n\n[ìƒ· " + shotCount + "] ---------------------- " +
      "(ì‹ ë¢°ë„ ëŒ€ëµ " + confStr + ", ê¸¸ì´ " + lengthStr + "ì)\n";
    ocrBox.value = (ocrBox.value || "") + header + text + "\n";

    const done = isDonePage(text, confValue);

    if (done){
      statusEl.textContent =
        "ìƒ· " + shotCount + ": OCR ì„±ê³µ(ì‹ ë¢°ë„ ëŒ€ëµ " + confStr + ", ê¸¸ì´ " + lengthStr + "ì).\n" +
        "í…ìŠ¤íŠ¸ì—ì„œ 'ë¬¸ì œ'ì™€ 'ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤' ë¬¸êµ¬ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.\n" +
        "â†’ ì´ í˜ì´ì§€ë¥¼ ë§ˆì§€ë§‰ìœ¼ë¡œ ìë™ OCRì„ ì¢…ë£Œí•©ë‹ˆë‹¤.\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      speakShort("ì´ í˜ì´ì§€ ì¸ì‹ ì™„ë£Œ. ì´ì œ ë§ˆì§€ë§‰ í˜ì´ì§€ì…ë‹ˆë‹¤. ìë™ ì˜¤ ì”¨ ì•Œì„ ì¢…ë£Œí•©ë‹ˆë‹¤.");
      return { ok:true, done:true };
    }else{
      statusEl.textContent =
        "ìƒ· " + shotCount + ": OCR ì„±ê³µ(ì‹ ë¢°ë„ ëŒ€ëµ " + confStr + ", ê¸¸ì´ " + lengthStr + "ì).\n" +
        "ë‹¤ë§Œ 'ë¬¸ì œ' ë˜ëŠ” 'ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤' ë¬¸êµ¬ê°€ ì™„ì „íˆ ì¡íˆì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.\n" +
        "â†’ ë‹¤ìŒ ì•ˆë‚´ì— ë”°ë¼ í˜ì´ì§€ë¥¼ ë„˜ê²¨ ìë™ OCRì„ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";

      if (shotsContainer && shotsContainer.lastElementChild){
        const lbl = shotsContainer.lastElementChild.querySelector(".shotLabel");
        if (lbl){
          lbl.textContent = "ìƒ· " + shotCount + " (ì‹ ë¢°ë„ ëŒ€ëµ " + confStr + ")";
        }
      }
      return { ok:true, done:false };
    }
  }

  function sleep(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // ===== ìë™ OCR ë£¨í”„ =====
  async function runAutoOcrLoop(){
    if (ocrAutoRunning) return;
    ocrAutoRunning = true;
    btnAuto.textContent = "â¹ ìë™ OCR ì¤‘ì§€";

    // ì‹œì‘í•  ë•Œ í”„ë¼ì„ ìŒì„±
    speakShort("ìë™ ì˜¤ ì”¨ ì•Œì„ ì‹œì‘í•©ë‹ˆë‹¤.");

    statusEl.textContent =
      "ìë™ OCRì„ ì‹œì‘í•©ë‹ˆë‹¤.\n" +
      "ì§€ê¸ˆ ë³´ì´ëŠ” í˜ì´ì§€ë¥¼ ê³ ì •í•œ ìƒíƒœì—ì„œ ê¸°ë‹¤ë¦¬ë©´, ê° ì¥ë§ˆë‹¤ ìë™ìœ¼ë¡œ ì´¬ì˜ + OCR 3íšŒê°€ ì§„í–‰ë©ë‹ˆë‹¤.\n" +
      "ì™„ë£Œ ë¬¸êµ¬ê°€ ë‚˜ì˜¤ë©´ ê·¸ í˜ì´ì§€ê°€ ë§ˆì§€ë§‰ì…ë‹ˆë‹¤.\n" +
      "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";

    while (ocrAutoRunning){
      const res = await captureAndOcrSingleShot();
      if (!ocrAutoRunning) break;
      if (!res.ok){
        statusEl.textContent += "\nìë™ OCR ë£¨í”„ë¥¼ ì ì‹œ ë©ˆì¶¥ë‹ˆë‹¤. í•„ìš”í•˜ë©´ ë‹¤ì‹œ 'ìë™ OCR ì‹œì‘'ì„ ëˆ„ë¥´ì„¸ìš”.";
        break;
      }
      if (res.done){
        ocrAutoRunning = false;
        break;
      }
      speakNextPageCountdown();
      await sleep(6500);
    }

    ocrAutoRunning = false;
    btnAuto.textContent = "ğŸ“¸ ìë™ OCR ì‹œì‘/ì •ì§€";
  }

  function stopAutoOcr(){
    ocrAutoRunning = false;
    btnAuto.textContent = "ğŸ“¸ ìë™ OCR ì‹œì‘/ì •ì§€";
    statusEl.textContent =
      "ìë™ OCRì„ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤. í•„ìš”í•˜ë©´ ë‹¤ì‹œ 'ìë™ OCR ì‹œì‘'ì„ ëˆŒëŸ¬ ì´ì–´ì„œ ì§„í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n" +
      "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
  }

  // ===== OCR í…ìŠ¤íŠ¸ ë³µì‚¬/ì´ˆê¸°í™” =====
  function buildSharePayload(text){
    return (
      "[OCR ì´ë¯¸ì§€/í…ìŠ¤íŠ¸ ì„¸íŠ¸]\n\n" +
      "- ì•„ë˜ OCR í…ìŠ¤íŠ¸ëŠ” ì‹œí—˜ì§€ì—ì„œ ì¶”ì¶œë¨\n" +
      "- ì‚¬ì§„ì€ ì‚¬ì´íŠ¸ ìƒ· ë¯¸ë¦¬ë³´ê¸°ì—ì„œ ê¸¸ê²Œ ëˆŒëŸ¬ ë³µì‚¬/ì €ì¥ í›„ ChatGPTì— ì²¨ë¶€\n\n" +
      "[OCR TEXT START]\n" +
      text +
      "\n[OCR TEXT END]\n"
    );
  }

  async function copyAllText(){
    const text = (ocrBox.value || "").trim();
    if (!text){
      statusEl.textContent =
        "ë³µì‚¬í•  OCR í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ìë™ OCRì„ ì§„í–‰í•˜ì„¸ìš”.\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      return;
    }
    const payload = buildSharePayload(text);
    try{
      if (navigator.clipboard && navigator.clipboard.writeText){
        await navigator.clipboard.writeText(payload);
        statusEl.textContent =
          "OCR í…ìŠ¤íŠ¸ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆìŠµë‹ˆë‹¤. ChatGPTì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.\n" +
          "ì´ë¯¸ì§€ëŠ” ê° ìƒ· ë¯¸ë¦¬ë³´ê¸°ì—ì„œ ê¸¸ê²Œ ëˆŒëŸ¬ ë³µì‚¬/ì €ì¥ í›„ ì²¨ë¶€í•˜ì„¸ìš”.\n" +
          "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      }else{
        const tmp = document.createElement("textarea");
        tmp.value = payload;
        tmp.style.position = "fixed";
        tmp.style.left = "-9999px";
        document.body.appendChild(tmp);
        tmp.select();
        document.execCommand("copy");
        document.body.removeChild(tmp);
        statusEl.textContent =
          "ë³µì‚¬ ì‹œë„ ì™„ë£Œ. ë¶™ì—¬ë„£ê¸° ì•ˆ ë˜ë©´ OCR í…ìŠ¤íŠ¸ë¥¼ ì „ì²´ì„ íƒ í›„ ì§ì ‘ ë³µì‚¬í•˜ì„¸ìš”.\n" +
          "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      }
    }catch(e){
      statusEl.textContent =
        "ë³µì‚¬ ì‹¤íŒ¨: " + (e.message || String(e)) + "\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      showErrorOverlay("í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨", String(e && e.stack ? e.stack : e));
    }
  }

  function clearOcr(){
    if (!confirm("OCR ëˆ„ì  í…ìŠ¤íŠ¸ë¥¼ ëª¨ë‘ ì§€ìš°ê² ìŠµë‹ˆê¹Œ?")) return;
    ocrBox.value = "";
    statusEl.textContent =
      "OCR í…ìŠ¤íŠ¸ë¥¼ ì´ˆê¸°í™”í–ˆìŠµë‹ˆë‹¤. ìƒ· ë¯¸ë¦¬ë³´ê¸°ëŠ” ê·¸ëŒ€ë¡œ ë‚¨ì•„ ìˆìŠµë‹ˆë‹¤.\n" +
      "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
  }

  // ===== TTS: ë‹µì•ˆ ì½ê¸°(0.9ë°°ì† + ë‹¨ì–´ ì‚¬ì´ 6ì´ˆ ì¹¨ë¬µ + ë°˜ë³µ) =====
  function buildTokens(text){
    let t = String(text || "");
    t = t.replace(/\r/g, "");
    t = t.replace(/\./g, " ë§ˆì¹¨í‘œ ");
    const lines = t.split(/\n+/).map(x => x.trim()).filter(Boolean);
    const out = [];
    for (let i = 0; i < lines.length; i++){
      if (i > 0) out.push("ì¤„ë°”ê¿ˆ");
      const words = lines[i].split(/\s+/).filter(Boolean);
      for (const w of words) out.push(w);
    }
    return out;
  }

  function speakNextToken(){
    if (!synth) return;
    if (!ttsLoopActive || ttsStopFlag) return;

    if (!ttsTokens.length){
      ttsLoopActive = false;
      return;
    }

    if (ttsIndex >= ttsTokens.length){
      setTimeout(() => {
        if (!ttsLoopActive || ttsStopFlag) return;
        ttsIndex = 0;
        speakNextToken();
      }, LOOP_GAP_MS);
      return;
    }

    const token = ttsTokens[ttsIndex];
    const u = new SpeechSynthesisUtterance(token);
    u.lang = "ko-KR";
    u.rate = TTS_RATE;
    u.pitch = 1.0;

    u.onend = () => {
      if (ttsStopFlag) return;
      ttsIndex++;
      setTimeout(() => {
        speakNextToken();
      }, WORD_GAP_MS);
    };

    u.onerror = () => {
      if (ttsStopFlag) return;
      ttsIndex++;
      setTimeout(() => {
        speakNextToken();
      }, WORD_GAP_MS);
    };

    try{
      synth.speak(u);
    }catch(e){
      statusEl.textContent =
        "TTS ì˜¤ë¥˜: " + (e.message || String(e)) + "\n" +
        "TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
    }
  }

  function startTts(){
    if (!synth){
      statusEl.textContent = "ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” TTSë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
      return;
    }
    const text = (ttsInput.value || "").trim();
    if (!text){
      statusEl.textContent =
        "TTS ë°•ìŠ¤ì— ë‹µì•ˆì„ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      return;
    }

    try{ synth.cancel(); }catch(e){}
    ttsTokens = buildTokens(text);
    if (!ttsTokens.length){
      statusEl.textContent =
        "ì½ì„ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.\n" +
        "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
      return;
    }

    ttsIndex = 0;
    ttsStopFlag = false;
    ttsLoopActive = true;

    statusEl.textContent =
      "TTS ì‹œì‘: 0.9ë°°ì† + ë‹¨ì–´ ê°„ ì•½ 6ì´ˆ ì¹¨ë¬µ + ë°˜ë³µ.\n" +
      "ì•± ì „í™˜ í›„ ë¬´ìŒì´ë©´ 'ì½ê¸° ì‹œì‘' ë‹¤ì‹œ ëˆ„ë¥´ê¸° â†’ ê·¸ë˜ë„ ë¬´ìŒì´ë©´ ìƒˆë¡œê³ ì¹¨.\n" +
      "TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";

    speakNextToken();
  }

  function stopTts(){
    ttsStopFlag = true;
    ttsLoopActive = false;
    try{ if (synth) synth.cancel(); }catch(e){}
    statusEl.textContent =
      "TTSë¥¼ ì •ì§€í–ˆìŠµë‹ˆë‹¤.\n" +
      "â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
  }

  // í¬ê·¸ë¼ìš´ë“œ ë³µê·€ ì•ˆë‚´
  document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") return;
    statusEl.textContent =
      "ì•± ì „í™˜ í›„ ëŒì•„ì™”ìŠµë‹ˆë‹¤.\n" +
      "TTSê°€ ì•ˆ ë‚˜ì˜¤ë©´ 'ì½ê¸° ì‹œì‘'ì„ ë‹¤ì‹œ ëˆ„ë¥´ì„¸ìš”.\n" +
      "ê·¸ë˜ë„ ë¬´ìŒì´ë©´ ìƒˆë¡œê³ ì¹¨.\n" +
      "TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼";
  });

  // TTS ì…ë ¥ì°½ì— ë¶™ì—¬ë„£ìœ¼ë©´ ìë™ìœ¼ë¡œ ì½ê¸° ì‹œì‘ ì‹œë„
  ttsInput.addEventListener("paste", () => {
    setTimeout(() => {
      try{ startTts(); }catch(e){}
    }, 50);
  });

  // ë²„íŠ¼ ì´ë²¤íŠ¸
  btnAuto.addEventListener("click", () => {
    if (ocrAutoRunning){
      stopAutoOcr();
    }else{
      runAutoOcrLoop();
    }
  });
  btnCopyAll.addEventListener("click", copyAllText);
  btnCopyLastImg.addEventListener("click", copyLastImageToClipboard);
  btnClearOcr.addEventListener("click", clearOcr);
  btnTtsStart.addEventListener("click", startTts);
  btnTtsStop.addEventListener("click", stopTts);

  // ì‹œì‘
  startCamera();
})();
</script>
</body>
</html>
