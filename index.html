<!-- index.html (ë£¨íŠ¸ì— ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ê¸°) -->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Auto OCR â†’ Solve â†’ TTS</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 16px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button { padding:10px 12px; border:1px solid #ccc; border-radius:10px; background:#fff; }
    button.primary { border-color:#111; background:#111; color:#fff; }
    button.danger { border-color:#b00020; color:#b00020; }
    #videoWrap { position:relative; width:100%; max-width:520px; }
    video { width:100%; border-radius:12px; background:#000; }
    #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:48px; font-weight:800; text-shadow:0 2px 10px rgba(0,0,0,.6);
      pointer-events:none;
    }
    #log, #ocrOut, #ansOut { white-space:pre-wrap; background:#f7f7f7; padding:12px; border-radius:12px; border:1px solid #e5e5e5; }
    .small { color:#555; font-size:12px; }
    .ok { color:#0a7a00; }
    .warn { color:#b26a00; }
    .bad { color:#b00020; }
  </style>
</head>
<body>
  <h2>Auto OCR â†’ Solve â†’ TTS</h2>

  <div class="row">
    <button id="btnCam" class="primary">ì¹´ë©”ë¼ ì¼œê¸°</button>
    <button id="btnStart" class="primary" disabled>AUTO START</button>
    <button id="btnStop" class="danger" disabled>STOP</button>
    <button id="btnVoice">ğŸ”Š ìŒì„± ON(1íšŒ íƒ­)</button>
    <button id="btnSpeak" disabled>ğŸ” ì •ë‹µ ë‹¤ì‹œ ì½ê¸°(4íšŒ)</button>
  </div>

  <p class="small">
    STOP TOKEN: <b>ABCDEFGH</b> (ì´ ë¬¸ìê°€ OCRì—ì„œ ê°ì§€ë˜ë©´ ìë™ ì¢…ë£Œ í›„ /solve í˜¸ì¶œ)
  </p>

  <div id="videoWrap">
    <video id="video" playsinline autoplay muted></video>
    <div id="overlay"></div>
  </div>

  <h3>ìƒíƒœ / ë¡œê·¸</h3>
  <div id="log"></div>

  <h3>ëˆ„ì  OCR</h3>
  <div id="ocrOut"></div>

  <h3>ì •ë‹µ</h3>
  <div id="ansOut"></div>

<script>
(() => {
  // ====== ì„¤ì • ======
  const STOP_TOKEN = "ABCDEFGH";
  const SHOTS_PER_PAGE = 3;
  const COUNTDOWN_SEC = 5;
  const MAX_PAGES = 30; // ì•ˆì „ì¥ì¹˜

  // ====== ìƒíƒœ ======
  let stream = null;
  let running = false;
  let voiceUnlocked = false;
  let lastAnswerText = "";

  const el = {
    video: document.getElementById("video"),
    overlay: document.getElementById("overlay"),
    log: document.getElementById("log"),
    ocrOut: document.getElementById("ocrOut"),
    ansOut: document.getElementById("ansOut"),
    btnCam: document.getElementById("btnCam"),
    btnStart: document.getElementById("btnStart"),
    btnStop: document.getElementById("btnStop"),
    btnVoice: document.getElementById("btnVoice"),
    btnSpeak: document.getElementById("btnSpeak"),
  };

  function now() {
    const d = new Date();
    return d.toTimeString().slice(0,8);
  }
  function log(msg, cls="") {
    const line = `[${now()}] ${msg}`;
    el.log.textContent += (el.log.textContent ? "\n" : "") + line;
    el.log.scrollTop = el.log.scrollHeight;
    // ì½˜ì†”ì—ë„ ë‚¨ê¹€
    console.log(line);
  }

  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  function getPreviewInfo() {
    const w = el.video.videoWidth || 0;
    const h = el.video.videoHeight || 0;
    return { w, h };
  }

  async function initCamera() {
    if (stream) return;

    // iOSì—ì„œ ê³ í•´ìƒë„ ìœ ë„
    const constraints = {
      audio: false,
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 2560 },
        height: { ideal: 1440 },
      }
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    el.video.srcObject = stream;

    // ë©”íƒ€ ë¡œë”© ëŒ€ê¸°
    await new Promise(res => el.video.onloadedmetadata = res);
    el.video.play();

    const { w, h } = getPreviewInfo();
    log(`ì¹´ë©”ë¼ OK (${w}x${h})`);

    // í”„ë¦¬ë·° í’ˆì§ˆ ê²½ê³ 
    if (w && h && (Math.min(w,h) < 1400)) {
      log(`ê²½ê³ : í”„ë¦¬ë·° í•´ìƒë„ê°€ ë‚®ë‹¤(${w}x${h}). OCR ì •í™•ë„ê°€ í¬ê²Œ ë–¨ì–´ì§ˆ ìˆ˜ ìˆë‹¤.`, "warn");
      log(`ëŒ€ì‘: (1) ë” ë°ì€ ì¡°ëª… (2) í°-ì¢…ì´ ê±°ë¦¬ ëŠ˜ë¦¬ê³  ê½‰ ì±„ìš°ê¸° (3) ì‚¬íŒŒë¦¬/ë‹¤ë¥¸ ë¸Œë¼ìš°ì € ì¬ì‹œë„`, "warn");
    }

    el.btnStart.disabled = false;
  }

  function stopCamera() {
    if (!stream) return;
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }

  function captureJpegBlob() {
    const vw = el.video.videoWidth;
    const vh = el.video.videoHeight;
    if (!vw || !vh) throw new Error("video not ready");

    const canvas = document.createElement("canvas");
    canvas.width = vw;
    canvas.height = vh;
    const ctx = canvas.getContext("2d", { willReadFrequently: false });
    ctx.drawImage(el.video, 0, 0, vw, vh);

    return new Promise((resolve) => {
      canvas.toBlob((blob) => resolve(blob), "image/jpeg", 0.92);
    });
  }

  function blobToBase64(blob) {
    return new Promise((resolve, reject) => {
      const fr = new FileReader();
      fr.onload = () => resolve(fr.result); // data:image/jpeg;base64,...
      fr.onerror = reject;
      fr.readAsDataURL(blob);
    });
  }

  function cleanForStopDetect(s) {
    return (s || "").toUpperCase().replace(/\s+/g, "");
  }

  function stripStopToken(text) {
    // STOP í† í° ì¤„ì„ í†µì§¸ë¡œ ì œê±° (í˜¹ì‹œ ë¬¸ì¥ ì¤‘ê°„ì´ë©´ í† í° ì´í›„ë„ ì œê±°)
    const idx = text.toUpperCase().indexOf(STOP_TOKEN);
    if (idx === -1) return text;
    return text.slice(0, idx).trim();
  }

  function qualityScore(text) {
    // ê¸¸ì´ + ì•ŒíŒŒë²³ ë¹„ìœ¨ë¡œ ê°„ë‹¨ í’ˆì§ˆ ì ìˆ˜
    if (!text) return 0;
    const t = text.trim();
    const len = t.length;
    const letters = (t.match(/[A-Za-z]/g) || []).length;
    const ratio = len ? (letters / len) : 0;
    // ê¸¸ì´ê°€ ë„ˆë¬´ ì§§ìœ¼ë©´ ê°•í•˜ê²Œ íŒ¨ë„í‹°
    const base = Math.min(100, (len / 1500) * 70) + (ratio * 30);
    return Math.max(0, Math.min(100, base));
  }

  async function ocrImage(base64DataUrl) {
    const r = await fetch("/.netlify/functions/ocr", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ image: base64DataUrl })
    });
    const j = await r.json();
    if (!r.ok) throw new Error(j?.error || "OCR failed");
    return j; // { text, raw? }
  }

  async function solveText(fullText) {
    const r = await fetch("/.netlify/functions/solve", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: fullText })
    });
    const j = await r.json();
    if (!r.ok) throw new Error(j?.error || "SOLVE failed");
    return j; // { answers: { "1":"A"... }, answer_text, raw }
  }

  // ====== TTS (iOS ëŒ€ì‘: 1íšŒ íƒ­ìœ¼ë¡œ unlock) ======
  function speakNTimes(text, n=4) {
    if (!("speechSynthesis" in window)) {
      log("ì´ ë¸Œë¼ìš°ì €ëŠ” SpeechSynthesisë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤.", "bad");
      return;
    }
    if (!voiceUnlocked) {
      log("ìŒì„± ì ê¸ˆ ìƒíƒœ: 'ğŸ”Š ìŒì„± ON' ë²„íŠ¼ì„ 1íšŒ ëˆŒëŸ¬ì•¼ ì¬ìƒ ê°€ëŠ¥(iOS ì œí•œ).", "warn");
      return;
    }
    window.speechSynthesis.cancel();

    let count = 0;
    const run = () => {
      if (count >= n) return;
      const ut = new SpeechSynthesisUtterance(text);
      ut.lang = "ko-KR";
      ut.rate = 1.0;
      ut.pitch = 1.0;
      ut.onend = () => { count++; run(); };
      ut.onerror = (e) => {
        log("TTS ì˜¤ë¥˜: " + (e?.error || "unknown"), "bad");
      };
      window.speechSynthesis.speak(ut);
    };
    run();
  }

  async function unlockVoiceOnce() {
    try {
      if (!("speechSynthesis" in window)) {
        log("ì´ ë¸Œë¼ìš°ì €ëŠ” SpeechSynthesisë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤.", "bad");
        return;
      }
      // ì§§ì€ ë°œí™”ë¡œ ì‚¬ìš©ì ì œìŠ¤ì²˜ ë½ í•´ì œ
      window.speechSynthesis.cancel();
      const ut = new SpeechSynthesisUtterance("ìŒì„± ì•ˆë‚´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
      ut.lang = "ko-KR";
      ut.rate = 1.0;
      await new Promise((res) => {
        ut.onend = res;
        ut.onerror = res;
        window.speechSynthesis.speak(ut);
      });
      voiceUnlocked = true;
      log("ì •ë‹µ TTS ì‚¬ìš© ê°€ëŠ¥(ì–¸ë½ ì™„ë£Œ).", "ok");
    } catch (e) {
      log("ìŒì„± ì–¸ë½ ì‹¤íŒ¨: " + e.message, "bad");
    }
  }

  // ====== AUTO ë£¨í”„ ======
  async function countdown(sec) {
    for (let s = sec; s >= 1; s--) {
      el.overlay.textContent = String(s);
      await sleep(1000);
    }
    el.overlay.textContent = "";
  }

  async function runAuto() {
    if (!stream) await initCamera();
    running = true;
    el.btnStart.disabled = true;
    el.btnStop.disabled = false;

    el.ocrOut.textContent = "";
    el.ansOut.textContent = "";
    lastAnswerText = "";
    el.btnSpeak.disabled = true;

    log("AUTO START");

    let fullText = "";
    for (let page = 1; page <= MAX_PAGES && running; page++) {
      let best = { q: -1, text: "", shot: 0 };

      for (let shot = 1; shot <= SHOTS_PER_PAGE && running; shot++) {
        log(`í˜ì´ì§€ ${page} / ìƒ· ${shot} ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (${COUNTDOWN_SEC}s)`);
        await countdown(COUNTDOWN_SEC);

        const blob = await captureJpegBlob();
        const b64 = await blobToBase64(blob);

        let ocr;
        try {
          ocr = await ocrImage(b64);
        } catch (e) {
          log(`OCR FAIL page=${page} shot=${shot} err=${e.message}`, "bad");
          continue;
        }

        const t = (ocr.text || "");
        const q = qualityScore(t);
        log(`OCR OK page=${page} shot=${shot} len=${t.length} q=${q.toFixed(1)}`);

        if (q > best.q) best = { q, text: t, shot };

        // STOP í† í°ì´ ìƒ· ë‹¨ìœ„ì—ì„œ ì´ë¯¸ ë³´ì´ë©´ í˜ì´ì§€ ë£¨í”„ ëë‚´ë„ ë¨
        if (cleanForStopDetect(t).includes(STOP_TOKEN)) break;
      }

      log(`í˜ì´ì§€ ${page} ì™„ë£Œ (best q=${best.q.toFixed(1)}, shot=${best.shot})`);

      // ëˆ„ì  ê¸°ë¡
      fullText += `\n\n[PAGE ${page}]\n` + best.text.trim() + "\n";
      el.ocrOut.textContent = fullText.trim();

      // STOP ê°ì§€
      if (cleanForStopDetect(best.text).includes(STOP_TOKEN)) {
        log(`STOP TOKEN ê°ì§€ (${STOP_TOKEN}) â†’ ì¢…ë£Œ`);
        fullText = stripStopToken(fullText);
        break;
      }
    }

    running = false;
    el.btnStop.disabled = true;

    // solve í˜¸ì¶œ
    const trimmed = (fullText || "").trim();
    if (trimmed.length < 300) {
      log("ì •ë‹µ ê³„ì‚° ì¤‘ë‹¨: ëˆ„ì  OCR í…ìŠ¤íŠ¸ê°€ ë„ˆë¬´ ì§§ë‹¤(ì´¬ì˜/STOP ì„¤ì • í™•ì¸).", "bad");
      el.btnStart.disabled = false;
      return;
    }

    log("ì •ë‹µ ê³„ì‚° ì‹œì‘ (/solve í˜¸ì¶œ)");
    let solved;
    try {
      solved = await solveText(trimmed);
    } catch (e) {
      log("ì •ë‹µ ê³„ì‚° ì‹¤íŒ¨: " + e.message, "bad");
      el.btnStart.disabled = false;
      return;
    }

    // í™”ë©´ í‘œì‹œ
    const answers = solved.answers || {};
    const keys = Object.keys(answers).map(k => Number(k)).filter(n => !Number.isNaN(n)).sort((a,b)=>a-b);
    let pretty = "";
    for (const k of keys) pretty += `${k}ë²ˆ: ${answers[String(k)]}\n`;

    lastAnswerText = pretty.trim();
    el.ansOut.textContent = lastAnswerText || JSON.stringify(solved, null, 2);

    log("ì •ë‹µ ìˆ˜ì‹  OK");
    el.btnSpeak.disabled = !voiceUnlocked;

    // ìë™ 4íšŒ ì½ê¸°
    if (voiceUnlocked && lastAnswerText) {
      log("ì •ë‹µ TTS 4íšŒ ì¬ìƒ ì‹œì‘");
      speakNTimes(lastAnswerText, 4);
    } else {
      log("TTS ë¯¸ì¬ìƒ: iOS ì œí•œìœ¼ë¡œ 'ğŸ”Š ìŒì„± ON' ë²„íŠ¼ 1íšŒ íƒ­ í•„ìš”", "warn");
    }

    el.btnStart.disabled = false;
  }

  function stopAuto() {
    running = false;
    el.overlay.textContent = "";
    log("STOP(ì‚¬ìš©ì)");
    el.btnStop.disabled = true;
    el.btnStart.disabled = false;
  }

  // ====== ì´ë²¤íŠ¸ ======
  el.btnCam.onclick = async () => {
    try { await initCamera(); }
    catch (e) { log("ì¹´ë©”ë¼ ì‹¤íŒ¨: " + e.message, "bad"); }
  };
  el.btnStart.onclick = async () => {
    try { await runAuto(); }
    catch (e) { log("AUTO ì˜¤ë¥˜: " + e.message, "bad"); running=false; el.btnStart.disabled=false; el.btnStop.disabled=true; }
  };
  el.btnStop.onclick = stopAuto;

  el.btnVoice.onclick = async () => {
    await unlockVoiceOnce();
    el.btnSpeak.disabled = !voiceUnlocked;
  };

  el.btnSpeak.onclick = () => {
    if (lastAnswerText) speakNTimes(lastAnswerText, 4);
  };
})();
</script>
</body>
</html>
