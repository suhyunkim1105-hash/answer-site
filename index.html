<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì—°ì„¸ëŒ€ ë…¼ìˆ  OCR â†’ ë³µë¶™ â†’ TTS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <style>
    * { box-sizing: border-box; }
    body {
      margin:0;
      padding:10px;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      background:#050505;
      color:#f5f5f5;
    }
    h1 {
      font-size:16px;
      margin:0 0 8px;
    }
    #status {
      font-size:12px;
      padding:8px;
      border-radius:10px;
      border:1px solid #333;
      background:#080808;
      white-space:pre-wrap;
      min-height:36px;
    }
    .btnRow {
      margin-top:8px;
      display:flex;
      gap:8px;
    }
    button {
      flex:1;
      padding:10px 8px;
      font-size:13px;
      border-radius:10px;
      border:1px solid #555;
      background:#151515;
      color:#f8f8f8;
    }
    button:active {
      transform:scale(0.97);
    }
    .smallHint {
      margin-top:6px;
      font-size:11px;
      color:#bbb;
    }
    #videoBox {
      margin-top:10px;
      border-radius:10px;
      border:1px solid #333;
      overflow:hidden;
      background:#000;
    }
    video {
      width:100%;
      height:auto;
      display:block;
    }
    textarea {
      width:100%;
      margin-top:8px;
      padding:10px;
      border-radius:10px;
      border:1px solid #333;
      background:#060606;
      color:#f5f5f5;
      font-size:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
      min-height:120px;
    }
    #errOverlay {
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.9);
      color:#fff;
      padding:14px;
      display:none;
      z-index:9999;
      overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }
    #errOverlay button {
      margin-top:10px;
      width:auto;
    }
  </style>
</head>

<body>
  <div id="errOverlay"></div>

  <h1>ì—°ì„¸ëŒ€ ë…¼ìˆ  OCR â†’ ë³µë¶™ â†’ TTS</h1>

  <div class="btnRow">
    <button id="btnAuto">ğŸ“¸ ìë™ OCR ì‹œì‘/ì •ì§€</button>
    <button id="btnCopyOcr">ğŸ“‹ OCR ì „ì²´ í…ìŠ¤íŠ¸ ë³µì‚¬</button>
    <button id="btnClearOcr">ğŸ§¹ OCR í…ìŠ¤íŠ¸ ì§€ìš°ê¸°</button>
  </div>
  <div class="btnRow">
    <button id="btnStartTts">ğŸ”Š TTS ì‹œì‘/ì •ì§€</button>
    <button id="btnClearTts">ğŸ§¹ TTS í…ìŠ¤íŠ¸ ì§€ìš°ê¸°</button>
  </div>

  <div id="status">ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...</div>
  <div class="smallHint">â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼.</div>

  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <textarea id="ocrBox" placeholder="ì—¬ê¸°ì— ìë™ OCRë¡œ ëˆ„ì ëœ ì‹œí—˜ì§€ í…ìŠ¤íŠ¸ê°€ ë“¤ì–´ì˜¨ë‹¤. (ë„í‘œ í˜ì´ì§€ ìœ„ì—ëŠ” ì§ì ‘ 'ë„í‘œì…ë‹ˆë‹¤ ì œì‹œë¬¸ (ë¼)'ì²˜ëŸ¼ í¬ê²Œ ì¨ ë‘ë©´ ì¢‹ìŒ.)"></textarea>
  <textarea id="ttsBox" placeholder="ì—¬ê¸°ì— ChatGPT ìµœì¢… ë‹µì•ˆì„ ë¶™ì—¬ë„£ìœ¼ë©´ TTSë¡œ ê³„ì† ë°˜ë³µ ì¬ìƒëœë‹¤."></textarea>

<script>
(function(){
  const OCR_URL = "/.netlify/functions/ocr";

  const errOverlay = document.getElementById("errOverlay");
  const statusEl   = document.getElementById("status");
  const video      = document.getElementById("video");
  const ocrBox     = document.getElementById("ocrBox");
  const ttsBox     = document.getElementById("ttsBox");

  const btnAuto     = document.getElementById("btnAuto");
  const btnCopyOcr  = document.getElementById("btnCopyOcr");
  const btnClearOcr = document.getElementById("btnClearOcr");
  const btnStartTts = document.getElementById("btnStartTts");
  const btnClearTts = document.getElementById("btnClearTts");

  // ===== ê³µí†µ: ì—ëŸ¬ ì˜¤ë²„ë ˆì´ =====
  function showErrorOverlay(title, detail){
    try{
      errOverlay.style.display = "block";
      errOverlay.textContent = "[ERROR]\n" + (title || "") + "\n\n" + (detail || "") + "\n\n(ë‹«ê¸° ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”)";
      const br = document.createElement("br");
      const b  = document.createElement("button");
      b.textContent = "ë‹«ê¸°";
      b.onclick = () => { errOverlay.style.display = "none"; errOverlay.innerHTML = ""; };
      errOverlay.appendChild(br);
      errOverlay.appendChild(b);
    }catch(e){}
  }

  window.addEventListener("error", (e) => {
    showErrorOverlay(e.message || "Unknown JS error", (e.error && e.error.stack) ? e.error.stack : "");
  });
  window.addEventListener("unhandledrejection", (e) => {
    const msg = (e && e.reason) ? (e.reason.message || String(e.reason)) : "Unhandled rejection";
    const stack = (e && e.reason && e.reason.stack) ? e.reason.stack : "";
    showErrorOverlay(msg, stack);
  });

  // ===== ì¹´ë©”ë¼ =====
  let stream = null;

  async function startCamera(){
    try{
      statusEl.textContent = "ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­ ì¤‘...";
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width:  { ideal: 1920 },
          height: { ideal: 1080 }
        },
        audio:false
      });
      video.srcObject = stream;
      statusEl.textContent = "ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ. ìë™ OCR ì‹œì‘ ë²„íŠ¼ì„ ëˆ„ë¥´ì„¸ìš”.";
    }catch(e){
      statusEl.textContent = "ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨: " + (e.message || String(e));
      showErrorOverlay("ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨", e && e.stack ? e.stack : String(e));
    }
  }

  function captureFrameDataUrl(){
    const w = video.videoWidth;
    const h = video.videoHeight;
    if(!w || !h) return null;

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);
    return canvas.toDataURL("image/jpeg", 0.9);
  }

  // ===== OCR ê´€ë¦¬ =====
  const MAX_PAGES = 12;
  const SHOTS_PER_PAGE = 3;

  let autoRunning = false;
  let autoLoopBusy = false;
  let currentPage = 1;

  // í˜ì´ì§€ë³„ best ê²°ê³¼
  const pageResults = [];  // [{pageIndex, bestText, bestConf}]
  const shots = [];        // [{pageIndex, imageDataUrl, text, conf, hasGraphMark, isLastPageHint}]

  function delay(ms){
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  async function callOcrApi(imageDataUrl, pageIndex){
    try{
      const res = await fetch(OCR_URL, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({
          imageBase64: imageDataUrl,
          pageIndex,
          mode:"dual"
        })
      });
      const json = await res.json().catch(() => null);
      if(!json){
        return { ok:false, text:"", conf:0 };
      }
      if(!json.ok){
        return { ok:false, text:"", conf:0, error: json.error || json.message || "OCR ì‹¤íŒ¨" };
      }
      return {
        ok:true,
        text: json.text || "",
        conf: typeof json.conf === "number" ? json.conf : 0
      };
    }catch(e){
      console.error(e);
      return { ok:false, text:"", conf:0, error: e.message || String(e) };
    }
  }

  function rebuildOcrTextarea(){
    pageResults.sort((a,b) => a.pageIndex - b.pageIndex);
    const blocks = pageResults.map(p => {
      return "[í˜ì´ì§€ " + p.pageIndex + "] ------------------\n" + (p.bestText || "");
    });
    ocrBox.value = blocks.join("\n\n");
  }

  function setPageBestResult(pageIndex, text, conf){
    const idx = pageResults.findIndex(p => p.pageIndex === pageIndex);
    if(idx >= 0){
      if(conf > (pageResults[idx].bestConf || 0)){
        pageResults[idx].bestText = text;
        pageResults[idx].bestConf = conf;
      }
    }else{
      pageResults.push({ pageIndex, bestText:text, bestConf:conf });
    }
  }

  function hasLastPageHint(text){
    if(!text) return false;
    return text.indexOf("ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤") !== -1;
  }

  function hasGraphMark(text){
    if(!text) return false;
    return text.indexOf("ë„í‘œì…ë‹ˆë‹¤") !== -1;
  }

  async function ocrOnePage(pageIndex){
    let bestText = "";
    let bestConf = 0;
    let lastPageFlag = false;

    for(let i=0;i<SHOTS_PER_PAGE && autoRunning;i++){
      statusEl.textContent = "í˜ì´ì§€ " + pageIndex + " OCR ì¤‘... (" + (i+1) + "/" + SHOTS_PER_PAGE + ")";
      const dataUrl = captureFrameDataUrl();
      if(!dataUrl){
        statusEl.textContent = "ì¹´ë©”ë¼ ì˜ìƒ ì¤€ë¹„ ì¤‘... ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„";
        await delay(800);
        i--;
        continue;
      }

      const result = await callOcrApi(dataUrl, pageIndex);
      if(!result.ok){
        // ì‹¤íŒ¨ shotì€ ê·¸ëƒ¥ ë„˜ì–´ê°€ê³  ë‹¤ìŒ ì‹œë„
        continue;
      }

      const text = (result.text || "").trim();
      const conf = result.conf || 0;

      shots.push({
        pageIndex,
        imageDataUrl: dataUrl,
        text,
        conf,
        hasGraphMark: hasGraphMark(text),
        isLastPageHint: hasLastPageHint(text)
      });

      if(text && (conf > bestConf || !bestText)){
        bestText = text;
        bestConf  = conf;
      }

      if(hasLastPageHint(text)){
        lastPageFlag = true;
      }
    }

    if(bestText){
      setPageBestResult(pageIndex, bestText, bestConf);
      rebuildOcrTextarea();
      statusEl.textContent = "í˜ì´ì§€ " + pageIndex + " OCR ì™„ë£Œ (ëŒ€ëµ ì‹ ë¢°ë„ " + bestConf.toFixed(1) + "%)";
    }else{
      statusEl.textContent = "í˜ì´ì§€ " + pageIndex + " OCR ì‹¤íŒ¨(ìµœëŒ€ " + SHOTS_PER_PAGE + "íšŒ ì‹œë„).";
    }

    return lastPageFlag;
  }

  async function speakCountdown(){
    primeTts();
    simpleSpeak("ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ì£¼ì„¸ìš”. 5ì´ˆ ë’¤ì— ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.");
    await delay(1000);
    for(let n=5;n>=1 && autoRunning;n--){
      simpleSpeak(String(n));
      await delay(1000);
    }
  }

  async function runAutoLoop(){
    if(autoLoopBusy) return;
    autoLoopBusy = true;
    primeTts();
    statusEl.textContent = "ìë™ OCR ì‹œì‘.";
    simpleSpeak("ìë™ ì˜¤ ì”¨ ì•Œì„ ì‹œì‘í•©ë‹ˆë‹¤.");

    currentPage = 1;

    while(autoRunning && currentPage <= MAX_PAGES){
      const isLast = await ocrOnePage(currentPage);
      if(!autoRunning) break;

      if(isLast){
        statusEl.textContent = "ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤ ë¬¸êµ¬ê°€ ê°ì§€ë˜ì–´ OCRì„ ì¢…ë£Œí•©ë‹ˆë‹¤.";
        simpleSpeak("ëª¨ë“  í˜ì´ì§€ ì˜¤ ì”¨ ì•Œì´ ëë‚¬ìŠµë‹ˆë‹¤. ì´ì œ ì±„ì°ì§€ í”¼í‹°ë¡œ ë³µì‚¬í•´ì„œ í’€ì´ë¥¼ ì‹œì‘í•˜ì„¸ìš”.");
        break;
      }

      // ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ì–´ê°€ê¸°
      currentPage++;
      if(currentPage > MAX_PAGES){
        statusEl.textContent = "ìµœëŒ€ í˜ì´ì§€ ìˆ˜ì— ë„ë‹¬í•˜ì—¬ OCRì„ ì¢…ë£Œí•©ë‹ˆë‹¤.";
        simpleSpeak("ìµœëŒ€ í˜ì´ì§€ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤. ì˜¤ ì”¨ ì•Œì„ ë§ˆì¹©ë‹ˆë‹¤.");
        break;
      }

      statusEl.textContent = "ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ì£¼ì„¸ìš”. ê³§ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.";
      await speakCountdown();
    }

    autoRunning = false;
    autoLoopBusy = false;
  }

  // ===== TTS (í”„ë¡¬í”„íŠ¸ìš© ì§§ì€ ë©˜íŠ¸, ë‹µì•ˆ ë°˜ë³µ TTS) =====
  let ttsPrimed = false;

  function primeTts(){
    if(ttsPrimed) return;
    ttsPrimed = true;
    try{
      const u = new SpeechSynthesisUtterance("ìŒì„± ì‹œì‘");
      u.lang = "ko-KR";
      u.rate = 1.0;
      u.onend = () => { window.speechSynthesis.cancel(); };
      window.speechSynthesis.speak(u);
    }catch(e){}
  }

  function simpleSpeak(text){
    try{
      if(!window.speechSynthesis) return;
      const u = new SpeechSynthesisUtterance(String(text || ""));
      u.lang = "ko-KR";
      u.rate = 1.0;
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    }catch(e){}
  }

  let ttsRunning = false;
  const ANSWER_RATE = 0.9;

  function speakAnswerLoop(){
    if(!ttsRunning) return;

    const text = (ttsBox.value || "").trim();
    if(!text){
      statusEl.textContent = "TTS: ì½ì„ í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.";
      ttsRunning = false;
      return;
    }

    try{
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "ko-KR";
      u.rate = ANSWER_RATE;

      u.onend = () => {
        if(ttsRunning){
          // ì•½ê°„ì˜ í…€ì„ ë‘ê³  ë‹¤ì‹œ ì „ì²´ ë°˜ë³µ
          setTimeout(speakAnswerLoop, 400);
        }
      };
      u.onerror = () => {
        ttsRunning = false;
      };

      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    }catch(e){
      ttsRunning = false;
    }
  }

  // ===== ë²„íŠ¼ ì´ë²¤íŠ¸ =====
  btnAuto.addEventListener("click", () => {
    primeTts();
    if(!autoRunning){
      autoRunning = true;
      runAutoLoop();
    }else{
      autoRunning = false;
      statusEl.textContent = "ìë™ OCR ìˆ˜ë™ ì¤‘ì§€ë¨.";
      simpleSpeak("ìë™ ì˜¤ ì”¨ ì•Œì„ ì¤‘ì§€í–ˆìŠµë‹ˆë‹¤.");
    }
  });

  btnCopyOcr.addEventListener("click", async () => {
    try{
      const text = ocrBox.value || "";
      await navigator.clipboard.writeText(text);
      statusEl.textContent = "OCR ì „ì²´ í…ìŠ¤íŠ¸ë¥¼ í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆìŠµë‹ˆë‹¤.";
    }catch(e){
      statusEl.textContent = "í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨: " + (e.message || String(e));
    }
  });

  btnClearOcr.addEventListener("click", () => {
    ocrBox.value = "";
    statusEl.textContent = "OCR í…ìŠ¤íŠ¸ë¥¼ ëª¨ë‘ ì§€ì› ìŠµë‹ˆë‹¤.";
  });

  btnStartTts.addEventListener("click", () => {
    primeTts();
    if(!ttsRunning){
      ttsRunning = true;
      speakAnswerLoop();
    }else{
      ttsRunning = false;
      window.speechSynthesis.cancel();
    }
  });

  btnClearTts.addEventListener("click", () => {
    ttsBox.value = "";
  });

  // ===== ì‹œì‘ =====
  startCamera();
})();
</script>
</body>
</html>
