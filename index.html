<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Auto OCR (누적) → Auto Solve + TTS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <!-- Tesseract v5 -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 10px;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    .wrap { max-width: 980px; margin: 0 auto; }
    #videoBox {
      position: relative;
      width: 100%;
      border: 1px solid #333;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
    }
    #video {
      width: 100%;
      height: auto;
      display: block;
    }
    #overlay {
      position: absolute;
      inset: 0;
      border: 2px solid rgba(0, 255, 0, 0.35);
      pointer-events: none;
    }
    #status {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #111;
      font-size: 13px;
      line-height: 1.45;
      white-space: pre-wrap;
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .panel {
      border: 1px solid #333;
      border-radius: 10px;
      background: #0b0b0b;
      padding: 10px;
    }
    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #cfcfcf;
      font-weight: 600;
    }
    textarea, pre {
      width: 100%;
      border: 1px solid #222;
      border-radius: 8px;
      background: #000;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 10px;
      margin: 0;
    }
    textarea { height: 240px; resize: vertical; }
    pre { min-height: 240px; white-space: pre-wrap; }
    .hint {
      margin-top: 6px;
      font-size: 12px;
      color: #aaa;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="videoBox">
      <video id="video" autoplay playsinline></></video>
      <div id="overlay"></div>
    </div>

    <div id="status">초기화 중...</div>

    <div class="grid">
      <div class="panel">
        <h3>누적 OCR 미리보기</h3>
        <textarea id="ocrPreview" readonly></textarea>
        <div class="hint">
          iOS 음성(TTS) 팁: 화면을 한 번 탭 + 무음모드 해제 + 볼륨 올리기.
        </div>
      </div>

      <div class="panel">
        <h3>답안</h3>
        <pre id="answerBox"></pre>
      </div>
    </div>
  </div>

<script>
(function () {
  // =========================
  // 0) 설정값
  // =========================
  const OCR_INTERVAL_MS = 3000;

  // 최소 풀이 가능 길이 (너무 짧으면 절대 안 풀기)
  const MIN_SOLVE_LEN_EFFECTIVE = 900;

  // 너가 말한 권장 기준: 2000자 근처
  const TEXT_THRESHOLD_EFFECTIVE = 2000;

  // 지문 부족 안내: 연속 5분
  const INSUFFICIENT_WARN_MS = 5 * 60 * 1000;

  // 최대 기다림: 연속 8분이면 부족해도 풀이
  const MAX_WAIT_MS = 8 * 60 * 1000;

  // solve 함수 (solve.js는 { ocrText } 받는 버전)
  const SOLVE_URL = "/.netlify/functions/solve";

  // OCR 언어
  const OCR_LANG = "kor+eng";

  // TTS
  const TTS_ENABLED = true;
  const TTS_RATE = 1.03;
  const TTS_PITCH = 1.0;
  const TTS_STATUS_COOLDOWN_MS = 15000;

  // 디지털 줌 (크롭) — 기본은 완전 줌아웃
  let cropFactor = 1.00; // 1.00 = 가장 넓게
  const CROP_MIN = 0.70; // 최대 확대
  const CROP_MAX = 1.00;
  const CROP_ADJUST_COOLDOWN_MS = 5000;
  let lastCropAdjustAt = 0;

  // =========================
  // 1) DOM
  // =========================
  const video = document.getElementById("video");
  const statusEl = document.getElementById("status");
  const ocrPreviewEl = document.getElementById("ocrPreview");
  const answerBoxEl = document.getElementById("answerBox");

  // =========================
  // 2) 상태
  // =========================
  let stream = null;
  let ocrRunning = false;
  let lastOcrAt = 0;

  // 누적 OCR 세그먼트
  let segments = []; // { text, effLen, conf }
  let accText = "";
  let accEffectiveLen = 0;
  let accBestConf = 0;

  // 카메라/거리 상태
  let blocked = false;
  let tooNear = false;
  let tooFar = false;

  // “아직 완료 아님”이 얼마나 오래 이어지는지
  let notReadySince = null;

  // solve 상태
  let solved = false;
  let solving = false;

  // TTS 상태
  let lastStatusSpokenAt = 0;
  let audioUnlocked = false;
  let voicesReady = false;

  // 움직임/밝기 분석용 캔버스
  const BW = 64;
  const BH = 36;
  const bCanvas = document.createElement("canvas");
  bCanvas.width = BW;
  bCanvas.height = BH;
  const bCtx = bCanvas.getContext("2d", { willReadFrequently: true });
  let prevThumb = null;
  let lastStableStart = 0;

  // OCR 캡처용 캔버스
  const capCanvas = document.createElement("canvas");
  const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

  // =========================
  // 3) 공통 유틸
  // =========================
  function now() {
    return Date.now();
  }

  function effectiveLenOf(text) {
    return (text || "").replace(/\s/g, "").length;
  }

  function setStatus(lines) {
    statusEl.textContent = lines.join("\n");
  }

  function normalizeOcrText(text) {
    let t = String(text || "");
    t = t.replace(/-\s*\n\s*/g, "");
    t = t.replace(/[ \t]+\n/g, "\n");
    t = t.replace(/\n[ \t]+/g, "\n");
    t = t.replace(/[ \t]{2,}/g, " ");
    t = t.replace(/[\u0000-\u001F\u007F]/g, "");
    t = t.replace(/[■□▢●◆◇]{2,}/g, " ");
    return t.trim();
  }

  // =========================
  // 4) TTS 관련
  // =========================
  function initVoices() {
    if (!("speechSynthesis" in window)) return;
    function tryLoad() {
      var v = window.speechSynthesis.getVoices();
      if (v && v.length) {
        voicesReady = true;
      }
    }
    tryLoad();
    window.speechSynthesis.onvoiceschanged = function () {
      var v = window.speechSynthesis.getVoices();
      if (v && v.length) {
        voicesReady = true;
      }
    };
  }

  function chooseKoreanVoice() {
    if (!("speechSynthesis" in window)) return null;
    var voices = window.speechSynthesis.getVoices() || [];
    var i;
    for (i = 0; i < voices.length; i++) {
      if ((voices[i].lang || "").toLowerCase().indexOf("ko") === 0) {
        return voices[i];
      }
    }
    return voices.length ? voices[0] : null;
  }

  function speak(text, force) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    var t = (text || "").trim();
    if (!t) return;

    var tNow = now();
    if (!force && tNow - lastStatusSpokenAt < TTS_STATUS_COOLDOWN_MS) return;

    function doSpeak() {
      try {
        window.speechSynthesis.cancel();
        var u = new SpeechSynthesisUtterance(t);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        var v = chooseKoreanVoice();
        if (v) u.voice = v;
        lastStatusSpokenAt = tNow;
        window.speechSynthesis.speak(u);
      } catch (e) {}
    }

    if (!voicesReady) {
      setTimeout(doSpeak, 250);
    } else {
      doSpeak();
    }
  }

  function speakLong(text) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    var t = (text || "").trim();
    if (!t) return;

    var chunkSize = 900;
    var chunks = [];
    var i;
    for (i = 0; i < t.length; i += chunkSize) {
      chunks.push(t.slice(i, i + chunkSize));
    }

    try {
      window.speechSynthesis.cancel();
      var idx = 0;
      var v = chooseKoreanVoice();

      function speakNext() {
        if (idx >= chunks.length) return;
        var u = new SpeechSynthesisUtterance(chunks[idx]);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        if (v) u.voice = v;
        u.onend = function () {
          idx += 1;
          speakNext();
        };
        window.speechSynthesis.speak(u);
      }

      setTimeout(speakNext, voicesReady ? 0 : 300);
    } catch (e) {}
  }

  function unlockAudioOnce() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    if (!TTS_ENABLED) return;
    speak("음성이 활성화되었습니다.", true);
  }

  // =========================
  // 5) 움직임/밝기/가려짐 분석
  // =========================
  function analyzeFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      return { blocked: false, stable: false, avgBright: 255, diffAvg: 0 };
    }

    bCtx.drawImage(video, 0, 0, BW, BH);
    var img = bCtx.getImageData(0, 0, BW, BH).data;

    var len = BW * BH;
    var currThumb = new Uint8Array(len);
    var sumBright = 0;
    var diffSum = 0;
    var i;
    var p = 0;

    for (i = 0; i < img.length; i += 4) {
      var r = img[i];
      var g = img[i + 1];
      var b = img[i + 2];
      var gray = (r + g + b) / 3;
      currThumb[p] = gray;
      sumBright += gray;
      if (prevThumb) {
        diffSum += Math.abs(gray - prevThumb[p]);
      }
      p++;
    }

    var avgBright = sumBright / len;
    var diffAvg = prevThumb ? diffSum / len : 0;
    prevThumb = currThumb;

    var isBlocked = avgBright < 20;
    var tNow = now();
    var stable = false;

    if (diffAvg < 8) {
      if (!lastStableStart) {
        lastStableStart = tNow;
      } else if (tNow - lastStableStart >= 900) {
        stable = true;
      }
    } else {
      lastStableStart = 0;
    }

    return { blocked: isBlocked, stable: stable, avgBright: avgBright, diffAvg: diffAvg };
  }

  function analyzeLoop() {
    var a = analyzeFrame();
    blocked = a.blocked;
    requestAnimationFrame(analyzeLoop);
  }

  // =========================
  // 6) 캡처(영상 → 캔버스) + 디지털 줌
  // =========================
  function captureToCanvas() {
    var vw = video.videoWidth;
    var vh = video.videoHeight;

    if (!vw || !vh) {
      capCanvas.width = 640;
      capCanvas.height = 360;
      capCtx.fillStyle = "black";
      capCtx.fillRect(0, 0, capCanvas.width, capCanvas.height);
      return capCanvas;
    }

    var scaleCrop = cropFactor; // 1.0 = 줌아웃, 0.7 = 확대
    var cropW = Math.floor(vw * scaleCrop);
    var cropH = Math.floor(vh * scaleCrop);
    var cropX = Math.floor((vw - cropW) / 2);
    var cropY = Math.floor((vh - cropH) / 2);

    var maxW = 1920;
    var scale = Math.min(1, maxW / cropW);
    var outW = Math.max(360, Math.floor(cropW * scale));
    var outH = Math.max(240, Math.floor(cropH * scale));

    capCanvas.width = outW;
    capCanvas.height = outH;

    capCtx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, outW, outH);
    return capCanvas;
  }

  function adjustCropByDistance() {
    var tNow = now();
    if (tNow - lastCropAdjustAt < CROP_ADJUST_COOLDOWN_MS) return;

    if (tooNear) {
      cropFactor = Math.max(CROP_MIN, cropFactor - 0.03); // 살짝 확대
    } else {
      // 기본은 완전 줌아웃 유지
      cropFactor = CROP_MAX;
    }
    lastCropAdjustAt = tNow;
  }

  // =========================
  // 7) 누적 OCR + 중복 처리
  // =========================
  function tokenize(text) {
    var t = (text || "").slice(0, 1500);
    var arr = t.split(/\s+/);
    var out = [];
    var i;
    for (i = 0; i < arr.length; i++) {
      if (arr[i]) out.push(arr[i]);
    }
    if (out.length > 220) return out.slice(0, 220);
    return out;
  }

  function jaccardSimilarity(a, b) {
    var A = tokenize(a);
    var B = tokenize(b);
    if (!A.length || !B.length) return 0;

    var setA = {};
    var setB = {};
    var i;
    for (i = 0; i < A.length; i++) setA[A[i]] = true;
    for (i = 0; i < B.length; i++) setB[B[i]] = true;

    var inter = 0;
    for (var key in setA) {
      if (setB[key]) inter++;
    }

    var sizeA = 0;
    var sizeB = 0;
    for (var k1 in setA) sizeA++;
    for (var k2 in setB) sizeB++;
    var union = sizeA + sizeB - inter;
    if (!union) return 0;
    return inter / union;
  }

  function rebuildAccumulated() {
    var texts = [];
    var i;
    for (i = 0; i < segments.length; i++) {
      texts.push(segments[i].text);
    }
    accText = texts.join("\n\n");
    accEffectiveLen = effectiveLenOf(accText);

    accBestConf = 0;
    for (i = 0; i < segments.length; i++) {
      if (typeof segments[i].conf === "number" && segments[i].conf > accBestConf) {
        accBestConf = segments[i].conf;
      }
    }

    var maxPreview = 8000;
    if (accText.length <= maxPreview) {
      ocrPreviewEl.value = accText;
    } else {
      ocrPreviewEl.value = accText.slice(-maxPreview);
    }
  }

  function updateAccumulation(newText, newConf) {
    var cleaned = normalizeOcrText(newText);
    var effLen = effectiveLenOf(cleaned);
    if (effLen < 20) {
      return { changed: false, action: "ignore_too_short" };
    }
    if (newConf < 5) {
      return { changed: false, action: "ignore_low_conf" };
    }

    if (!segments.length) {
      segments.push({ text: cleaned, effLen: effLen, conf: newConf });
      rebuildAccumulated();
      return { changed: true, action: "append_first" };
    }

    var last = segments[segments.length - 1];
    var sim = jaccardSimilarity(last.text, cleaned);
    var DUP_SIMILARITY = 0.75;
    if (sim >= DUP_SIMILARITY) {
      var better =
        (effLen > last.effLen + 60) ||
        (Math.abs(effLen - last.effLen) <= 60 && newConf > last.conf + 4);

      if (better) {
        segments[segments.length - 1] = { text: cleaned, effLen: effLen, conf: newConf };
        rebuildAccumulated();
        return { changed: true, action: "replace_last(sim=" + sim.toFixed(2) + ")" };
      } else {
        return { changed: false, action: "dup_keep_last(sim=" + sim.toFixed(2) + ")" };
      }
    }

    segments.push({ text: cleaned, effLen: effLen, conf: newConf });
    if (segments.length > 12) {
      segments = segments.slice(segments.length - 12);
    }
    rebuildAccumulated();
    return { changed: true, action: "append_new(sim=" + sim.toFixed(2) + ")" };
  }

  // =========================
  // 8) 구조/제시문 인식
  // =========================
  function hasProblemStructure(text) {
    var t = text || "";
    var reQ1 = /(\[\s*문제\s*1\s*\]|문제\s*1\s*[\.\)]|1\)\s)/;
    var reQ2 = /(\[\s*문제\s*2\s*\]|문제\s*2\s*[\.\)]|2\)\s)/;
    var hasQ1 = reQ1.test(t);
    var hasQ2 = reQ2.test(t);
    return hasQ1 && hasQ2;
  }

  function hasPassageHint(text) {
    var t = text || "";
    var re = /(제시문\s*[ⅠI1]|\b제시문\s*\d|\b제시문\b|보기|다음\s*글|다음은|자료\s*\d)/;
    return re.test(t);
  }

  function isReadyToSolve() {
    if (accEffectiveLen < MIN_SOLVE_LEN_EFFECTIVE) return false;
    var structure = hasProblemStructure(accText);
    var passage = hasPassageHint(accText);
    if (structure && (passage || accEffectiveLen >= TEXT_THRESHOLD_EFFECTIVE)) {
      return true;
    }
    return false;
  }

  function buildInsufficientReason() {
    if (blocked) {
      return "카메라가 가려졌습니다. 렌즈를 가리지 않게 해주세요.";
    }
    if (tooFar) {
      return "지문이 너무 멀어 보입니다. 종이를 화면에 더 크게 채워주세요.";
    }
    if (tooNear) {
      return "지문이 너무 가까워 보입니다. 5에서 10센티미터 정도만 멀리 두고 다시 비춰주세요.";
    }
    if (!hasProblemStructure(accText)) {
      return "문제 1과 문제 2가 아직 충분히 인식되지 않았습니다. 문제 부분을 화면에 크게 비춰주세요.";
    }
    return "아직 제시문이나 일부 문장이 부족합니다. 페이지를 조금 더 오래, 흔들림 없이 비춰주세요.";
  }

  function buildStatusLines(extraLine) {
    var lines = [];
    lines.push("자동 OCR(누적) → 자동 풀이");
    lines.push("카메라 상태: " + (blocked ? "가려짐" : "정상"));

    var dist = "정상(추정)";
    if (tooFar) dist = "너무 멂(추정)";
    else if (tooNear) dist = "너무 가까움(추정)";
    lines.push("거리 상태: " + dist);

    lines.push("자동 크롭(디지털 줌): " + cropFactor.toFixed(2) + " (1.00=넓게, 0.70=확대)");
    lines.push("누적 세그먼트 수: " + segments.length);
    lines.push("누적 길이(공백제외): " + accEffectiveLen);
    lines.push("OCR 참고 신뢰도(최대): " + accBestConf.toFixed(1) + "%");

    var ready = isReadyToSolve();
    lines.push("완성 판정(문제1·2/제시문): " + (ready ? "OK" : "아직 부족"));

    if (notReadySince && !ready) {
      var sec = Math.floor((now() - notReadySince) / 1000);
      lines.push("부족 지속: " + sec + "초 (5분 안내 / 8분 자동풀이)");
    } else {
      lines.push("부족 지속: 0초");
    }

    if (extraLine) {
      lines.push(String(extraLine));
    }
    return lines;
  }

  // =========================
  // 9) OCR 1회
  // =========================
  function shouldTryOcr() {
    if (solved || solving) return false;
    if (ocrRunning) return false;
    if (blocked) return false;

    var tNow = now();
    if (tNow - lastOcrAt < OCR_INTERVAL_MS) return false;

    var a = analyzeFrame();
    if (!a.stable) return false;

    return true;
  }

  function doOcrOnce() {
    if (!shouldTryOcr()) return;
    ocrRunning = true;
    lastOcrAt = now();

    var canvas = captureToCanvas();
    setStatus(buildStatusLines("OCR 진행 중..."));

    Tesseract.recognize(canvas, OCR_LANG, {
      logger: function (m) {
        if (m && m.status === "recognizing text") {
          var p = Math.round((m.progress || 0) * 100);
          setStatus(buildStatusLines("OCR 진행 중... " + p + "%"));
        }
      }
    }).then(function (result) {
      var rawText = (result && result.data && result.data.text) ? result.data.text : "";
      var conf = (result && result.data && typeof result.data.confidence === "number")
        ? result.data.confidence
        : 0;

      var cleaned = normalizeOcrText(rawText);
      var effLen = effectiveLenOf(cleaned);

      tooFar = (effLen < 400 && conf < 35);
      tooNear = (effLen >= 800 && conf < 35);
      adjustCropByDistance();

      var mergeInfo = updateAccumulation(cleaned, conf);

      var ready = isReadyToSolve();
      var tNow = now();
      if (!ready) {
        if (!notReadySince) notReadySince = tNow;
      } else {
        notReadySince = null;
      }

      setStatus(buildStatusLines("OCR 완료 · 누적: " + mergeInfo.action));

      if (!solved && !solving) {
        if (ready) {
          autoSolve("문제/제시문 구조 인식 완료");
          return;
        }
        if (notReadySince) {
          var dur = tNow - notReadySince;
          if (dur >= INSUFFICIENT_WARN_MS && dur < MAX_WAIT_MS) {
            speak(buildInsufficientReason(), false);
          }
          if (dur >= MAX_WAIT_MS) {
            autoSolve("8분 경과. 현재 인식된 내용으로 풀이");
            return;
          }
        }
      }
    }).catch(function (e) {
      console.error(e);
      setStatus(buildStatusLines("OCR 에러: " + String(e)));
    }).finally(function () {
      ocrRunning = false;
    });
  }

  // =========================
  // 10) solve 호출
  // =========================
  function autoSolve(reason) {
    if (solved || solving) return;
    solving = true;

    var payloadText = (accText || "").trim();
    if (payloadText.length > 8000) {
      payloadText = payloadText.slice(0, 8000);
    }

    setStatus(buildStatusLines("풀이 요청 중... (" + reason + ")"));
    answerBoxEl.textContent = "풀이 생성 중...";

    fetch(SOLVE_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ ocrText: payloadText })
    })
      .then(function (res) {
        var ct = (res.headers.get("content-type") || "").toLowerCase();
        if (ct.indexOf("application/json") !== -1) {
          return res.json().then(function (data) {
            return { ok: res.ok, status: res.status, data: data, text: null };
          });
        }
        return res.text().then(function (text) {
          return { ok: res.ok, status: res.status, data: null, text: text };
        });
      })
      .then(function (resObj) {
        if (!resObj.ok) {
          var msg = resObj.text || JSON.stringify(resObj.data || {});
          answerBoxEl.textContent = "서버 에러 (status " + resObj.status + ")\n\n" + msg.slice(0, 4000);
          speak("서버 에러가 발생했습니다.", true);
          solving = false;
          return;
        }

        var out = "";
        if (resObj.data && typeof resObj.data.answer === "string") {
          out = resObj.data.answer;
        } else if (resObj.data && typeof resObj.data.body === "string") {
          out = resObj.data.body;
        } else if (typeof resObj.text === "string") {
          out = resObj.text;
        } else {
          out = JSON.stringify(resObj.data || {});
        }

        solved = true;
        answerBoxEl.textContent = out;
        setStatus(buildStatusLines("풀이 완료"));
        speak("답안이 생성되었습니다.", true);
        speakLong(out);
      })
      .catch(function (e) {
        console.error(e);
        answerBoxEl.textContent = "요청 실패: " + String(e);
        speak("요청에 실패했습니다.", true);
      })
      .finally(function () {
        solving = false;
      });
  }

  // =========================
  // 11) OCR 루프 & 카메라 시작
  // =========================
  function scheduleOcrLoop() {
    doOcrOnce();
    setInterval(function () {
      doOcrOnce();
    }, OCR_INTERVAL_MS);
  }

  function startCamera() {
    setStatus(["카메라 요청 중...", "iOS 권한 팝업이 뜨면 '허용'을 눌러야 함."]);

    navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 },
        frameRate: { ideal: 30 }
      },
      audio: false
    }).then(function (s) {
      stream = s;
      video.srcObject = stream;

      if (video.readyState >= 2) {
        afterMetadata();
      } else {
        video.onloadedmetadata = afterMetadata;
      }
    }).catch(function (e) {
      console.error(e);
      setStatus(["카메라 접근 실패", String(e)]);
      speak("카메라 접근에 실패했습니다.", true);
    });
  }

  function afterMetadata() {
    setStatus([
      "카메라 ON",
      "자동 OCR 시작됨 (3초마다, 화면이 안정될 때만)",
      "음성(TTS)이 안 나오면: 화면 탭 + 무음모드 해제 + 볼륨 올리기"
    ]);
    requestAnimationFrame(analyzeLoop);
    scheduleOcrLoop();
  }

  // =========================
  // 12) 초기화
  // =========================
  initVoices();
  document.addEventListener("click", unlockAudioOnce, { passive: true, once: true });
  document.addEventListener("touchstart", unlockAudioOnce, { passive: true, once: true });
  startCamera();
})();
</script>
</body>
</html>

