<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ë…¼ìˆ  ìë™ OCR(ëˆ„ì ) â†’ ìë™ í’€ì´</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- âœ… Tesseract.js (v5) -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 10px;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Apple SD Gothic Neo", sans-serif;
    }
    .wrap { max-width: 980px; margin: 0 auto; }

    #videoBox {
      position: relative;
      width: 100%;
      background: #000;
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(0,255,0,0.25);
    }
    #video {
      width: 100%;
      height: auto;
      transform-origin: center center;
      background: #000;
    }
    #frame {
      position: absolute; inset: 8px;
      border: 2px solid rgba(0,255,0,0.35);
      border-radius: 10px;
      pointer-events: none;
    }

    .btnRow {
      display: flex;
      gap: 10px;
      margin: 12px 0 10px;
      flex-wrap: wrap;
    }
    button {
      appearance: none;
      border: 1px solid #2b2b2b;
      background: #111;
      color: #fff;
      padding: 12px 14px;
      border-radius: 14px;
      font-size: 15px;
      cursor: pointer;
    }
    button:active { transform: scale(0.98); }
    .card {
      margin-top: 12px;
      border: 1px solid #2b2b2b;
      background: #0b0b0b;
      border-radius: 14px;
      padding: 14px;
      line-height: 1.35;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .title {
      font-weight: 700;
      font-size: 18px;
      margin: 0 0 8px;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 13px;
    }
    .small { font-size: 13px; color: #cfcfcf; }
    .dim { color: #bdbdbd; }

    #ocrBox, #answerBox {
      min-height: 160px;
      max-height: 280px;
      overflow: auto;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #222;
      background: #000;
    }

    .footerHint {
      margin-top: 10px;
      font-size: 12px;
      color: #9a9a9a;
    }
  </style>
</head>
<body>
<div class="wrap">

  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
    <div id="frame"></div>
  </div>

  <div class="btnRow">
    <button id="btnTtsUnlock">ğŸ”Š ìŒì„± ì—°ê²°(í•œ ë²ˆ íƒ­)</button>
    <button id="btnForceSolve">âš¡ ì§€ê¸ˆê¹Œì§€ë¡œ ê°•ì œ í’€ì´</button>
    <button id="btnReset">â†©ï¸ OCR ì¬ì‹œì‘(ìƒˆë¡œê³ ì¹¨)</button>
  </div>

  <div class="card mono" id="statusCard">
ìë™ OCR(ëˆ„ì ) â†’ ìë™ í’€ì´
í”„ë¦¬ë·° ë°°ìœ¨: 0.8 (í‘œì‹œìš©)
ì¹´ë©”ë¼ ìƒíƒœ: ì¤€ë¹„ ì¤‘
ê±°ë¦¬ ìƒíƒœ: ì•Œ ìˆ˜ ì—†ìŒ
ì„¸ê·¸ë¨¼íŠ¸(í˜ì´ì§€ ì¶”ì •) ìˆ˜: 0
ëˆ„ì  OCR ê¸¸ì´(ê³µë°±ì œì™¸): 0 / ê¸°ì¤€ 2400
í‰ê·  OCR ì‹ ë¢°ë„(ëŒ€ëµ): 0.0%
ì§€ë¬¸ ë¶€ì¡± ì§€ì†: 0ì´ˆ (8ë¶„ì´ë©´ "ì§€ë¬¸ ë¶€ì¡± ìë™í’€ì´")
OCR ì—”ì§„: ë¡œë”© ì¤‘...
ë§ˆì§€ë§‰ ë©”ì‹œì§€: ì‹œì‘ ì¤‘...
  </div>

  <div class="card">
    <div class="title">ì‹¤ì‹œê°„ OCR(ëˆ„ì )</div>
    <div id="ocrBox" class="mono"></div>
    <div class="footerHint">íŒ: ì¢…ì´ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ, í”ë“¤ë¦¼ ì—†ì´ 1ì´ˆ ê³ ì • â†’ ìë™ OCRì´ ëŒì•„ê°„ë‹¤.</div>
  </div>

  <div class="card">
    <div class="title">ë‹µì•ˆ</div>
    <div id="answerBox" class="mono"></div>
  </div>

</div>

<script>
/* =========================
   ì„¤ì •
========================= */
const SOLVE_URL = "/.netlify/functions/solve";  // ê°™ì€ Netlify ì‚¬ì´íŠ¸ë©´ ì´ê²Œ ì œì¼ ì•ˆì „
const OCR_LANG = "kor";                         // í•œêµ­ì–´ë§Œ
const OCR_INTERVAL_MS = 4500;                   // ìë™ OCR ì£¼ê¸°(ë„ˆë¬´ ì§§ìœ¼ë©´ í¬ë˜ì‹œ/ì˜¤ë¥˜â†‘)
const STABLE_REQUIRED_MS = 900;                 // í”ë“¤ë¦¼ ë©ˆì¶˜ í›„ OCR ì‹œì‘ê¹Œì§€
const TARGET_LEN = 2400;                        // ê³µë°±ì œì™¸ ëˆ„ì  ê¸¸ì´ ê¸°ì¤€(ì¶©ë¶„í•˜ë©´ ì¦‰ì‹œ ìë™í’€ì´)
const LOW_TEXT_WAIT_MS = 8 * 60 * 1000;         // ì§€ë¬¸ ë¶€ì¡± 8ë¶„ì´ë©´ ìë™í’€ì´
const MAX_SEND_CHARS = 3500;                    // solveë¡œ ë³´ë‚´ëŠ” ìµœëŒ€ ê¸€ì(íƒ€ì„ì•„ì›ƒ ë°©ì§€)
const MAX_CANVAS_W = 1280;                      // OCR ìº¡ì²˜ ìµœëŒ€ í­(í¬ë˜ì‹œ ë°©ì§€)
const MAX_CANVAS_H = 960;

const PREVIEW_SCALE = 0.8;                      // í‘œì‹œìš© ë°°ìœ¨(0.8)
const ZOOM_REQUEST = 0.8;                       // ì¹´ë©”ë¼ zoom ì§€ì› ì‹œ 0.8 ì‹œë„ (ë¯¸ì§€ì›ì´ë©´ ë¬´ì‹œ)

/* =========================
   DOM
========================= */
const video = document.getElementById("video");
const statusCard = document.getElementById("statusCard");
const ocrBox = document.getElementById("ocrBox");
const answerBox = document.getElementById("answerBox");

const btnReset = document.getElementById("btnReset");
const btnForceSolve = document.getElementById("btnForceSolve");
const btnTtsUnlock = document.getElementById("btnTtsUnlock");

/* =========================
   ìƒíƒœ
========================= */
let stream = null;
let lastFrameThumb = null;
let lastStableAt = 0;
let lastOcrAt = 0;
let ocrBusy = false;

let engineReady = false;
let engineError = "";

let accumulatedText = "";
let totalSegments = 0;

let confSum = 0;
let confCount = 0;

let lastLenImprovedAt = Date.now();   // ëˆ„ì  ê¸¸ì´ê°€ ì˜ë¯¸ìˆê²Œ ëŠ˜ì–´ë‚œ ì‹œì 
let lastNoTextStartAt = Date.now();   // "ì§€ë¬¸ ë¶€ì¡±" ì‹œì‘ ì‹œì 

let solvedOnce = false;
let lastSolveHash = "";

let ttsUnlocked = false;

/* =========================
   ìœ í‹¸
========================= */
function nowMs() { return Date.now(); }

function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }

function noSpaceLen(s) {
  return String(s || "").replace(/\s/g, "").length;
}

function hashSimple(s) {
  // ë¹ ë¥¸ í•´ì‹œ(ì¶©ëŒ ê°€ëŠ¥í•˜ì§€ë§Œ ë°˜ë³µìš”ì²­ ë°©ì§€ìš©)
  s = String(s || "");
  let h = 2166136261;
  for (let i = 0; i < s.length; i++) {
    h ^= s.charCodeAt(i);
    h = (h * 16777619) >>> 0;
  }
  return String(h);
}

/* =========================
   í…ìŠ¤íŠ¸ ì •ë¦¬(ìˆ«ì/ì˜ë¬¸/ì¡ê¸°í˜¸ ì œê±°)
   - í•œêµ­ì–´ + ê³µë°± + ê¸°ë³¸ ë¬¸ì¥ë¶€í˜¸ë§Œ ë‚¨ê¹€
========================= */
function cleanKoreanOnly(raw) {
  raw = String(raw || "");

  // 1) í”í•œ OCR ì¡ê¸°í˜¸/ì œì–´ë¬¸ì ì œê±°
  raw = raw.replace(/\u0000/g, "");

  // 2) ìˆ«ì/ì˜ë¬¸ ì œê±°
  raw = raw.replace(/[0-9A-Za-z]/g, "");

  // 3) í•œêµ­ì–´/ê³µë°±/ê°œí–‰/ê¸°ë³¸ë¶€í˜¸ë§Œ ë‚¨ê¸°ê³  ì œê±°
  // í—ˆìš©: í•œê¸€, ê³µë°±, ê°œí–‰, . , ? ! : ; ( ) [ ] " ' Â· - â€” â€¦
  raw = raw.replace(/[^ê°€-í£\s\n\.\,\?\!\:\;\(\)\[\]\"\'Â·\-\â€”\â€¦]/g, "");

  // 4) ê³µë°± ì •ë¦¬
  raw = raw.replace(/[ \t]+/g, " ");
  raw = raw.replace(/\n{3,}/g, "\n\n");
  raw = raw.replace(/ +\n/g, "\n");
  raw = raw.trim();

  return raw;
}

/* =========================
   ëˆ„ì  + "ë¹„ìŠ·í•œ ë¬¸ì¥" ë®ì–´ì“°ê¸°(ê°„ë‹¨ ë²„ì „)
   - ì¤„ ë‹¨ìœ„ë¡œ ì •ê·œí™” keyë¥¼ ë§Œë“¤ê³ 
   - ë” ê¸´ ì¤„/ì‹ ë¢°ë„ ë†’ì€ ì¤„ì´ ì˜¤ë©´ êµì²´
========================= */
function normalizeLineKey(line) {
  return String(line || "")
    .replace(/\s+/g, "")
    .replace(/[Â·\-\â€”\.\,\?\!\:\;\"\'\(\)\[\]]/g, "")
    .trim();
}

function mergeAccumulated(acc, incoming, incomingConf) {
  const accLines = acc.split("\n").map(s => s.trim()).filter(Boolean);
  const inLines  = incoming.split("\n").map(s => s.trim()).filter(Boolean);

  const best = new Map(); // key -> { text, score }
  const put = (line, baseScore) => {
    const k = normalizeLineKey(line);
    if (!k) return;
    const score = baseScore + Math.min(40, line.length); // ê¸¸ì´ ê°€ì¤‘ì¹˜
    const prev = best.get(k);
    if (!prev || score > prev.score) best.set(k, { text: line, score });
  };

  // ê¸°ì¡´ ëˆ„ì ì„ ê¸°ë³¸ìœ¼ë¡œ
  for (const line of accLines) put(line, 50);

  // ìƒˆ ì¸ì‹ì€ ì‹ ë¢°ë„ ê°€ì¤‘ì¹˜
  const confBoost = clamp((incomingConf || 0), 0, 90) / 2; // 0~45
  for (const line of inLines) put(line, 60 + confBoost);

  // ì›ë˜ ìˆœì„œë¥¼ ìµœëŒ€í•œ ìœ ì§€í•˜ë ¤ê³  accLines ìˆœì„œëŒ€ë¡œ ì¶œë ¥ + ìƒˆë¡œ ìƒê¸´ ì¤„ ë’¤ì— ì¶”ê°€
  const used = new Set();
  const out = [];

  for (const line of accLines) {
    const k = normalizeLineKey(line);
    const v = best.get(k);
    if (v && !used.has(k)) {
      out.push(v.text);
      used.add(k);
    }
  }
  for (const line of inLines) {
    const k = normalizeLineKey(line);
    const v = best.get(k);
    if (v && !used.has(k)) {
      out.push(v.text);
      used.add(k);
    }
  }

  return out.join("\n");
}

/* =========================
   í”„ë ˆì„ ë¶„ì„: ë°ê¸°/í”ë“¤ë¦¼
========================= */
const THUMB_W = 64, THUMB_H = 36;
const thumbCanvas = document.createElement("canvas");
thumbCanvas.width = THUMB_W;
thumbCanvas.height = THUMB_H;
const thumbCtx = thumbCanvas.getContext("2d", { willReadFrequently: true });

function analyzeFrame() {
  if (!video.videoWidth || !video.videoHeight) {
    return { blocked: false, stable: false, brightness: 0, motion: 0 };
  }
  thumbCtx.drawImage(video, 0, 0, THUMB_W, THUMB_H);
  const img = thumbCtx.getImageData(0, 0, THUMB_W, THUMB_H);
  const data = img.data;

  const len = THUMB_W * THUMB_H;
  let sum = 0;
  let diff = 0;

  const curr = new Uint8Array(len);
  for (let i = 0, p = 0; i < data.length; i += 4, p++) {
    const r = data[i], g = data[i+1], b = data[i+2];
    const gray = (r + g + b) / 3;
    curr[p] = gray;
    sum += gray;
    if (lastFrameThumb) diff += Math.abs(gray - lastFrameThumb[p]);
  }

  const brightness = sum / len;
  const motion = lastFrameThumb ? (diff / len) : 0;

  lastFrameThumb = curr;

  const blocked = brightness < 18;     // ë„ˆë¬´ ì–´ë‘ìš°ë©´ ê°€ë ¤ì§/ë Œì¦ˆê°€ë¦¼ ê°€ëŠ¥ì„±
  const stable = motion < 7;          // ê°’ ë‚®ì„ìˆ˜ë¡ ì•ˆì •

  return { blocked, stable, brightness, motion };
}

/* =========================
   ìº¡ì²˜ + ì „ì²˜ë¦¬ (í¬ë˜ì‹œ ë°©ì§€ + ì •í™•ë„â†‘)
   - ì¤‘ì•™ ìœ„ì£¼, ë‹¤ìš´ìŠ¤ì¼€ì¼, í‘ë°±/ì´ì§„í™”(ê°„ë‹¨ Otsu)
========================= */
function createCaptureCanvas() {
  const c = document.createElement("canvas");
  const ctx = c.getContext("2d", { willReadFrequently: true });
  return { c, ctx };
}

function drawCenterCropToCanvas(canvas, ctx) {
  const vw = video.videoWidth;
  const vh = video.videoHeight;

  // ì¤‘ì•™ 92% crop
  const cropScale = 0.92;
  const cw = Math.floor(vw * cropScale);
  const ch = Math.floor(vh * cropScale);
  const cx = Math.floor((vw - cw) / 2);
  const cy = Math.floor((vh - ch) / 2);

  // ë‹¤ìš´ìŠ¤ì¼€ì¼ ì œí•œ
  let outW = cw;
  let outH = ch;
  const s = Math.min(1, MAX_CANVAS_W / outW, MAX_CANVAS_H / outH);
  outW = Math.max(320, Math.floor(outW * s));
  outH = Math.max(240, Math.floor(outH * s));

  canvas.width = outW;
  canvas.height = outH;

  ctx.drawImage(video, cx, cy, cw, ch, 0, 0, outW, outH);
}

function otsuThreshold(grayArr) {
  // grayArr: Uint8Array
  const hist = new Array(256).fill(0);
  for (let i = 0; i < grayArr.length; i++) hist[grayArr[i]]++;

  const total = grayArr.length;
  let sum = 0;
  for (let t = 0; t < 256; t++) sum += t * hist[t];

  let sumB = 0;
  let wB = 0;
  let wF = 0;

  let varMax = 0;
  let threshold = 160;

  for (let t = 0; t < 256; t++) {
    wB += hist[t];
    if (wB === 0) continue;

    wF = total - wB;
    if (wF === 0) break;

    sumB += t * hist[t];

    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;

    const varBetween = wB * wF * (mB - mF) * (mB - mF);
    if (varBetween > varMax) {
      varMax = varBetween;
      threshold = t;
    }
  }
  return threshold;
}

function preprocessToBinary(canvas, ctx) {
  const img = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const d = img.data;

  // grayscale
  const gray = new Uint8Array(canvas.width * canvas.height);
  for (let i = 0, p = 0; i < d.length; i += 4, p++) {
    const r = d[i], g = d[i+1], b = d[i+2];
    const y = (r * 0.299 + g * 0.587 + b * 0.114);
    gray[p] = y;
  }

  // Otsu threshold
  const th = otsuThreshold(gray);

  // binarize + ì•½ê°„ ëŒ€ë¹„ ê°•í™”
  for (let i = 0, p = 0; i < d.length; i += 4, p++) {
    const v = gray[p] < th ? 0 : 255;
    d[i] = d[i+1] = d[i+2] = v;
    d[i+3] = 255;
  }

  ctx.putImageData(img, 0, 0);
}

/* =========================
   OCR ì—”ì§„ ì¤€ë¹„(ì›Œë°ì—…)
========================= */
async function warmupOcr() {
  try {
    if (!window.Tesseract || !Tesseract.recognize) {
      engineReady = false;
      engineError = "Tesseract ë¡œë“œ ì‹¤íŒ¨(ë„¤íŠ¸ì›Œí¬)";
      return;
    }
    const { c, ctx } = createCaptureCanvas();
    c.width = 320; c.height = 240;
    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,320,240);
    ctx.fillStyle = "#000";
    ctx.font = "24px sans-serif";
    ctx.fillText("ì›Œë°ì—…", 90, 120);

    // ì›Œë°ì—… 1íšŒ(ë°ì´í„° ë‹¤ìš´ë¡œë“œ/wasm ì´ˆê¸°í™”)
    await Tesseract.recognize(c, OCR_LANG, {
      langPath: "https://tessdata.projectnaptha.com/4.0.0",
      logger: () => {}
    });

    engineReady = true;
    engineError = "";
  } catch (e) {
    engineReady = false;
    engineError = "OCR ì›Œë°ì—… ì‹¤íŒ¨(ë„¤íŠ¸ì›Œí¬/ë©”ëª¨ë¦¬): " + String(e && e.message ? e.message : e);
  }
}

/* =========================
   OCR 1íšŒ
========================= */
async function doOcrOnce() {
  if (!engineReady) return;
  if (ocrBusy) return;

  ocrBusy = true;
  const startedAt = nowMs();

  try {
    setStatusMsg("OCR ì§„í–‰ ì¤‘...");

    const { c, ctx } = createCaptureCanvas();
    drawCenterCropToCanvas(c, ctx);
    preprocessToBinary(c, ctx);

    const res = await Tesseract.recognize(c, OCR_LANG, {
      langPath: "https://tessdata.projectnaptha.com/4.0.0",
      logger: (m) => {
        if (m && m.status === "recognizing text") {
          const p = Math.round((m.progress || 0) * 100);
          setStatusMsg("OCR ì§„í–‰ ì¤‘... " + p + "%");
        }
      }
    });

    const conf = Number(res?.data?.confidence || 0);
    let text = String(res?.data?.text || "");
    text = cleanKoreanOnly(text);

    // ë„ˆë¬´ ì§§ìœ¼ë©´ ë¬´ì‹œ
    const eff = noSpaceLen(text);
    if (!text || eff < 25) {
      setStatusMsg(`OCR ì™„ë£Œ(ë¬´ì‹œ: í…ìŠ¤íŠ¸ ì§§ìŒ, ê¸¸ì´=${eff}, conf=${conf.toFixed(1)}%)`);
      markNoText();
      return;
    }

    // ëˆ„ì  ì—…ë°ì´íŠ¸
    const beforeLen = noSpaceLen(accumulatedText);
    const merged = mergeAccumulated(accumulatedText, text, conf);
    accumulatedText = merged;

    const afterLen = noSpaceLen(accumulatedText);

    // ì‹ ë¢°ë„ í‰ê· (ëŒ€ëµ)
    if (conf > 0) {
      confSum += conf;
      confCount += 1;
    }

    // í˜ì´ì§€(ì„¸ê·¸ë¨¼íŠ¸) ì¶”ì •: ê¸¸ì´ í° í­ ì¦ê°€í•˜ë©´ +1
    if (afterLen - beforeLen >= 260) totalSegments += 1;

    // "ì§€ë¬¸ ë¶€ì¡±" íƒ€ì´ë¨¸ ë¦¬ì…‹ ê¸°ì¤€(ì˜ë¯¸ìˆê²Œ ëŠ˜ì—ˆì„ ë•Œ)
    if (afterLen - beforeLen >= 120) {
      lastLenImprovedAt = nowMs();
      lastNoTextStartAt = nowMs();
    } else {
      // ê±°ì˜ ëŠ˜ì§€ ì•Šìœ¼ë©´ ì§€ë¬¸ë¶€ì¡± ìœ ì§€
      markNoText();
    }

    ocrBox.textContent = accumulatedText;

    setStatusMsg(`OCR ì™„ë£Œ(ëˆ„ì  ê°±ì‹ ) ê¸¸ì´=${afterLen}, conf=${conf.toFixed(1)}%`);

    // âœ… ì¶©ë¶„í•˜ë©´ ìë™ í’€ì´
    if (!solvedOnce && afterLen >= TARGET_LEN) {
      await callSolve("ì¶©ë¶„í•œ ì§€ë¬¸ ì¸ì‹ìœ¼ë¡œ ìë™ í’€ì´í•©ë‹ˆë‹¤.");
    }

  } catch (e) {
    const msg = String(e && e.message ? e.message : e);
    // RuntimeError Aborted(-1) ê°™ì€ ê²½ìš°: ë„ˆë¬´ ìì£¼/í° ì´ë¯¸ì§€/ë©”ëª¨ë¦¬ â†’ ì£¼ê¸° ëŠ˜ë¦¬ê³  í¬ê¸° ì¤„ì—¬ì•¼ í•¨(ì´ë¯¸ ì¤„ì—¬ë‘ )
    setStatusMsg("OCR ì—ëŸ¬: " + msg);
    // ì—ëŸ¬ê°€ ë‚˜ë©´ ì ê¹ ì‰¬ì—ˆë‹¤ê°€ ì¬ì‹œë„
    lastOcrAt = nowMs();
  } finally {
    ocrBusy = false;
    // ë„ˆë¬´ ì—°ì†ìœ¼ë¡œ ëŒì§€ ì•Šê²Œ
    lastOcrAt = startedAt;
  }
}

/* =========================
   ì§€ë¬¸ë¶€ì¡± íƒ€ì´ë¨¸
========================= */
function markNoText() {
  // ì§€ë¬¸ì´ "ì¶©ë¶„íˆ ëŠ˜ì§€ ì•ŠëŠ” ìƒíƒœ"ê°€ ê³„ì†ë˜ë©´ lastNoTextStartAt ìœ ì§€
  // (ëŠ˜ì—ˆìœ¼ë©´ ìœ„ì—ì„œ lastNoTextStartAt ê°±ì‹ í–ˆìŒ)
}

function noTextDurationMs() {
  return nowMs() - lastNoTextStartAt;
}

/* =========================
   Solve í˜¸ì¶œ (í…ìŠ¤íŠ¸/HTML ë°©ì–´)
========================= */
async function callSolve(prefixLine) {
  if (solvedOnce) return;

  const base = accumulatedText.trim();
  if (!base) {
    answerBox.textContent = "ì•„ì§ OCR í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.";
    return;
  }

  const send = base.length > MAX_SEND_CHARS ? base.slice(0, MAX_SEND_CHARS) : base;
  const h = hashSimple(send);
  if (h === lastSolveHash) return;
  lastSolveHash = h;

  solvedOnce = true;
  answerBox.textContent = "ë‹µì•ˆ ìƒì„± ì¤‘...";

  try {
    const res = await fetch(SOLVE_URL, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ ocrText: send })
    });

    const ct = (res.headers.get("content-type") || "").toLowerCase();

    let outText = "";
    if (ct.includes("application/json")) {
      try {
        const data = await res.json();
        outText = (data && (data.answer || data.text || data.result)) ? String(data.answer || data.text || data.result) : JSON.stringify(data);
      } catch (e) {
        outText = "JSON íŒŒì‹± ì—ëŸ¬: " + String(e && e.message ? e.message : e);
      }
    } else {
      outText = await res.text();
    }

    if (prefixLine) outText = prefixLine + "\n\n" + outText;

    answerBox.textContent = outText;

    // âœ… ë‹µì•ˆ ìŒì„± ì¶œë ¥
    speakLong(outText);

  } catch (e) {
    solvedOnce = false; // ì‹¤íŒ¨ë©´ ë‹¤ì‹œ ì‹œë„ ê°€ëŠ¥í•˜ê²Œ
    answerBox.textContent = "ìš”ì²­ ì‹¤íŒ¨: " + String(e && e.message ? e.message : e);
  }
}

/* =========================
   ìë™ ë£¨í”„(ì•ˆì •ë  ë•Œë§Œ OCR)
========================= */
function loop() {
  const a = analyzeFrame();

  const camState = a.blocked ? "ê°€ë ¤ì§/ì–´ë‘ì›€" : "ì •ìƒ";
  const distState = inferDistance(a.brightness);
  const stable = a.stable;

  if (stable) {
    if (!lastStableAt) lastStableAt = nowMs();
  } else {
    lastStableAt = 0;
  }

  // ìë™ OCR ì¡°ê±´
  const stableEnough = lastStableAt && (nowMs() - lastStableAt >= STABLE_REQUIRED_MS);
  const intervalPassed = (nowMs() - lastOcrAt >= OCR_INTERVAL_MS);

  // ì§€ë¬¸ ë¶€ì¡± ì§€ì† ì‹œê°„ ê³„ì‚°
  const noTextSec = Math.floor(noTextDurationMs() / 1000);

  // ì§€ë¬¸ ë¶€ì¡± 8ë¶„ì´ë©´ ìë™ í’€ì´(ë‹¨, í…ìŠ¤íŠ¸ê°€ ì¡°ê¸ˆì´ë¼ë„ ìˆì–´ì•¼)
  if (!solvedOnce && noTextDurationMs() >= LOW_TEXT_WAIT_MS && noSpaceLen(accumulatedText) > 120) {
    callSolve("ì§€ë¬¸ì´ ë¶€ì¡±í•œ ìƒíƒœê°€ ì˜¤ë˜ ì§€ì†ë˜ì–´, ì§€ê¸ˆê¹Œì§€ ì¸ì‹ëœ ë‚´ìš©ìœ¼ë¡œ ìë™ í’€ì´í•©ë‹ˆë‹¤.");
  }

  // ìë™ OCR ì‹¤í–‰
  if (engineReady && !a.blocked && stableEnough && intervalPassed && !ocrBusy && !solvedOnce) {
    doOcrOnce();
  }

  renderStatus(camState, distState, stable, a.brightness, noTextSec);

  requestAnimationFrame(loop);
}

function inferDistance(brightness) {
  // ì •í™•íˆ ì•Œ ìˆ˜ ì—†ìŒ. ëŒ€ì‹  "ì¶”ì •" ì•ˆë‚´ë§Œ.
  // ë°ê¸°/í”ë“¤ë¦¼ë§Œìœ¼ë¡œ ê±°ë¦¬ë¥¼ íŒì •í•˜ëŠ” ê±´ ë¶ˆê°€ëŠ¥ì— ê°€ê¹Œì›€.
  // ë”°ë¼ì„œ ê°•í•œ í™•ì • í‘œí˜„ ê¸ˆì§€.
  if (brightness < 30) return "ì•Œ ìˆ˜ ì—†ìŒ(ì–´ë‘ì›€)";
  return "ì •ìƒ(ì¶”ì •)";
}

/* =========================
   ìƒíƒœ ì¶œë ¥
========================= */
let lastMsg = "ì‹œì‘ ì¤‘...";

function setStatusMsg(msg) {
  lastMsg = msg;
}

function renderStatus(camState, distState, stable, brightness, noTextSec) {
  const accLen = noSpaceLen(accumulatedText);
  const avgConf = confCount ? (confSum / confCount) : 0;

  const engineLine = engineReady ? "ì¤€ë¹„ë¨" : ("ë¡œë”©/ë¶ˆì•ˆì •");
  const engineErrLine = engineReady ? "" : ("ì—”ì§„ ì—ëŸ¬: " + (engineError || "ì•Œ ìˆ˜ ì—†ìŒ"));

  const moveLine = stable ? "ì •ì§€" : "ì›€ì§ì„(í”ë“¤ë¦¼)";
  const msgLine = stable ? lastMsg : "ì¹´ë©”ë¼ ì›€ì§ì„(í”ë“¤ë¦¼) ê°ì§€ â†’ 1ì´ˆë§Œ ê³ ì •";

  statusCard.textContent =
`ìë™ OCR(ëˆ„ì ) â†’ ìë™ í’€ì´
í”„ë¦¬ë·° ë°°ìœ¨: ${PREVIEW_SCALE} (í‘œì‹œìš©)
ì¹´ë©”ë¼ ìƒíƒœ: ${camState} (${moveLine}) | ë°ê¸°: ${brightness.toFixed(1)}
ê±°ë¦¬ ìƒíƒœ: ${distState}
ì„¸ê·¸ë¨¼íŠ¸(í˜ì´ì§€ ì¶”ì •) ìˆ˜: ${totalSegments}
ëˆ„ì  OCR ê¸¸ì´(ê³µë°±ì œì™¸): ${accLen} / ê¸°ì¤€ ${TARGET_LEN}
í‰ê·  OCR ì‹ ë¢°ë„(ëŒ€ëµ): ${avgConf.toFixed(1)}%
ì§€ë¬¸ ë¶€ì¡± ì§€ì†: ${noTextSec}ì´ˆ (8ë¶„ì´ë©´ "ì§€ë¬¸ ë¶€ì¡± ìë™í’€ì´")
OCR ì—”ì§„: ${engineLine}
ë§ˆì§€ë§‰ ë©”ì‹œì§€: ${msgLine}
${engineErrLine}`.trim();
}

/* =========================
   TTS (iOSëŠ” ë²„íŠ¼ íƒ­ìœ¼ë¡œ "ì—°ê²°" í•„ìš”)
========================= */
function ttsAvailable() {
  return ("speechSynthesis" in window) && ("SpeechSynthesisUtterance" in window);
}

function unlockTtsOnce() {
  if (!ttsAvailable()) {
    alert("ì´ ë¸Œë¼ìš°ì €ì—ì„œ TTSë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.");
    return;
  }
  // iOSëŠ” ì‚¬ìš©ì ì œìŠ¤ì²˜ë¡œ í•œë²ˆ ì‹¤í–‰í•´ì¤˜ì•¼ ì•ˆì •ì 
  const u = new SpeechSynthesisUtterance("ìŒì„± ì—°ê²° ì™„ë£Œ");
  u.lang = "ko-KR";
  u.rate = 1.0;
  u.pitch = 1.0;
  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(u);
  ttsUnlocked = true;
}

function speakLong(text) {
  if (!ttsAvailable()) return;
  if (!ttsUnlocked) return; // ë²„íŠ¼ íƒ­ ì „ì—ëŠ” ìë™ë°œí™” ê¸ˆì§€(ì•ˆ ë“¤ë¦´ ìˆ˜ ìˆìŒ)

  text = String(text || "").trim();
  if (!text) return;

  // ë„ˆë¬´ ê¸´ ê±´ ì•ë¶€ë¶„ë§Œ(í˜„ì‹¤ì ìœ¼ë¡œ)
  const MAX_SPEAK = 2200;
  if (text.length > MAX_SPEAK) text = text.slice(0, MAX_SPEAK);

  window.speechSynthesis.cancel();

  const chunks = splitForTts(text, 180);
  let idx = 0;

  const speakNext = () => {
    if (idx >= chunks.length) return;
    const u = new SpeechSynthesisUtterance(chunks[idx]);
    u.lang = "ko-KR";
    u.rate = 1.0;
    u.pitch = 1.0;
    u.onend = () => { idx += 1; speakNext(); };
    u.onerror = () => { idx += 1; speakNext(); };
    window.speechSynthesis.speak(u);
  };

  speakNext();
}

function splitForTts(text, maxLen) {
  const out = [];
  let buf = "";
  const parts = text.split(/\n+/);

  for (const p of parts) {
    const s = p.trim();
    if (!s) continue;

    if ((buf + " " + s).trim().length <= maxLen) {
      buf = (buf ? (buf + " " + s) : s);
    } else {
      if (buf) out.push(buf);
      if (s.length <= maxLen) {
        buf = s;
      } else {
        // ë„ˆë¬´ ê¸´ ì¤„ì€ ê°•ì œ ë¶„í• 
        let i = 0;
        while (i < s.length) {
          out.push(s.slice(i, i + maxLen));
          i += maxLen;
        }
        buf = "";
      }
    }
  }
  if (buf) out.push(buf);
  return out;
}

/* =========================
   ë²„íŠ¼
========================= */
btnReset.addEventListener("click", () => location.reload());

btnForceSolve.addEventListener("click", () => {
  callSolve("ê°•ì œ í’€ì´: ì§€ë¬¸ì´ ë¶€ì¡±í•  ìˆ˜ ìˆìœ¼ë‚˜, ì§€ê¸ˆê¹Œì§€ ì¸ì‹ëœ ë‚´ìš©ìœ¼ë¡œ ë‹µì•ˆì„ ìƒì„±í•©ë‹ˆë‹¤.");
});

btnTtsUnlock.addEventListener("click", () => {
  unlockTtsOnce();
});

/* =========================
   ì¹´ë©”ë¼ ì‹œì‘
========================= */
async function startCamera() {
  try {
    video.style.transform = `scale(${PREVIEW_SCALE})`;

    const constraints = {
      audio: false,
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 },
        frameRate: { ideal: 30 }
      }
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;

    // zoom ì§€ì› ì‹œ ì‹œë„
    const track = stream.getVideoTracks()[0];
    if (track) {
      try {
        const caps = track.getCapabilities ? track.getCapabilities() : null;
        if (caps && caps.zoom) {
          const z = clamp(ZOOM_REQUEST, caps.zoom.min, caps.zoom.max);
          await track.applyConstraints({ advanced: [{ zoom: z }] });
        }
      } catch (e) {
        // iOSëŠ” ëŒ€ë¶€ë¶„ ë¯¸ì§€ì› â†’ ë¬´ì‹œ
      }
    }

  } catch (e) {
    setStatusMsg("ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: " + String(e && e.message ? e.message : e));
  }
}

/* =========================
   ì‹œì‘
========================= */
(async function init() {
  setStatusMsg("ì¹´ë©”ë¼ ì‹œì‘ ì¤‘...");
  await startCamera();

  setStatusMsg("OCR ì—”ì§„ ë¡œë”© ì¤‘...");
  await warmupOcr();

  if (!engineReady) {
    setStatusMsg("OCR ì—”ì§„ ë¡œë”© ì‹¤íŒ¨: " + (engineError || "ì•Œ ìˆ˜ ì—†ìŒ"));
  } else {
    setStatusMsg("OCR ì—”ì§„ ì¤€ë¹„ë¨(í”ë“¤ë¦¼ ë©ˆì¶”ë©´ ìë™ OCR)");
  }

  requestAnimationFrame(loop);
})();
</script>

</body>
</html>
