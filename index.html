<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Auto OCR (누적) → Auto Solve + TTS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <!-- Tesseract v5 -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 10px;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    .wrap { max-width: 980px; margin: 0 auto; }
    #videoBox {
      position: relative;
      width: 100%;
      border: 1px solid #333;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
    }
    #video { width: 100%; height: auto; display: block; }
    #overlay {
      position: absolute;
      inset: 0;
      border: 2px solid rgba(0, 255, 0, 0.35);
      pointer-events: none;
    }
    #status {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #111;
      font-size: 13px;
      line-height: 1.45;
      white-space: pre-wrap;
    }
    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .panel {
      border: 1px solid #333;
      border-radius: 10px;
      background: #0b0b0b;
      padding: 10px;
    }
    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #cfcfcf;
      font-weight: 600;
    }
    textarea, pre {
      width: 100%;
      border: 1px solid #222;
      border-radius: 8px;
      background: #000;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 10px;
      margin: 0;
    }
    textarea { height: 240px; resize: vertical; }
    pre { min-height: 240px; white-space: pre-wrap; }
    .hint {
      margin-top: 6px;
      font-size: 12px;
      color: #aaa;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="videoBox">
      <video id="video" autoplay playsinline></video>
      <div id="overlay"></div>
    </div>

    <div id="status">초기화 중...</div>

    <div class="grid">
      <div class="panel">
        <h3>누적 OCR 미리보기</h3>
        <textarea id="ocrPreview" readonly></textarea>
        <div class="hint">
          iOS 음성(TTS) 팁: 화면을 한 번 탭 + 무음모드 해제 + 볼륨 올리기.
        </div>
      </div>

      <div class="panel">
        <h3>답안</h3>
        <pre id="answerBox"></pre>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // 0) 설정값
  // =========================
  const OCR_INTERVAL_MS = 3000;

  // 글자수 기반 최소치(구조 인식이 우선이지만, 완전 짧은 건 막음)
  const MIN_SOLVE_LEN_EFFECTIVE = 900;

  // "충분" 임시 기준 (구조가 다 잡히면 이거보다 조금 작아도 풀 수 있게 설계)
  const TEXT_THRESHOLD_EFFECTIVE = 2200;

  // 부족 안내: 연속 5분
  const INSUFFICIENT_WARN_MS = 5 * 60 * 1000;

  // 최대 대기: 연속 8분이면 부족해도 자동풀이
  const MAX_WAIT_MS = 8 * 60 * 1000;

  // solve 함수 (solve.js는 {ocrText} 받는 버전 기준)
  const SOLVE_URL = "/.netlify/functions/solve";

  // OCR 언어 (한국어 위주 + 영어 섞임 대비)
  const OCR_LANG = "kor+eng";

  // TTS
  const TTS_ENABLED = true;
  const TTS_RATE = 1.03;
  const TTS_PITCH = 1.0;
  const TTS_STATUS_COOLDOWN_MS = 15000;

  // 자동 디지털 줌(크롭)
  // 1.00=넓게(줌아웃), 0.70~0.75=확대(줌인)
  let cropFactor = 0.90;
  let lastCropAdjustAt = 0;
  const CROP_MIN = 0.72;
  const CROP_MAX = 1.00;
  const CROP_ADJUST_COOLDOWN_MS = 6000;

  // 중복 판정(같은 페이지를 계속 OCR하는 걸 흡수)
  // similarity >= 0.75면 "거의 같은 내용"으로 보고 더 좋은 걸로 교체
  const DUP_SIMILARITY = 0.75;

  // =========================
  // 1) DOM
  // =========================
  const video = document.getElementById("video");
  const statusEl = document.getElementById("status");
  const ocrPreviewEl = document.getElementById("ocrPreview");
  const answerBoxEl = document.getElementById("answerBox");

  // =========================
  // 2) 상태
  // =========================
  let stream = null;
  let ocrRunning = false;
  let lastOcrAt = 0;

  // 누적 OCR
  let segments = []; // { text, effLen, conf }
  let accText = "";
  let accEffectiveLen = 0;
  let accBestConf = 0;

  // 카메라 상태
  let blocked = false;
  let tooNear = false;
  let tooFar = false;

  // "아직 완성 아님" 연속 시간
  let notReadySince = null;

  // solve 상태
  let solved = false;
  let solving = false;

  // TTS 상태
  let lastStatusSpokenAt = 0;
  let audioUnlocked = false;
  let voicesReady = false;

  // =========================
  // 3) iOS 음성 언락 + voice 로딩 대기
  // =========================
  function initVoices() {
    if (!("speechSynthesis" in window)) return;
    const tryLoad = () => {
      const v = window.speechSynthesis.getVoices();
      if (v && v.length) voicesReady = true;
    };
    tryLoad();
    window.speechSynthesis.onvoiceschanged = () => {
      const v = window.speechSynthesis.getVoices();
      if (v && v.length) voicesReady = true;
    };
  }
  initVoices();

  function unlockAudioOnce() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    if (!TTS_ENABLED) return;
    // 탭 직후 "짧은 음성"을 한 번 성공시키면 이후가 잘 됨
    speak("음성이 활성화되었습니다.", true);
  }
  document.addEventListener("click", unlockAudioOnce, { passive: true, once: true });
  document.addEventListener("touchstart", unlockAudioOnce, { passive: true, once: true });

  // =========================
  // 4) 유틸
  // =========================
  function now() { return Date.now(); }
  function effectiveLenOf(text) { return (text || "").replace(/\s/g, "").length; }

  function setStatus(lines) {
    statusEl.textContent = lines.join("\n");
  }

  function chooseKoreanVoice() {
    if (!("speechSynthesis" in window)) return null;
    const voices = window.speechSynthesis.getVoices() || [];
    // ko-KR 우선
    let v = voices.find(x => (x.lang || "").toLowerCase().startsWith("ko"));
    if (v) return v;
    // fallback: 첫 번째
    return voices.length ? voices[0] : null;
  }

  function speak(text, force = false) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const t = (text || "").trim();
    if (!t) return;

    const tNow = now();
    if (!force && tNow - lastStatusSpokenAt < TTS_STATUS_COOLDOWN_MS) return;

    // voices가 아직 안 로드된 경우: 그래도 시도는 하되, 약간 지연
    const doSpeak = () => {
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(t);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;

        const v = chooseKoreanVoice();
        if (v) u.voice = v;

        lastStatusSpokenAt = tNow;
        window.speechSynthesis.speak(u);
      } catch (e) {}
    };

    if (!voicesReady) {
      setTimeout(doSpeak, 250);
    } else {
      doSpeak();
    }
  }

  function speakLong(text) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const t = (text || "").trim();
    if (!t) return;

    // iOS에서 길면 끊기는 경우가 있어 분할
    const chunkSize = 900;
    const chunks = [];
    for (let i = 0; i < t.length; i += chunkSize) chunks.push(t.slice(i, i + chunkSize));

    try {
      window.speechSynthesis.cancel();
      let idx = 0;
      const v = chooseKoreanVoice();

      const speakNext = () => {
        if (idx >= chunks.length) return;
        const u = new SpeechSynthesisUtterance(chunks[idx]);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        if (v) u.voice = v;
        u.onend = () => { idx += 1; speakNext(); };
        window.speechSynthesis.speak(u);
      };

      // voices 아직 로드 중이면 약간 대기
      setTimeout(speakNext, voicesReady ? 0 : 300);
    } catch (e) {}
  }

  function normalizeOcrText(text) {
    // 너무 공격적인 "오타수정"은 위험해서,
    // 안전한 정리(줄바꿈/공백/하이픈 줄끊김/이상문자 정리)만 함.
    let t = String(text || "");

    // 하이픈 줄바꿈(영문) 제거: "exam-\nple" -> "example"
    t = t.replace(/-\s*\n\s*/g, "");

    // 줄바꿈 주변 공백 정리
    t = t.replace(/[ \t]+\n/g, "\n");
    t = t.replace(/\n[ \t]+/g, "\n");

    // 연속 공백 축소
    t = t.replace(/[ \t]{2,}/g, " ");

    // 이상한 제어문자 제거
    t = t.replace(/[\u0000-\u001F\u007F]/g, "");

    // 너무 많은 특수기호 줄이기(완전 삭제는 X)
    t = t.replace(/[■□▢●◆◇]{2,}/g, " ");

    return t.trim();
  }

  // =========================
  // 5) 카메라 시작
  // =========================
  async function startCamera() {
    try {
      setStatus([
        "카메라 요청 중...",
        "iOS 권한 팝업이 뜨면 '허용'을 눌러야 함."
      ]);

      const constraints = {
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          frameRate: { ideal: 30 }
        },
        audio: false
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      await new Promise((resolve) => {
        if (video.readyState >= 2) return resolve();
        video.onloadedmetadata = () => resolve();
      });

      setStatus([
        "카메라 ON",
        "자동 OCR 시작됨 (3초마다, 화면이 안정될 때만)",
        "음성(TTS)이 안 나오면: 화면 탭 + 무음모드 해제 + 볼륨 올리기"
      ]);

      requestAnimationFrame(analyzeLoop);
      scheduleOcrLoop();
    } catch (e) {
      console.error(e);
      setStatus(["카메라 접근 실패", String(e)]);
      speak("카메라 접근에 실패했습니다.", true);
    }
  }

  // =========================
  // 6) 밝기/움직임/가려짐
  // =========================
  const BW = 64, BH = 36;
  const bCanvas = document.createElement("canvas");
  bCanvas.width = BW; bCanvas.height = BH;
  const bCtx = bCanvas.getContext("2d", { willReadFrequently: true });
  let prevThumb = null;
  let lastStableStart = 0;

  function analyzeFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      return { blocked: false, stable: false, avgBright: 255, diffAvg: 0 };
    }

    bCtx.drawImage(video, 0, 0, BW, BH);
    const img = bCtx.getImageData(0, 0, BW, BH).data;

    const len = BW * BH;
    const currThumb = new Uint8Array(len);

    let sumBright = 0;
    let diffSum = 0;

    for (let i = 0, p = 0; i < img.length; i += 4, p++) {
      const r = img[i], g = img[i + 1], b = img[i + 2];
      const gray = (r + g + b) / 3;
      currThumb[p] = gray;
      sumBright += gray;
      if (prevThumb) diffSum += Math.abs(gray - prevThumb[p]);
    }

    const avgBright = sumBright / len;
    const diffAvg = prevThumb ? (diffSum / len) : 0;
    prevThumb = currThumb;

    const isBlocked = avgBright < 20;

    const tNow = now();
    let stable = false;
    if (diffAvg < 8) {
      if (!lastStableStart) lastStableStart = tNow;
      if (tNow - lastStableStart >= 900) stable = true;
    } else {
      lastStableStart = 0;
    }

    return { blocked: isBlocked, stable, avgBright, diffAvg };
  }

  function analyzeLoop() {
    const a = analyzeFrame();
    blocked = a.blocked;
    requestAnimationFrame(analyzeLoop);
  }

  // =========================
  // 7) 캡처(영상 → 캔버스) + 중앙 크롭
  // =========================
  const capCanvas = document.createElement("canvas");
  const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

  function captureToCanvas() {
    const vw = video.videoWidth;
    const vh = video.videoHeight;

    if (!vw || !vh) {
      capCanvas.width = 640;
      capCanvas.height = 360;
      capCtx.fillStyle = "black";
      capCtx.fillRect(0, 0, capCanvas.width, capCanvas.height);
      return capCanvas;
    }

    const scaleCrop = cropFactor; // 0.72~1.00
    const cropW = Math.floor(vw * scaleCrop);
    const cropH = Math.floor(vh * scaleCrop);
    const cropX = Math.floor((vw - cropW) / 2);
    const cropY = Math.floor((vh - cropH) / 2);

    const maxW = 1920; // 글자 픽셀 확보를 위해 1600→1920
    const scale = Math.min(1, maxW / cropW);
    const outW = Math.max(360, Math.floor(cropW * scale));
    const outH = Math.max(240, Math.floor(cropH * scale));

    capCanvas.width = outW;
    capCanvas.height = outH;

    capCtx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, outW, outH);
    return capCanvas;
  }

  // =========================
  // 8) 중복/유사도(단순) + 누적 merge
  // =========================
  function tokenize(text) {
    // 너무 길면 비용 커서 앞부분 위주로
    const t = (text || "").slice(0, 1500);
    // 공백 기준 토큰 (한글도 대부분 띄어쓰기 존재)
    const arr = t.split(/\s+/).filter(Boolean);
    // 너무 많으면 제한
    return arr.slice(0, 220);
  }

  function jaccardSimilarity(a, b) {
    const A = tokenize(a);
    const B = tokenize(b);
    if (!A.length || !B.length) return 0;

    const setA = new Set(A);
    const setB = new Set(B);

    let inter = 0;
    for (const x of setA) if (setB.has(x)) inter++;

    const union = setA.size + setB.size - inter;
    return union ? (inter / union) : 0;
  }

  function updateAccumulation(newText, newConf) {
    const cleaned = normalizeOcrText(newText);
    const effLen = effectiveLenOf(cleaned);
    if (effLen < 20) return { changed: false, action: "ignore_too_short" };

    // 너무 낮은 confidence는 버리되, 완전 0~5만 버림(한글은 conf가 들쑥날쑥)
    if (newConf < 5) return { changed: false, action: "ignore_low_conf" };

    // 첫 세그먼트
    if (segments.length === 0) {
      segments.push({ text: cleaned, effLen, conf: newConf });
      rebuildAccumulated();
      return { changed: true, action: "append_first" };
    }

    const last = segments[segments.length - 1];
    const sim = jaccardSimilarity(last.text, cleaned);

    if (sim >= DUP_SIMILARITY) {
      // 같은 페이지/비슷한 내용으로 보고 더 좋은 쪽으로 교체
      const better =
        (effLen > last.effLen + 60) ||
        (Math.abs(effLen - last.effLen) <= 60 && newConf > last.conf + 4);

      if (better) {
        segments[segments.length - 1] = { text: cleaned, effLen, conf: newConf };
        rebuildAccumulated();
        return { changed: true, action: `replace_last(sim=${sim.toFixed(2)})` };
      } else {
        return { changed: false, action: `dup_keep_last(sim=${sim.toFixed(2)})` };
      }
    }

    // 새 페이지/새 구간으로 append
    segments.push({ text: cleaned, effLen, conf: newConf });

    // 세그먼트가 너무 쌓이면 앞쪽 일부만 유지(너무 길어지면 solve 타임아웃 위험)
    // solve.js는 8000자로 잘라 쓰니, 여기서도 과도한 누적은 관리
    if (segments.length > 12) segments = segments.slice(segments.length - 12);

    rebuildAccumulated();
    return { changed: true, action: `append_new(sim=${sim.toFixed(2)})` };
  }

  function rebuildAccumulated() {
    // 그냥 문단 구분만 넣고 합침 (모델에 불필요한 라벨 넣지 않음)
    accText = segments.map(s => s.text).join("\n\n");
    accEffectiveLen = effectiveLenOf(accText);

    // conf는 "가장 좋은 세그먼트" 기준으로 참고
    accBestConf = 0;
    for (const s of segments) {
      if (typeof s.conf === "number" && s.conf > accBestConf) accBestConf = s.conf;
    }

    // 미리보기는 너무 길면 끝부분을 보여주는 게 “누적되고 있다” 느낌이 더 좋음
    const maxPreview = 8000;
    if (accText.length <= maxPreview) {
      ocrPreviewEl.value = accText;
    } else {
      ocrPreviewEl.value = accText.slice(-maxPreview);
    }
  }

  // =========================
  // 9) “완성” 구조 판단 (문제/제시문 인식)
  // =========================
  function hasProblemStructure(text) {
    // 다양한 표기 대응
    const t = text || "";
    const hasQ1 = /(\[?\s*문제\s*1\s*\]?)/.test(t) || /(1\)\s*)/.test(t);
    const hasQ2 = /(\[?\s*문제\s*2\s*\]?)/.test(t) || /(2\)\s*)/.test(t);
    return hasQ1 && hasQ2;
  }

  function hasPassageHint(text) {
    const t = text || "";
    // “제시문”, “보기”, “다음 글”, “자료” 등 신호
    return /(제시문\s*\d*|보기|다음\s*글|다음은|자료\s*\d*)/.test(t);
  }

  function isReadyToSolve() {
    // 최소한 너무 짧으면 금지
    if (accEffectiveLen < MIN_SOLVE_LEN_EFFECTIVE) return false;

    // 1순위: 문제 1/2 구조가 잡히면 거의 준비된 것
    const structure = hasProblemStructure(accText);

    // 제시문 신호까지 있으면 더 확실
    const passage = hasPassageHint(accText);

    // 구조 + (제시문 신호 또는 충분한 길이)면 ready
    if (structure && (passage || accEffectiveLen >= TEXT_THRESHOLD_EFFECTIVE)) return true;

    // 구조가 없더라도 길이가 매우 길면(사용자 최종 fallback) ready로 보긴 하지만,
    // 너가 “문제까지 다 인식했을 때” 원하니 여기서는 false 유지.
    return false;
  }

  function buildInsufficientReason() {
    if (blocked) return "카메라가 가려졌습니다. 렌즈를 가리지 않게 해주세요.";
    if (tooFar) return "지문이 너무 멀어 보입니다. 종이를 화면에 더 크게 채워주세요.";
    if (tooNear) return "지문이 너무 가까워 보입니다. 5에서 10센티미터 정도만 멀리 두고 다시 비춰주세요.";
    // 구조 기반 안내
    const structure = hasProblemStructure(accText);
    if (!structure) return "문제 1과 문제 2가 아직 충분히 인식되지 않았습니다. 문제 부분을 화면에 크게 비춰주세요.";
    return "아직 제시문이나 일부 문장이 부족합니다. 페이지를 조금 더 오래, 흔들림 없이 비춰주세요.";
  }

  function buildStatusLines(extraLine) {
    const lines = [];
    lines.push("자동 OCR(누적) → 자동 풀이");
    lines.push(`카메라 상태: ${blocked ? "가려짐" : "정상"}`);

    let dist = "정상(추정)";
    if (tooFar) dist = "너무 멂(추정)";
    else if (tooNear) dist = "너무 가까움(추정)";
    lines.push(`거리 상태: ${dist}`);

    lines.push(`자동 크롭(디지털 줌): ${cropFactor.toFixed(2)} (1.00=넓게, 0.72=확대)`);
    lines.push(`누적 세그먼트 수: ${segments.length}`);
    lines.push(`누적 길이(공백제외): ${accEffectiveLen}`);
    lines.push(`OCR 참고 신뢰도(최대): ${accBestConf.toFixed(1)}%`);

    const ready = isReadyToSolve();
    lines.push(`완성 판정(문제1·2/제시문): ${ready ? "OK" : "아직 부족"}`);

    if (notReadySince && !ready) {
      const sec = Math.floor((now() - notReadySince) / 1000);
      lines.push(`부족 지속: ${sec}초 (5분 안내 / 8분 자동풀이)`);
    } else {
      lines.push("부족 지속: 0초");
    }

    if (extraLine) lines.push(String(extraLine));
    return lines;
  }

  // =========================
  // 10) OCR 1회
  // =========================
  function shouldTryOcr() {
    if (solved || solving) return false;
    if (ocrRunning) return false;
    if (blocked) return false;

    const tNow = now();
    if (tNow - lastOcrAt < OCR_INTERVAL_MS) return false;

    const a = analyzeFrame();
    if (!a.stable) return false;

    return true;
  }

  async function doOcrOnce() {
    if (!shouldTryOcr()) return;
    ocrRunning = true;
    lastOcrAt = now();

    try {
      const canvas = captureToCanvas();
      setStatus(buildStatusLines("OCR 진행 중..."));

      const result = await Tesseract.recognize(canvas, OCR_LANG, {
        logger: (m) => {
          if (m && m.status === "recognizing text") {
            const p = Math.round((m.progress || 0) * 100);
            setStatus(buildStatusLines(`OCR 진행 중... ${p}%`));
          }
        }
      });

      const rawText = (result && result.data && result.data.text) ? result.data.text : "";
      const conf = (result && result.data && typeof result.data.confidence === "number")
        ? result.data.confidence
        : 0;

      const cleaned = normalizeOcrText(rawText);
      const effLen = effectiveLenOf(cleaned);

      // 거리 추정(휴리스틱)
      tooFar = (effLen < 400 && conf < 35);
      tooNear = (effLen >= 800 && conf < 35);

      // 자동 디지털 줌 조절
      const tNow2 = now();
      if (tNow2 - lastCropAdjustAt >= CROP_ADJUST_COOLDOWN_MS) {
        if (tooNear) {
          cropFactor = Math.min(CROP_MAX, cropFactor + 0.05); // 줌아웃
          lastCropAdjustAt = tNow2;
        } else if (tooFar) {
          cropFactor = Math.max(CROP_MIN, cropFactor - 0.05); // 확대
          lastCropAdjustAt = tNow2;
        }
      }

      // 누적 업데이트(중복이면 교체, 아니면 append)
      const mergeInfo = updateAccumulation(cleaned, conf);

      // ready/타이머
      const ready = isReadyToSolve();
      const tNow = now();

      if (!ready) {
        if (!notReadySince) notReadySince = tNow;
      } else {
        notReadySince = null;
      }

      setStatus(buildStatusLines(`OCR 완료 · 누적:${mergeInfo.action}`));

      // 자동풀이 조건
      if (!solved && !solving) {
        if (ready) {
          await autoSolve("문제/제시문 구조 인식 완료");
          return;
        }

        if (notReadySince) {
          const dur = tNow - notReadySince;

          // 5분 연속 부족이면 “진짜 부족할 때만” 안내
          if (dur >= INSUFFICIENT_WARN_MS && dur < MAX_WAIT_MS) {
            speak(buildInsufficientReason(), false);
          }

          // 8분이면 부족해도 자동풀이(너 요구)
          if (dur >= MAX_WAIT_MS) {
            await autoSolve("8분 경과. 현재 인식된 내용으로 풀이");
            return;
          }
        }
      }

    } catch (e) {
      console.error(e);
      setStatus(buildStatusLines("OCR 에러: " + String(e)));
    } finally {
      ocrRunning = false;
    }
  }

  // =========================
  // 11) solve 호출
  // =========================
  async function autoSolve(reason) {
    if (solved || solving) return;
    solving = true;

    // solve.js 내부에서 8000자로 자르니, 여기서도 너무 길면 미리 자름
    let payloadText = (accText || "").trim();
    if (payloadText.length > 8000) payloadText = payloadText.slice(0, 8000);

    setStatus(buildStatusLines(`풀이 요청 중... (${reason})`));
    answerBoxEl.textContent = "풀이 생성 중...";

    try {
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ ocrText: payloadText })
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();
      let out = "";

      if (ct.includes("application/json")) {
        let data;
        try { data = await res.json(); }
        catch (e) { out = "JSON 파싱 에러: " + String(e); }

        if (!out) {
          if (data && typeof data.answer === "string") out = data.answer;
          else if (data && typeof data.body === "string") out = data.body;
          else out = JSON.stringify(data);
        }
      } else {
        out = await res.text();
      }

      if (!res.ok) {
        answerBoxEl.textContent = `서버 에러 (status ${res.status})\n\n${out.slice(0, 4000)}`;
        speak("서버 에러가 발생했습니다.", true);
        solving = false;
        return;
      }

      solved = true;
      answerBoxEl.textContent = out;

      setStatus(buildStatusLines("풀이 완료"));
      speak("답안이 생성되었습니다.", true);
      speakLong(out);

    } catch (e) {
      console.error(e);
      answerBoxEl.textContent = "요청 실패: " + String(e);
      speak("요청에 실패했습니다.", true);
    } finally {
      solving = false;
    }
  }

  // =========================
  // 12) OCR 루프
  // =========================
  function scheduleOcrLoop() {
    doOcrOnce();
    setInterval(() => { doOcrOnce(); }, OCR_INTERVAL_MS);
  }

  // =========================
  // 13) 시작
  // =========================
  startCamera();

})();
</script>
</body>
</html>

