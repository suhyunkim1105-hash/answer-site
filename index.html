<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 16px; }
    #status { white-space: pre-wrap; padding: 10px; border: 1px solid #ddd; border-radius: 8px; min-height: 96px; }
    video { width: 100%; max-width: 520px; border-radius: 12px; background: #000; }
    button { padding: 12px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; font-size: 16px; }
    button:disabled { opacity: 0.5; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    textarea { width: 100%; min-height: 140px; margin-top: 10px; }
    .small { font-size: 12px; color: #666; line-height: 1.45; }
  </style>
</head>
<body>
  <h2>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</h2>

  <div id="status">ëŒ€ê¸° ì¤‘</div>

  <div class="row" style="margin:12px 0;">
    <button id="btnAudio">ğŸ”Š ì˜¤ë””ì˜¤ ì¤€ë¹„(í•œ ë²ˆë§Œ)</button>
    <button id="btnStart">ğŸ“¸ ìë™ ì‹œì‘</button>
    <button id="btnStop" disabled>â›” ì¤‘ì§€</button>
    <button id="btnReplay" disabled>ğŸ” ì •ë‹µ ë‹¤ì‹œë“£ê¸°</button>
  </div>

  <div class="small">
    - ë§ˆì§€ë§‰ í˜ì´ì§€ì— <b>XVRTH</b> ë¥¼ êµµê³  í¬ê²Œ ì ìœ¼ë©´ ìë™ìœ¼ë¡œ OCR ì¢…ë£Œ í›„ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br/>
    - iOS ë¬´ìŒëª¨ë“œ(ì‚¬ì¼ëŸ°íŠ¸)ë©´ TTSê°€ ì•ˆ ë“¤ë¦´ ìˆ˜ ìˆë‹¤. ë¬´ìŒ í•´ì œ + ë³¼ë¥¨ ì˜¬ë ¤ë¼.<br/>
    - ì¹´ë©”ë¼ ê¶Œí•œì´ ê±°ë¶€ë¼ ìˆìœ¼ë©´ Safari ì„¤ì •ì—ì„œ ì´ ì‚¬ì´íŠ¸ ì¹´ë©”ë¼ â€œí—ˆìš©â€ìœ¼ë¡œ ë°”ê¿”ì•¼ í•œë‹¤.
  </div>

  <div style="margin-top:12px;">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <h3 style="margin-top:16px;">OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸)</h3>
  <textarea id="ocrBox" placeholder="ìë™ OCR ê²°ê³¼ê°€ ëˆ„ì ëœë‹¤(ìˆ˜ë™ ìˆ˜ì • ê¸ˆì§€)."></textarea>

  <h3 style="margin-top:16px;">ì •ë‹µ(ë””ë²„ê·¸)</h3>
  <textarea id="ansBox" placeholder="ìë™ í’€ì´ ê²°ê³¼ê°€ ì—¬ê¸°ì— ì¶œë ¥ëœë‹¤."></textarea>

<script>
(() => {
  const OCR_URL   = "/.netlify/functions/ocr";
  const SOLVE_URL = "/.netlify/functions/solve";

  // ì´¬ì˜/ì¸ì‹ ì„¤ì •
  const SHOTS_PER_PAGE = 3;
  const SHOT_GAP_MS = 120;              // 5ì´ˆ ëŒ€ê¸° ì œê±°
  const MAX_PAGES = 25;
  const MAX_RETRY_PER_PAGE = 4;

  // í˜ì´ì§€ ë„˜ê¹€ ì•ˆë‚´ í›„ ë‹¤ìŒ ì´¬ì˜ê¹Œì§€ ëŒ€ê¸°
  const TURN_PAGE_WAIT_MS = 650;

  // OCR í’ˆì§ˆ ê¸°ì¤€
  const MIN_TEXT_LEN = 700;
  const MIN_QNUM_HITS = 2;
  const PASSAGE_LEN_OK = 1400;

  // ì¢…ë£Œ ê°ì§€
  const STOP_PHRASE = "XVRTH";

  // ì •ë‹µ TTS
  const ANSWER_ROUNDS = 4;
  const BETWEEN_ANS_MS = 2000;          // ë¬¸í•­ ì‚¬ì´ 2ì´ˆ
  const BETWEEN_ROUND_MS = 600;

  let running = false;
  let stream = null;

  let currentPage = 1;
  let pages = []; // {page, text, conf, qnums:Set<number>}
  let allText = "";

  let koVoice = null;
  let audioReady = false;
  let lastAnswers = null;

  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnAudio = document.getElementById("btnAudio");
  const btnStart = document.getElementById("btnStart");
  const btnStop = document.getElementById("btnStop");
  const btnReplay = document.getElementById("btnReplay");
  const ocrBox = document.getElementById("ocrBox");
  const ansBox = document.getElementById("ansBox");

  // ì´ˆê¸° ìƒíƒœ ê°•ì œ(ì‚¬íŒŒë¦¬ì—ì„œ ì´ìƒí•˜ê²Œ disabled ë‚¨ëŠ” ê²½ìš° ë°©ì§€)
  btnStart.disabled = false;
  btnStop.disabled = true;
  btnReplay.disabled = true;

  function log(msg) {
    const t = new Date().toLocaleTimeString("ko-KR", { hour12:false });
    statusEl.textContent = `[${t}] ${msg}\n` + statusEl.textContent;
    console.log(msg);
  }
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // ---------- iOS ì˜¤ë””ì˜¤ ì–¸ë½(ì²´ê°ë˜ê²Œ) ----------
  async function beep() {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      const ctx = new AC();
      await ctx.resume().catch(()=>{});
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = 880;     // ì§§ì€ í™•ì¸ìš©
      gain.gain.value = 0.08;        // ë„ˆë¬´ í¬ì§€ ì•Šê²Œ
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.08);
    } catch (_) {}
  }

  async function unlockAudio() {
    if (audioReady) return true;

    try { speechSynthesis.getVoices(); } catch (_) {}

    // iOS: ë²„íŠ¼ ì œìŠ¤ì²˜ì—ì„œ AudioContext+TTSë¥¼ ê°™ì´ ê¹¨ì›Œì•¼ ì•ˆì •ì 
    await beep();
    audioReady = true;
    log("AudioContext ì–¸ë½ ì™„ë£Œ");
    return true;
  }

  // ---------- TTS ----------
  function pickKoreanVoice() {
    const voices = speechSynthesis.getVoices() || [];
    const ko = voices.filter(v => (v.lang || "").toLowerCase().startsWith("ko"));
    const preferred = ko.find(v => /yuna|ìœ ë‚˜|ì„œí˜„|ì§€ì€|ì•„ë¦¬/i.test(v.name));
    koVoice = preferred || ko[0] || null;
    if (koVoice) log(`TTS voice: ${koVoice.name} (${koVoice.lang})`);
    else log("TTS voice ì„ íƒ ì‹¤íŒ¨");
  }

  function speak(text) {
    return new Promise(resolve => {
      try {
        const u = new SpeechSynthesisUtterance(String(text));
        u.lang = "ko-KR";
        u.rate = 1.0;
        if (koVoice) u.voice = koVoice;
        u.onend = resolve;
        u.onerror = resolve;
        speechSynthesis.speak(u);
      } catch (_) { resolve(); }
    });
  }

  async function speakTurnPage(page) {
    await speak(`í˜ì´ì§€ ${page} ì¸ì‹ ì™„ë£Œ. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë„˜ê²¨ ì£¼ì„¸ìš”.`);
    await sleep(TURN_PAGE_WAIT_MS);
  }

  async function speakAnswers(answerNumMap) {
    const toLetter = (n)=>["A","B","C","D","E"][Number(n)-1] || "";
    const keys = Object.keys(answerNumMap).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);

    try { speechSynthesis.cancel(); } catch (_) {}

    for (let r=1; r<=ANSWER_ROUNDS; r++) {
      for (const q of keys) {
        const a = toLetter(answerNumMap[String(q)]);
        if (!a) continue;
        await speak(`${q}ë²ˆ ${a}`);
        await sleep(BETWEEN_ANS_MS);
      }
      await sleep(BETWEEN_ROUND_MS);
    }
  }

  // ---------- Camera (3ë‹¨ê³„ fallback + play() ê°•ì œ + ì—ëŸ¬ í‘œì‹œ) ----------
  async function getStreamWithFallback() {
    const tries = [
      { video: { facingMode: { ideal: "environment" }, width:{ ideal:1440 }, height:{ ideal:2560 } }, audio:false },
      { video: { facingMode: "environment" }, audio:false },
      { video: true, audio:false }
    ];

    let lastErr = null;
    for (const c of tries) {
      try {
        const s = await navigator.mediaDevices.getUserMedia(c);
        return s;
      } catch (e) {
        lastErr = e;
      }
    }
    throw lastErr || new Error("getUserMedia failed");
  }

  function explainCamError(e) {
    const name = String(e?.name || "");
    if (name === "NotAllowedError" || name === "PermissionDeniedError") {
      return "ì¹´ë©”ë¼ ê¶Œí•œì´ ê±°ë¶€ë¨(NotAllowed). iOS ì„¤ì •ì—ì„œ Safariâ†’ì¹´ë©”ë¼ í—ˆìš© + ì´ ì‚¬ì´íŠ¸ ê¶Œí•œ í—ˆìš© í•„ìš”.";
    }
    if (name === "NotFoundError") return "ì¹´ë©”ë¼ ì¥ì¹˜ë¥¼ ì°¾ì§€ ëª»í•¨(NotFound).";
    if (name === "NotReadableError") return "ì¹´ë©”ë¼ê°€ ë‹¤ë¥¸ ì•±ì—ì„œ ì‚¬ìš© ì¤‘(NotReadable). ë‹¤ë¥¸ ì•± ì¢…ë£Œ í›„ ì¬ì‹œë„.";
    if (name === "OverconstrainedError") return "ì¹´ë©”ë¼ ì œì•½ì¡°ê±´ ì‹¤íŒ¨(Overconstrained).";
    return "ì¹´ë©”ë¼ ì˜¤ë¥˜: " + (e?.message ? e.message : String(e));
  }

  async function startCamera() {
    if (stream) return;
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error("ì´ ë¸Œë¼ìš°ì €ëŠ” ì¹´ë©”ë¼ APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŒ");
    }

    stream = await getStreamWithFallback();
    video.srcObject = stream;

    // iOSì—ì„œ autoplay/playsinlineì´ì–´ë„ play() í˜¸ì¶œì´ í•„ìš”í•  ë•Œê°€ ìˆìŒ
    try { await video.play(); } catch (_) {}

    // ë©”íƒ€ë°ì´í„° ëŒ€ê¸°(ë„ˆë¬´ ì˜¤ë˜ ê±¸ë¦¬ë©´ ê·¸ëƒ¥ ì§„í–‰)
    await Promise.race([
      new Promise(r => video.onloadedmetadata = r),
      sleep(800)
    ]);

    log(`ì¹´ë©”ë¼ OK (${video.videoWidth}x${video.videoHeight})`);
  }

  // ---------- OCR ----------
  async function callOcr(dataUrl, pageIndex) {
    const payload = { image: dataUrl, pageIndex, mode: "dual" };
    const res = await fetch(OCR_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    const j = await res.json().catch(()=>null);
    if (!j || !j.ok) return { ok:false, text:"", conf:0 };
    return { ok:true, text:String(j.text||""), conf:Number(j.conf||0) };
  }

  const normalizeNoSpace = (s)=>String(s||"").replace(/\s+/g,"").trim();
  function detectStop(text) {
    const t = normalizeNoSpace(text);
    return t.includes(normalizeNoSpace(STOP_PHRASE));
  }

  function qnumHits(text) {
    const m = String(text||"").match(/(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g);
    return m ? m.length : 0;
  }

  function extractQnumsFromPage(text) {
    const out = new Set();
    const re = /(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g;
    let m;
    const t = String(text||"");
    while ((m = re.exec(t)) !== null) out.add(parseInt(m[1],10));
    return out;
  }

  function qualityOk(text) {
    const len = String(text||"").length;
    const hits = qnumHits(text);
    if (len >= PASSAGE_LEN_OK) return true;
    if (len >= MIN_TEXT_LEN && hits >= MIN_QNUM_HITS) return true;
    return false;
  }

  function captureFrameBase64Jpeg(quality=0.90) {
    const w = video.videoWidth, h = video.videoHeight;
    if (!w || !h) throw new Error("ì¹´ë©”ë¼ í”„ë ˆì„ í¬ê¸° 0(ì•„ì§ ìŠ¤íŠ¸ë¦¼ ì¤€ë¹„ ì•ˆ ë¨)");
    const canvas = document.createElement("canvas");
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);
    return canvas.toDataURL("image/jpeg", quality);
  }

  async function ocrOnePage(pageIndex) {
    let best = null;

    for (let shot=1; shot<=SHOTS_PER_PAGE; shot++) {
      if (!running) return null;
      await sleep(SHOT_GAP_MS);

      const dataUrl = captureFrameBase64Jpeg(0.90);
      const r = await callOcr(dataUrl, pageIndex);

      const text = r.ok ? r.text : "";
      const conf = r.ok ? r.conf : 0;

      const score = (text.length/50) + (qnumHits(text)*30) + (conf*2);
      log(`OCR ${r.ok?"OK":"FAIL"} page=${pageIndex} shot=${shot} len=${text.length} conf=${conf} score=${score.toFixed(1)}`);

      const cand = { shot, text, conf, score, stop: detectStop(text) };
      if (!best || cand.score > best.score) best = cand;

      if (cand.stop) return cand;
    }

    if (!best) return null;
    best.stop = detectStop(best.text);
    return best;
  }

  function rebuildAllText() {
    allText = "";
    for (const p of pages) {
      allText += `[PAGE ${p.page}] (conf=${(p.conf||0).toFixed(1)})\n${p.text}\n\n`;
    }
    ocrBox.value = allText;
  }

  async function recaptureSpecificPages(targetPages) {
    for (const p of targetPages) {
      if (!running) return;
      await speak(`ë¬¸ì œê°€ ìˆëŠ” í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤. í˜ì´ì§€ ${p}ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”.`);
      await sleep(350);

      let ok = false;
      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) return;
        log(`ì¬ì´¬ì˜: í˜ì´ì§€ ${p} ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        const r = await ocrOnePage(p);
        if (!r) break;

        if (r.stop || qualityOk(r.text)) {
          const idx = pages.findIndex(x => x.page === p);
          const qnums = extractQnumsFromPage(r.text);
          const entry = { page:p, text:r.text, conf:r.conf, qnums };
          if (idx >= 0) pages[idx] = entry; else pages.push(entry);
          pages.sort((a,b)=>a.page-b.page);
          rebuildAllText();
          ok = true;
          break;
        }
        await speak(`í˜ì´ì§€ ${p} ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”.`);
      }

      if (!ok) {
        await speak(`í˜ì´ì§€ ${p}ë¥¼ ë‹¤ì‹œ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì¡°ëª…ê³¼ ê°ë„ë¥¼ ì¡°ì •í•´ ì£¼ì„¸ìš”.`);
        throw new Error(`ì¬ì´¬ì˜ ì‹¤íŒ¨(page=${p})`);
      }
    }
  }

  // ---------- Solve ----------
  async function callSolve(allText) {
    const res = await fetch(SOLVE_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ text: allText })
    });
    const j = await res.json().catch(()=>null);
    if (!j) return { ok:false, error:"Solve JSON parse failed" };
    return j;
  }

  function answersToText(ansNumMap) {
    const toLetter = (n)=>["A","B","C","D","E"][Number(n)-1] || "";
    const keys = Object.keys(ansNumMap||{}).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);
    return keys.map(k => `${k}ë²ˆ: ${toLetter(ansNumMap[String(k)])}`).join("\n");
  }

  function mapBadQuestionsToPages(badQs) {
    const pagesSet = new Set();
    for (const q of badQs) {
      for (const p of pages) {
        if (p.qnums && p.qnums.has(q)) pagesSet.add(p.page);
      }
    }
    return Array.from(pagesSet).sort((a,b)=>a-b);
  }

  // ---------- Main ----------
  async function runAuto() {
    running = true;
    btnStart.disabled = true;
    btnStop.disabled = false;
    btnReplay.disabled = true;

    pages = [];
    allText = "";
    currentPage = 1;
    ocrBox.value = "";
    ansBox.value = "";
    lastAnswers = null;

    await unlockAudio();
    pickKoreanVoice();

    // ì¹´ë©”ë¼ë¥¼ ë¨¼ì € í™•ì‹¤íˆ ì—´ê³ , ì‹¤íŒ¨ ì›ì¸ì„ â€œë³´ì´ê²Œâ€ í•œë‹¤
    try {
      await startCamera();
    } catch (e) {
      const msg = explainCamError(e);
      log(msg);
      await speak("ì¹´ë©”ë¼ë¥¼ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¶Œí•œì„ í™•ì¸í•´ ì£¼ì„¸ìš”.");
      throw new Error(msg);
    }

    await speak("ìë™ ì´¬ì˜ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì‹œí—˜ì§€ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë§ì¶° ì£¼ì„¸ìš”.");

    while (running && currentPage <= MAX_PAGES) {
      let okPage = false;
      let last = null;

      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) break;

        log(`í˜ì´ì§€ ${currentPage} OCR ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        last = await ocrOnePage(currentPage);
        if (!last) break;

        const ok = last.stop || qualityOk(last.text);

        if (ok) {
          const qnums = extractQnumsFromPage(last.text);
          pages.push({ page: currentPage, text: last.text, conf: last.conf, qnums });
          rebuildAllText();
          okPage = true;
          break;
        } else {
          await speak(`í˜ì´ì§€ ${currentPage} ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”.`);
        }
      }

      if (!okPage) {
        await speak(`í˜ì´ì§€ ${currentPage}ë¥¼ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì¡°ëª…ê³¼ ê°ë„ë¥¼ ì¡°ì •í•´ ì£¼ì„¸ìš”.`);
        throw new Error(`OCR ì‹¤íŒ¨(page=${currentPage})`);
      }

      if (last && last.stop) {
        log(`STOP(${STOP_PHRASE}) ê°ì§€ â†’ OCR ì¢…ë£Œ`);
        break;
      }

      await speakTurnPage(currentPage);
      currentPage++;
    }

    await speak("ì´ì œ ë¬¸ì œë¥¼ í’‰ë‹ˆë‹¤.");
    log("SOLVE ì‹œì‘");

    for (let attempt=1; attempt<=2; attempt++) {
      const solved = await callSolve(allText);

      if (solved.ok && solved.answers) {
        lastAnswers = solved.answers;
        ansBox.value = answersToText(solved.answers);
        btnReplay.disabled = false;
        await speak("ì •ë‹µì„ ì½ê² ìŠµë‹ˆë‹¤.");
        await speakAnswers(solved.answers);
        log("ì™„ë£Œ");
        return;
      }

      const badQs = Array.isArray(solved.bad_questions) ? solved.bad_questions : [];
      if (badQs.length === 0 || attempt === 2) {
        log(`SOLVE ì‹¤íŒ¨: ${solved.error || "unknown"}`);
        await speak("í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì´¬ì˜ ìƒíƒœë¥¼ ê°œì„ í•´ ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”.");
        throw new Error(`SOLVE ì‹¤íŒ¨: ${solved.error || "unknown"}`);
      }

      const targetPages = mapBadQuestionsToPages(badQs);
      if (targetPages.length === 0) {
        await speak("ì¼ë¶€ ë¬¸í•­ ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”.");
        throw new Error("bad_questions page mapping failed");
      }

      await speak(`ë‹¤ìŒ ë¬¸í•­ì´ ì˜ ì•ˆ ì½í˜”ìŠµë‹ˆë‹¤. ${badQs.slice(0,10).join(", ")}ë²ˆ. í•´ë‹¹ í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
      await recaptureSpecificPages(targetPages);
      log("ì¬ì´¬ì˜ í›„ SOLVE ì¬ì‹œë„");
    }
  }

  function stopAll() {
    running = false;
    btnStart.disabled = false;
    btnStop.disabled = true;
    try { speechSynthesis.cancel(); } catch(_) {}
    log("STOP");
  }

  // ì˜¤ë””ì˜¤ ì¤€ë¹„ ë²„íŠ¼: â€œì‚‘â€ + â€œì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œâ€ë¥¼ ì‹¤ì œë¡œ ë“¤ë ¤ì¤€ë‹¤
  btnAudio.addEventListener("click", async () => {
    try {
      await unlockAudio();
      pickKoreanVoice();
      await speak("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ.");
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ(ë²„íŠ¼)");
    } catch (e) {
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì‹¤íŒ¨: " + String(e?.message || e));
    }
  });

  btnStart.addEventListener("click", async () => {
    try {
      await runAuto();
    } catch (e) {
      log(`ERROR: ${e && e.message ? e.message : e}`);
      try { await speak("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”."); } catch (_) {}
      stopAll();
    }
  });

  btnStop.addEventListener("click", () => stopAll());

  btnReplay.addEventListener("click", async () => {
    try {
      await unlockAudio();
      pickKoreanVoice();
      if (!lastAnswers) { await speak("ì •ë‹µì´ ì—†ìŠµë‹ˆë‹¤."); return; }
      await speakAnswers(lastAnswers);
    } catch (e) {
      log("ì •ë‹µ ë‹¤ì‹œë“£ê¸° ì‹¤íŒ¨: " + String(e?.message || e));
    }
  });

  speechSynthesis.onvoiceschanged = () => pickKoreanVoice();
})();
</script>
</body>
</html>
