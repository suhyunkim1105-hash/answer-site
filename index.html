<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Auto OCR → Solve</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0b0b; color:#eaeaea; font-family: -apple-system, system-ui, Segoe UI, Roboto, "Noto Sans KR", sans-serif; }
    .wrap { max-width: 860px; margin: 0 auto; padding: 14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { background:#1b1b1b; color:#eaeaea; border:1px solid #333; padding:10px 12px; border-radius:12px; font-size:15px; }
    button:active { transform: scale(0.99); }
    .card { border:1px solid #262626; border-radius:14px; padding:12px; background:#101010; }
    .muted { color:#aaa; }
    .big { width:100%; }
    video { width:100%; border-radius:14px; background:#000; }
    textarea { width:100%; min-height: 160px; background:#0c0c0c; color:#eaeaea; border:1px solid #2a2a2a; border-radius:12px; padding:10px; font-size:14px; line-height:1.4; }
    pre { white-space: pre-wrap; word-break: break-word; margin:0; }
    .kpi { font-variant-numeric: tabular-nums; }
  </style>

  <!-- Tesseract.js v4 (v5랑 섞이면 worker.load 에러 난다) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="row">
      <button id="btnCam">카메라 시작(필수 1회 탭)</button>
      <button id="btnVoice">음성 연결/테스트(필수 1회 탭)</button>
      <button id="btnReset">OCR 재시작(새로고침)</button>
      <button id="btnForceSolve">지금까지로 풀이</button>
    </div>

    <div class="card" style="margin-top:12px">
      <div class="muted kpi" id="statusLine">OCR 엔진: 로딩 중…</div>
      <div style="margin-top:8px">
        <video id="video" playsinline muted></video>
      </div>
      <div class="muted" style="margin-top:8px">
        iOS는 “카메라/음성”이 첫 탭(유저 제스처)이 필요하다. 위 버튼 2개는 반드시 한 번 눌러라.
      </div>
    </div>

    <div class="card" style="margin-top:12px">
      <div class="kpi" id="kpi"></div>
      <div class="muted" id="lastMsg" style="margin-top:6px"></div>
    </div>

    <div class="card" style="margin-top:12px">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div><b>실시간 OCR(누적)</b></div>
        <button id="btnCopy">누적 텍스트 복사</button>
      </div>
      <textarea id="ocrBox" placeholder="OCR 누적 텍스트가 여기에 쌓임"></textarea>
    </div>

    <div class="card" style="margin-top:12px">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <div><b>답안</b></div>
        <button id="btnStopSpeak">음성 중지</button>
      </div>
      <textarea id="ansBox" placeholder="아직 답안 없음"></textarea>
    </div>
  </div>

  <script>
    // ====== 튜닝값(안정성/퀄리티 우선) ======
    const LANG = "kor";
    const OCR_INTERVAL_MS = 2500;     // OCR 실행 간격
    const MIN_LEN_FOR_SOLVE = 2400;   // 공백 제거 길이
    const MIN_CONF_FOR_SOLVE = 65;    // 평균 신뢰도(대략)
    const STABLE_MS_REQUIRED = 800;   // 흔들림 없다고 판단하는 최소 유지시간
    const FORCE_OCR_AFTER_MS = 12000; // 아무리 흔들려도 12초 지나면 1번은 OCR 강제(막힘 방지)
    const MAX_INPUT_CHARS_TO_SOLVE = 8500; // solve에 보내는 최대 글자수(너무 길면 타임아웃 확률↑)

    // Tesseract 경로(여기가 꼬이면 "로딩/불안정"에서 멈춤)
    const workerOpts = {
      logger: () => {},
      workerPath: "https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/worker.min.js",
      corePath: "https://cdn.jsdelivr.net/npm/tesseract.js-core@4.0.4",
      langPath: "https://cdn.jsdelivr.net/npm/@tessdata/kor@1.0.0",
    };

    // ====== DOM ======
    const video = document.getElementById("video");
    const statusLine = document.getElementById("statusLine");
    const kpi = document.getElementById("kpi");
    const lastMsg = document.getElementById("lastMsg");
    const ocrBox = document.getElementById("ocrBox");
    const ansBox = document.getElementById("ansBox");

    const btnCam = document.getElementById("btnCam");
    const btnVoice = document.getElementById("btnVoice");
    const btnReset = document.getElementById("btnReset");
    const btnForceSolve = document.getElementById("btnForceSolve");
    const btnStopSpeak = document.getElementById("btnStopSpeak");
    const btnCopy = document.getElementById("btnCopy");

    // ====== 상태 ======
    let worker = null;
    let workerReady = false;

    let camReady = false;
    let stream = null;

    let ocrTimer = null;
    let analyzing = false;
    let solvedOnce = false;

    let lastOcrAt = 0;
    let stableSince = 0;
    let firstFrameAt = 0;

    let prevSmall = null; // 흔들림 측정용
    let avgConf = 0;
    let confSamples = 0;

    // canvas 준비
    const capCanvas = document.createElement("canvas");
    const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

    const smallCanvas = document.createElement("canvas");
    const smallCtx = smallCanvas.getContext("2d", { willReadFrequently: true });

    function now() { return Date.now(); }
    function compactLen(s) { return (s || "").replace(/\s+/g, "").length; }

    function setMsg(s) { lastMsg.textContent = s; }
    function setStatus(s) { statusLine.textContent = s; }

    // ====== 음성 ======
    let voiceReady = false;
    function speak(text) {
      try {
        if (!text) return;
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "ko-KR";
        u.rate = 1.0;
        u.pitch = 1.0;
        window.speechSynthesis.speak(u);
      } catch (e) {}
    }

    btnStopSpeak.onclick = () => window.speechSynthesis.cancel();

    btnVoice.onclick = () => {
      // iOS는 “첫 탭”에서 한번 재생 시도해야 이후 자동읽기가 안정적
      voiceReady = true;
      speak("음성 연결 완료");
    };

    // ====== 카메라 ======
    btnCam.onclick = async () => {
      try {
        setMsg("카메라 연결 시도…");
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        camReady = true;
        firstFrameAt = now();
        setMsg("카메라 연결 완료");
      } catch (e) {
        camReady = false;
        setMsg("카메라 실패: iOS 설정 > Safari > 카메라 허용 확인 + 페이지 새로고침");
      }
    };

    // ====== Tesseract 워커 ======
    async function initWorker() {
      workerReady = false;
      setStatus("OCR 엔진: 로딩 중…");
      try {
        worker = Tesseract.createWorker(workerOpts);
        await worker.load();
        await worker.loadLanguage(LANG);
        await worker.initialize(LANG);
        workerReady = true;
        setStatus("OCR 엔진: 준비됨");
        setMsg("OCR 엔진 준비 완료");
      } catch (e) {
        workerReady = false;
        setStatus("OCR 엔진: 로딩/불안정");
        setMsg("OCR 엔진 로딩 실패(네트워크/차단 가능). iOS 데이터절약/콘텐츠차단 끄고 새로고침.");
      }
    }

    // ====== 흔들림 점수(막히지 않게 설계) ======
    function computeMotionScore() {
      if (!camReady) return 999;

      const vw = video.videoWidth || 0;
      const vh = video.videoHeight || 0;
      if (vw === 0 || vh === 0) return 999;

      // 작은 프레임으로 흔들림만 체크(가벼움)
      const sw = 160;
      const sh = Math.round(sw * (vh / vw));
      smallCanvas.width = sw;
      smallCanvas.height = sh;

      smallCtx.drawImage(video, 0, 0, sw, sh);
      const img = smallCtx.getImageData(0, 0, sw, sh).data;

      // grayscale 간단 샘플링
      const cur = new Uint8Array(sw * sh);
      for (let i = 0, p = 0; i < img.length; i += 4, p++) {
        cur[p] = (img[i] * 0.299 + img[i+1] * 0.587 + img[i+2] * 0.114) | 0;
      }

      if (!prevSmall) {
        prevSmall = cur;
        return 999; // 첫 프레임은 비교 불가
      }

      let diff = 0;
      for (let i = 0; i < cur.length; i += 7) { // 샘플링으로 더 가볍게
        diff += Math.abs(cur[i] - prevSmall[i]);
      }
      prevSmall = cur;
      return diff / (cur.length / 7);
    }

    function updateStability(motionScore) {
      const t = now();
      const stable = motionScore !== 999 && motionScore < 6.0; // 임계치(필요하면 8~10으로 올려도 됨)

      if (stable) {
        if (!stableSince) stableSince = t;
      } else {
        stableSince = 0;
      }

      // “영원히 안정 안 됨” 방지: 일정 시간 지나면 1번은 OCR 허용
      const force = firstFrameAt && (t - firstFrameAt) > FORCE_OCR_AFTER_MS;
      const stableEnough = stableSince && (t - stableSince) >= STABLE_MS_REQUIRED;

      return { stable, stableEnough, force };
    }

    // ====== 캡처/전처리 ======
    function captureFrameForOCR() {
      const vw = video.videoWidth || 0;
      const vh = video.videoHeight || 0;
      if (vw === 0 || vh === 0) return null;

      // 크게 캡처(퀄리티 우선)
      const targetW = 1280;
      const targetH = Math.round(targetW * (vh / vw));
      capCanvas.width = targetW;
      capCanvas.height = targetH;

      // 약간의 대비/밝기 보정(저비용)
      capCtx.filter = "contrast(1.35) brightness(1.08)";
      capCtx.drawImage(video, 0, 0, targetW, targetH);
      capCtx.filter = "none";

      return capCanvas;
    }

    // ====== OCR 실행 ======
    async function doOCR() {
      if (!workerReady || !camReady || analyzing) return;

      const motionScore = computeMotionScore();
      const { stableEnough, force } = updateStability(motionScore);

      // 안정성 조건 만족 또는 강제 1회
      if (!stableEnough && !force) {
        setStatus(`OCR 엔진: 준비됨 | 흔들림 감지 → 1초 고정 필요 (score=${motionScore.toFixed(1)})`);
        return;
      }

      const canvas = captureFrameForOCR();
      if (!canvas) return;

      analyzing = true;
      setStatus("OCR 진행 중…");
      try {
        const result = await worker.recognize(canvas);
        const text = (result?.data?.text || "").trim();
        const conf = (result?.data?.confidence ?? 0);

        if (text) {
          // 누적: 일단은 “계속 이어붙이기”(가장 안전)
          // (교체/페이지 분리 같은 고급 로직은 OCR이 안정화된 다음에 붙여)
          const before = ocrBox.value.trim();
          const merged = (before ? (before + "\n" + text) : text);
          // 너무 길어지면 UI/메모리 터짐 방지
          ocrBox.value = merged.slice(-20000);

          confSamples++;
          avgConf = ((avgConf * (confSamples - 1)) + conf) / confSamples;

          setMsg(`OCR 갱신: +${text.length}자, conf≈${conf.toFixed(1)}%`);
        } else {
          setMsg("OCR 결과가 비어있음(프레임에 글자가 너무 작거나 반사/흐림 가능)");
        }

        // 자동 solve 트리거
        const clen = compactLen(ocrBox.value);
        const okLen = clen >= MIN_LEN_FOR_SOLVE;
        const okConf = avgConf >= MIN_CONF_FOR_SOLVE;

        // “품질 우선”이니까 둘 다 만족할 때 자동 호출
        if (!solvedOnce && okLen && okConf) {
          await callSolve(false);
          solvedOnce = true;
        } else {
          setStatus(`OCR 엔진: 준비됨 | 누적(공백제외)=${clen}/${MIN_LEN_FOR_SOLVE} | 평균 conf≈${avgConf.toFixed(1)}%/${MIN_CONF_FOR_SOLVE}% | motion=${motionScore === 999 ? 999 : motionScore.toFixed(1)}`);
        }

      } catch (e) {
        setMsg("OCR 에러: 네트워크/워커 로딩 문제 가능. 새로고침 후 재시도.");
        setStatus("OCR 엔진: 로딩/불안정");
      } finally {
        analyzing = false;
      }
    }

    // ====== solve 호출 ======
    async function callSolve(force) {
      const raw = ocrBox.value || "";
      if (!raw.trim()) {
        ansBox.value = "OCR 텍스트가 비어있음";
        return;
      }

      // solve로 보내는 입력을 제한(타임아웃 방지)
      const trimmed = raw.slice(-MAX_INPUT_CHARS_TO_SOLVE);

      ansBox.value = force ? "지금까지로 강제 풀이 중…" : "충분한 지문 인식으로 자동 풀이합니다.";
      setMsg("solve 호출…");

      try {
        const r = await fetch("/.netlify/functions/solve", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ text: trimmed })
        });
        const j = await r.json().catch(() => ({}));
        if (!r.ok) {
          ansBox.value = JSON.stringify(j || { error: "solve failed" }, null, 2);
          return;
        }
        const out = (j.answer || "").trim();
        if (!out) {
          ansBox.value = "No answer (모델 응답 비어있음). 입력을 더 줄여서 다시 시도";
          return;
        }
        ansBox.value = out;

        // 음성: 답안만 읽기(유저가 먼저 “음성 연결/테스트” 탭했을 때만)
        if (voiceReady) speak(out);

      } catch (e) {
        ansBox.value = "solve 네트워크 오류/타임아웃. (Netlify Functions 로그 확인 필요)";
      }
    }

    btnForceSolve.onclick = () => callSolve(true);

    btnReset.onclick = async () => {
      // OCR 상태 전부 초기화
      ocrBox.value = "";
      ansBox.value = "아직 답안 없음";
      avgConf = 0; confSamples = 0;
      solvedOnce = false;
      stableSince = 0;
      prevSmall = null;
      firstFrameAt = now();
      setMsg("OCR 누적 초기화 완료");

      if (worker) {
        try { await worker.terminate(); } catch (e) {}
      }
      await initWorker();
    };

    btnCopy.onclick = async () => {
      try {
        await navigator.clipboard.writeText(ocrBox.value || "");
        setMsg("누적 OCR 텍스트 복사 완료");
      } catch (e) {
        setMsg("복사 실패(iOS 제한 가능). 길게 눌러 수동 복사해.");
      }
    };

    // 시작: 워커 먼저 올려두기
    (async function boot(){
      await initWorker();
      // 자동 OCR 루프
      if (ocrTimer) clearInterval(ocrTimer);
      ocrTimer = setInterval(doOCR, OCR_INTERVAL_MS);
    })();
  </script>
</body>
</html>
