<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OCR → 자동 풀이</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; background:#0b0b0e; color:#e9e9ef; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 14px 12px 28px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .btn {
      appearance:none; border:1px solid rgba(255,255,255,.15); background: rgba(255,255,255,.06);
      color:#fff; padding:12px 14px; border-radius:14px; font-weight:700; cursor:pointer;
    }
    .btn:active { transform: translateY(1px); }
    .btn.primary { background: rgba(0, 180, 255, .18); border-color: rgba(0, 180, 255, .35); }
    .btn.danger { background: rgba(255, 70, 70, .14); border-color: rgba(255, 70, 70, .28); }
    .pill { padding:10px 12px; border-radius:14px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04); }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; margin-top: 12px; }
    @media (min-width: 860px) { .grid { grid-template-columns: 1fr 1fr; } }

    .card { border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.04); border-radius:18px; padding: 12px; }
    .title { font-size: 15px; font-weight: 900; margin:0 0 8px; opacity:.95; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .muted { opacity:.72; font-size: 12px; line-height: 1.4; }
    .big { font-size: 13px; line-height: 1.55; white-space: pre-wrap; word-break: break-word; }
    .videoBox { aspect-ratio: 4/3; width:100%; overflow:hidden; border-radius:14px; border:1px solid rgba(255,255,255,.12); background:#000; display:flex; align-items:center; justify-content:center; }
    video { width:100%; height:100%; object-fit: cover; transform: scaleX(-1); }
    .kv { display:grid; grid-template-columns: 1fr 1fr; gap:8px; }
    .kv .pill { font-size:12px; }
    .right { margin-left:auto; }
    .spacer { height: 6px; }
    .warn { color:#ffd27a; }
    .ok { color:#8bffa8; }
    .bad { color:#ff7a7a; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="row">
      <button id="btnCam" class="btn primary">카메라 시작(필수 1회 탭)</button>
      <button id="btnAudio" class="btn">음성 연결/테스트(필수 1회 탭)</button>
      <button id="btnReload" class="btn">새로고침</button>
      <button id="btnForceSolve" class="btn danger right">지금까지로 풀이</button>
    </div>

    <div class="spacer"></div>

    <div class="row">
      <div class="pill mono" style="flex:1">
        OCR 엔진: <span id="engineStatus">대기</span>
        | 카메라: <span id="camStatus">대기</span>
        | 음성: <span id="ttsStatus">대기</span>
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <h3 class="title">카메라 프리뷰</h3>
        <div class="videoBox">
          <video id="video" playsinline muted></video>
        </div>

        <div class="spacer"></div>

        <div class="kv">
          <div class="pill mono">누적 길이(공백제외): <span id="lenNoSpace">0</span> / 기준 <span id="thLen">2400</span></div>
          <div class="pill mono">평균 신뢰도(대략): <span id="avgConf">0.0%</span> / 기준 <span id="thConf">70%</span></div>
          <div class="pill mono">세그먼트(페이지 추정): <span id="segCount">0</span></div>
          <div class="pill mono">경과: <span id="elapsed">0s</span> / 부족 지속: <span id="lackSec">0s</span></div>
          <div class="pill mono">밝기(대략): <span id="brightness">-</span></div>
          <div class="pill mono">흔들림(대략): <span id="shake">-</span></div>
        </div>

        <div class="spacer"></div>
        <div class="muted">
          iOS는 카메라/음성이 “첫 탭”이 필수다. 위 버튼 2개는 반드시 한 번 눌러라.<br>
          팁: 종이를 화면에 꽉 차게, 흔들림 없이 1초 고정하면 OCR 정확도가 크게 오른다.
        </div>
      </div>

      <div class="card">
        <h3 class="title">자동 OCR(누적) → 자동 풀이</h3>
        <div class="pill mono" id="autoMsg">대기 중…</div>

        <div class="spacer"></div>

        <h3 class="title">실시간 OCR(누적)</h3>
        <div class="card" style="padding:10px; border-radius:14px;">
          <div id="ocrText" class="big">OCR 누적 텍스트가 여기에 쌓임</div>
        </div>

        <div class="spacer"></div>

        <div class="row">
          <button id="btnStopSpeech" class="btn right">음성 중지</button>
        </div>

        <h3 class="title">답안</h3>
        <div class="card" style="padding:10px; border-radius:14px;">
          <div id="answerText" class="big">아직 답안 없음</div>
        </div>
      </div>
    </div>

    <canvas id="canvas" style="display:none;"></canvas>
  </div>

  <!-- ✅ tesseract.js v5 (jsDelivr) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
  // =========================
  // 설정 (안정성/퀄리티 우선)
  // =========================
  const TESS_CFG = {
    workerPath: "https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js",
    corePath:   "https://cdn.jsdelivr.net/npm/tesseract.js-core@5/tesseract-core.wasm.js",
    langPath:   "https://tessdata.projectnaptha.com/4.0.0"
  };

  const OCR_LANG = "kor";              // 한국어만
  const OCR_INTERVAL_MS = 2400;        // 안정성 우선 (너무 빠르면 iOS에서 망가짐)
  const MAX_IDLE_SOLVE_SEC = 8 * 60;   // 지문 부족 8분이면 강제 풀이
  const THRESH_LEN_NOSPACE = 2400;     // 충분한 지문 기준
  const THRESH_CONF = 0.70;            // 평균 신뢰도 기준(대략)
  const THRESH_SEGMENTS = 2;           // 페이지 추정 2개 이상
  const SOLVE_ENDPOINT = "/.netlify/functions/solve";

  // =========================
  // DOM
  // =========================
  const $ = (id) => document.getElementById(id);

  const video = $("video");
  const canvas = $("canvas");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });

  const engineStatus = $("engineStatus");
  const camStatus = $("camStatus");
  const ttsStatus = $("ttsStatus");

  const ocrTextEl = $("ocrText");
  const answerTextEl = $("answerText");
  const autoMsgEl = $("autoMsg");

  const lenNoSpaceEl = $("lenNoSpace");
  const avgConfEl = $("avgConf");
  const segCountEl = $("segCount");
  const elapsedEl = $("elapsed");
  const lackSecEl = $("lackSec");
  const brightnessEl = $("brightness");
  const shakeEl = $("shake");
  const thLenEl = $("thLen");
  const thConfEl = $("thConf");

  thLenEl.textContent = String(THRESH_LEN_NOSPACE);
  thConfEl.textContent = String(Math.round(THRESH_CONF * 100)) + "%";

  // =========================
  // 상태
  // =========================
  let worker = null;
  let engineReady = false;

  let camStream = null;
  let camReady = false;

  let ttsReady = false;

  let ocrTimer = null;
  let ocrInFlight = false;

  let startTs = Date.now();
  let lastProgressTs = Date.now();

  // 누적(세그먼트)
  let segments = []; // { text, conf, ts }
  let avgConf = 0;
  let lastTextHash = "";

  // 프레임 분석(대략)
  let prevFrameSmall = null;

  // solve lock
  let solveInFlight = false;
  let solvedOnce = false;

  // =========================
  // 유틸
  // =========================
  function nowSec() { return Math.floor((Date.now() - startTs) / 1000); }
  function noSpaceLen(s) { return (s || "").replace(/\s+/g, "").length; }

  function simpleHash(s) {
    let h = 2166136261;
    for (let i=0;i<s.length;i++){
      h ^= s.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return (h >>> 0).toString(16);
  }

  function normalizeOCR(s) {
    return (s || "")
      .replace(/\u00A0/g, " ")
      .replace(/[ \t]+\n/g, "\n")
      .replace(/\n{3,}/g, "\n\n")
      .trim();
  }

  function setEngineStatus(txt, cls) { engineStatus.textContent = txt; engineStatus.className = cls || ""; }
  function setCamStatus(txt, cls) { camStatus.textContent = txt; camStatus.className = cls || ""; }
  function setTTSStatus(txt, cls) { ttsStatus.textContent = txt; ttsStatus.className = cls || ""; }
  function setAutoMsg(txt, cls) { autoMsgEl.textContent = txt; autoMsgEl.className = "pill mono " + (cls || ""); }

  function updateStatsUI() {
    const fullText = segments.map(s => s.text).join("\n\n");
    const lenNS = noSpaceLen(fullText);
    lenNoSpaceEl.textContent = String(lenNS);

    avgConfEl.textContent = (avgConf * 100).toFixed(1) + "%";
    segCountEl.textContent = String(segments.length);

    elapsedEl.textContent = nowSec() + "s";
    const lackSec = Math.floor((Date.now() - lastProgressTs) / 1000);
    lackSecEl.textContent = lackSec + "s";

    ocrTextEl.textContent = fullText || "OCR 누적 텍스트가 여기에 쌓임";
  }

  function canAutoSolve() {
    const fullText = segments.map(s => s.text).join("\n\n");
    const lenNS = noSpaceLen(fullText);
    const lackSec = Math.floor((Date.now() - lastProgressTs) / 1000);

    const okLen = lenNS >= THRESH_LEN_NOSPACE;
    const okConf = avgConf >= THRESH_CONF;
    const okSeg = segments.length >= THRESH_SEGMENTS;
    const forceByIdle = lackSec >= MAX_IDLE_SOLVE_SEC;

    return { okLen, okConf, okSeg, forceByIdle, fullText, lenNS, lackSec };
  }

  // =========================
  // TTS
  // =========================
  function stopSpeech() {
    try { window.speechSynthesis.cancel(); } catch(e){}
  }
  function speak(text) {
    if (!ttsReady) return;
    stopSpeech();
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "ko-KR";
    u.rate = 1.0;
    u.pitch = 1.0;
    u.volume = 1.0;
    window.speechSynthesis.speak(u);
  }

  // =========================
  // OCR 엔진 init (단계/타임아웃 표시)
  // =========================
  async function initOCR() {
    if (engineReady) return;

    const timeout = (ms, label) => new Promise((_, rej) =>
      setTimeout(() => rej(new Error(`TIMEOUT: ${label}`)), ms)
    );

    try {
      setEngineStatus("로딩중…", "warn");

      setAutoMsg("OCR 엔진: 1/4 createWorker…", "warn");
      const pCreate = Tesseract.createWorker({
        workerPath: TESS_CFG.workerPath,
        corePath: TESS_CFG.corePath,
        langPath: TESS_CFG.langPath,
        logger: (m) => { /* console.log(m); */ }
      });
      worker = await Promise.race([pCreate, timeout(25000, "createWorker")]);

      setAutoMsg("OCR 엔진: 2/4 한국어 로드(loadLanguage: kor)…", "warn");
      await Promise.race([worker.loadLanguage(OCR_LANG), timeout(60000, "loadLanguage(kor)")]);

      setAutoMsg("OCR 엔진: 3/4 초기화(initialize: kor)…", "warn");
      await Promise.race([worker.initialize(OCR_LANG), timeout(60000, "initialize(kor)")]);

      setAutoMsg("OCR 엔진: 4/4 파라미터 설정…", "warn");
      await worker.setParameters({
        preserve_interword_spaces: "1",
        user_defined_dpi: "300",
        tessedit_pageseg_mode: "6"
      });

      engineReady = true;
      setEngineStatus("준비됨", "ok");
      setAutoMsg("OCR 엔진 준비됨 ✅ (자동 OCR 시작됨)", "ok");

      maybeStartLoop();
    } catch (e) {
      console.error(e);
      engineReady = false;
      worker = null;
      setEngineStatus("실패", "bad");
      setAutoMsg("OCR 엔진 로딩 실패: " + (e?.message || String(e)), "bad");
    }
  }

  // =========================
  // 카메라
  // =========================
  async function startCamera() {
    setCamStatus("요청중…", "warn");
    try {
      const constraints = {
        audio: false,
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        }
      };
      camStream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = camStream;
      await video.play();

      camReady = true;
      setCamStatus("연결됨", "ok");

      maybeStartLoop();
    } catch (e) {
      console.error(e);
      camReady = false;
      setCamStatus("실패", "bad");
      setAutoMsg("카메라 연결 실패: iOS 설정에서 사이트 카메라 권한을 허용으로 바꾼 뒤 새로고침", "bad");
    }
  }

  function maybeStartLoop() {
    if (!engineReady || !camReady) {
      if (!engineReady) setAutoMsg("OCR 엔진 준비가 필요함 (잠시 기다리거나 새로고침)", "warn");
      if (!camReady) setAutoMsg("카메라 시작 버튼을 눌러야 함", "warn");
      return;
    }
    if (ocrTimer) return;

    startTs = Date.now();
    lastProgressTs = Date.now();
    ocrTimer = setInterval(tickOCR, OCR_INTERVAL_MS);
    setAutoMsg("자동 OCR 진행 중… (지문 충분하면 자동 풀이)", "ok");
  }

  // =========================
  // 프레임 분석(밝기/흔들림 대략)
  // =========================
  function analyzeFrame(imgData, w, h) {
    const data = imgData.data;

    let sum = 0;
    const step = 16;
    for (let i=0; i<data.length; i += 4 * step) {
      const r = data[i], g = data[i+1], b = data[i+2];
      sum += (0.2126*r + 0.7152*g + 0.0722*b);
    }
    const samples = Math.floor(data.length / (4 * step)) || 1;
    const bright = sum / samples;

    const smallW = 64, smallH = 48;
    const small = new Uint8Array(smallW * smallH);
    for (let y=0; y<smallH; y++){
      for (let x=0; x<smallW; x++){
        const sx = Math.floor((x / smallW) * w);
        const sy = Math.floor((y / smallH) * h);
        const idx = (sy * w + sx) * 4;
        const r = data[idx], g = data[idx+1], b = data[idx+2];
        small[y*smallW + x] = (r + g + b) / 3;
      }
    }

    let shake = 0;
    if (prevFrameSmall) {
      let diff = 0;
      for (let i=0; i<small.length; i+=3) diff += Math.abs(small[i] - prevFrameSmall[i]);
      shake = diff / (small.length/3);
    }
    prevFrameSmall = small;

    return { bright, shake };
  }

  // =========================
  // OCR tick
  // =========================
  async function tickOCR() {
    if (!engineReady || !camReady) return;
    if (ocrInFlight) return;
    ocrInFlight = true;

    try {
      const vw = video.videoWidth || 0;
      const vh = video.videoHeight || 0;
      if (!vw || !vh) { ocrInFlight = false; return; }

      // iOS 안정성: 다운스케일
      const targetW = 1400;
      const scale = Math.min(1, targetW / vw);
      const cw = Math.floor(vw * scale);
      const ch = Math.floor(vh * scale);

      canvas.width = cw;
      canvas.height = ch;

      // 미러된 video라서 OCR은 다시 반전 원복
      ctx.save();
      ctx.translate(cw, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(video, 0, 0, cw, ch);
      ctx.restore();

      const imgData = ctx.getImageData(0, 0, cw, ch);
      const { bright, shake } = analyzeFrame(imgData, cw, ch);
      brightnessEl.textContent = bright.toFixed(1);
      shakeEl.textContent = shake.toFixed(1);

      if (bright < 60) setAutoMsg("경고: 어두움 → 조명/각도 조정", "warn");
      else if (shake > 22) setAutoMsg("경고: 흔들림 큼 → 1초 고정", "warn");

      const result = await worker.recognize(canvas);
      const textRaw = result?.data?.text || "";
      const conf = (result?.data?.confidence ?? 0) / 100;

      const text = normalizeOCR(textRaw);
      const h = simpleHash(text);

      if (text.length >= 30 && h !== lastTextHash) {
        lastTextHash = h;

        if (segments.length === 0) {
          segments.push({ text, conf, ts: Date.now() });
          lastProgressTs = Date.now();
        } else {
          const last = segments[segments.length - 1];
          const lastNS = noSpaceLen(last.text);
          const curNS  = noSpaceLen(text);

          const prefixA = last.text.slice(0, 120);
          const prefixB = text.slice(0, 120);
          const samePrefix = prefixA && prefixB && prefixA === prefixB;

          const shouldReplace =
            samePrefix || (Math.abs(curNS - lastNS) < 120 && conf >= last.conf);

          if (shouldReplace) {
            if (curNS >= lastNS || conf >= last.conf) {
              segments[segments.length - 1] = { text, conf, ts: Date.now() };
              lastProgressTs = Date.now();
            }
          } else {
            segments.push({ text, conf, ts: Date.now() });
            lastProgressTs = Date.now();
          }
        }

        avgConf = segments.reduce((a, s) => a + (s.conf || 0), 0) / Math.max(1, segments.length);
      }

      updateStatsUI();

      if (!solveInFlight && !solvedOnce) {
        const st = canAutoSolve();
        if (st.forceByIdle) {
          setAutoMsg(`지문 부족 ${st.lackSec}s 지속 → 지문 부족으로 자동 풀이`, "warn");
          await callSolve(st.fullText, true);
        } else if (st.okLen && st.okConf && st.okSeg) {
          setAutoMsg("조건 충족 ✅ 자동 풀이 호출 중…", "ok");
          await callSolve(st.fullText, false);
        } else {
          const parts = [];
          parts.push(st.okLen ? "길이✅" : "길이❌");
          parts.push(st.okConf ? "신뢰도✅" : "신뢰도❌");
          parts.push(st.okSeg ? "페이지✅" : "페이지❌");
          setAutoMsg("지문 수집 중… (" + parts.join(" / ") + ")", st.okLen ? "ok" : "warn");
        }
      }

    } catch (e) {
      console.error(e);
      setAutoMsg("OCR 오류: " + (e?.message || String(e)), "bad");
    } finally {
      ocrInFlight = false;
    }
  }

  // =========================
  // Solve 호출 (solve.js와 payload 일치: ocrText)
  // =========================
  async function callSolve(text, isFallback) {
    if (!text || noSpaceLen(text) < 200) {
      answerTextEl.textContent = "OCR 텍스트가 너무 짧음";
      return;
    }
    if (solveInFlight) return;
    solveInFlight = true;

    try {
      const head = isFallback ? "지문 부족으로 자동 풀이합니다.\n\n" : "";
      answerTextEl.textContent = head + "풀이 요청 중…";

      const controller = new AbortController();
      const timeoutMs = 55000;
      const t = setTimeout(() => controller.abort(), timeoutMs);

      const payload = {
        ocrText: text.slice(0, 6000) // ✅ 타임아웃 줄이기 위해 6000자 컷
      };

      const res = await fetch(SOLVE_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
        signal: controller.signal
      });

      clearTimeout(t);

      const ct = res.headers.get("content-type") || "";
      let out = "";
      if (ct.includes("application/json")) {
        const j = await res.json();
        out = (j && (j.answer || j.output || j.text)) ? (j.answer || j.output || j.text) : JSON.stringify(j, null, 2);
      } else {
        out = await res.text();
      }

      if (out.includes("Inactivity Timeout")) {
        answerTextEl.textContent = head + "서버 타임아웃(Inactivity Timeout). solve.js를 더 줄여야 함.";
        return;
      }

      const finalOut = (out || "").trim();
      answerTextEl.textContent = head + (finalOut || "No answer(빈 응답). 입력을 더 줄여야 함.");

      solvedOnce = true;

      if (ttsReady && finalOut) {
        speak(finalOut);
      }
    } catch (e) {
      const msg = (e?.name === "AbortError") ? "solve 요청 시간초과(AbortError) → solve.js 더 줄여야 함" : (e?.message || String(e));
      answerTextEl.textContent = "solve 호출 오류: " + msg;
    } finally {
      solveInFlight = false;
    }
  }

  // =========================
  // 버튼
  // =========================
  $("btnCam").addEventListener("click", async () => {
    await startCamera();
    if (!engineReady) await initOCR();
  });

  $("btnAudio").addEventListener("click", () => {
    // iOS unlock
    speak("음성 연결 완료");
    ttsReady = true;
    setTTSStatus("준비됨", "ok");
  });

  $("btnStopSpeech").addEventListener("click", () => stopSpeech());
  $("btnReload").addEventListener("click", () => location.reload());

  $("btnForceSolve").addEventListener("click", async () => {
    const fullText = segments.map(s => s.text).join("\n\n");
    setAutoMsg("수동: 지금까지로 풀이 호출", "warn");
    await callSolve(fullText, true);
  });

  // 시작 상태
  setEngineStatus("대기", "");
  setCamStatus("대기", "");
  setTTSStatus("대기", "");
  setAutoMsg("대기 중… (카메라 시작 버튼 누르기)", "warn");
  updateStatsUI();

  // 엔진 사전 로딩(실패해도 버튼 누르면 다시 시도)
  (async () => { try { await initOCR(); } catch(e) {} })();
  </script>
</body>
</html>

