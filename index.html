<!doctype html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    body {
      font-family: -apple-system, system-ui, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 12px;
      background: #fafafa;
    }
    h1 {
      font-size: 22px;
      margin: 8px 0 12px;
    }
    #log {
      width: 100%;
      height: 140px;
      padding: 8px;
      box-sizing: border-box;
      font-size: 13px;
      font-family: Menlo, Monaco, "SF Mono", monospace;
      white-space: pre-wrap;
    }
    .btn-row {
      display: flex;
      gap: 8px;
      margin: 8px 0;
      flex-wrap: wrap;
    }
    button {
      flex: 1;
      min-width: 120px;
      padding: 10px;
      border-radius: 10px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
    }
    #btn-audio {
      background: #e0f3ff;
    }
    #btn-start {
      background: #ffe1a8;
    }
    #btn-stop {
      background: #ffb3b3;
    }
    #btn-replay {
      background: #ddeeff;
    }
    #instructions {
      font-size: 12px;
      color: #444;
      line-height: 1.5;
      margin-top: 4px;
    }
    #video-container {
      margin-top: 10px;
      text-align: center;
    }
    #video {
      max-width: 100%;
      border-radius: 12px;
      background: #000;
    }
    #snapshot {
      max-width: 100%;
      margin-top: 6px;
      border-radius: 8px;
    }
    #ocr-debug {
      width: 100%;
      height: 140px;
      margin-top: 10px;
      font-size: 11px;
      font-family: Menlo, Monaco, monospace;
      box-sizing: border-box;
    }
    .small {
      font-size: 11px;
      color: #777;
    }
  </style>
</head>
<body>
  <h1>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</h1>

  <textarea id="log" readonly></textarea>

  <div class="btn-row">
    <button id="btn-audio">ğŸ”Š ì˜¤ë””ì˜¤ ì¤€ë¹„(í•œ ë²ˆë§Œ)</button>
    <button id="btn-start">ğŸ“¸ ìë™ ì‹œì‘</button>
  </div>
  <div class="btn-row">
    <button id="btn-stop">â›” ì¤‘ì§€</button>
    <button id="btn-replay">ğŸ” ì •ë‹µ ë‹¤ì‹œ ë“£ê¸°</button>
  </div>

  <div id="instructions">
    <p>- <b>ë§ˆì§€ë§‰ í˜ì´ì§€</b> ì•„ë¬´ ê³³ì— <b>XVRTH</b> ë˜ëŠ” <b>XURTH</b> ë¥¼ êµµê³  í¬ê²Œ ì“°ë©´, ê·¸ í˜ì´ì§€ê¹Œì§€ OCR í›„ ìë™ìœ¼ë¡œ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.</p>
    <p>- iOS ì‚¬ì¼ëŸ°íŠ¸(ë¬´ìŒ) ëª¨ë“œë©´ TTSê°€ ì•ˆ ë“¤ë¦´ ìˆ˜ ìˆë‹¤. <b>ë¬´ìŒ í•´ì œ + ë³¼ë¥¨ ìµœëŒ€ë¡œ</b> ì˜¬ë ¤ë¼.</p>
    <p>- ì‹œí—˜ì§€ëŠ” í™”ë©´ì—ì„œ <b>ê¸€ìê°€ ë˜ë ·í•˜ê²Œ ë³´ì¼ ì •ë„ë¡œ í¬ê²Œ</b> ì¡ê³  ì°ì–´ë¼. (ê°€ëŠ¥í•˜ë©´ ì±…ìƒì— í‰í‰í•˜ê²Œ ë†“ê³ , í°ì€ ìœ„ì—ì„œ ìˆ˜ì§ìœ¼ë¡œ)</p>
  </div>

  <div id="video-container">
    <video id="video" autoplay playsinline></video>
    <img id="snapshot" alt="ë§ˆì§€ë§‰ ì´¬ì˜ í™”ë©´ ë¯¸ë¦¬ë³´ê¸°" />
  </div>

  <div class="small" style="margin-top:8px;">OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸ìš©, ìë™ ìˆ˜ì • ê¸ˆì§€)</div>
  <textarea id="ocr-debug" readonly></textarea>

  <canvas id="canvas" style="display:none;"></canvas>

  <script>
    // ===== ê³µí†µ ìƒíƒœ =====
    const logEl = document.getElementById('log');
    const videoEl = document.getElementById('video');
    const canvasEl = document.getElementById('canvas');
    const snapshotEl = document.getElementById('snapshot');
    const ocrDebugEl = document.getElementById('ocr-debug');

    const btnAudio = document.getElementById('btn-audio');
    const btnStart = document.getElementById('btn-start');
    const btnStop = document.getElementById('btn-stop');
    const btnReplay = document.getElementById('btn-replay');

    let mediaStream = null;
    let audioReady = false;
    let yunaVoice = null;
    let autoRunning = false;

    const MAX_PAGES = 10;                   // ì•ˆì „ìƒ í•œë„
    const MAX_ATTEMPTS_PER_PAGE = 10;       // í˜ì´ì§€ë‹¹ ìµœëŒ€ ì¬ì‹œë„
    const SHOTS_PER_ATTEMPT = 3;            // í•œ ë²ˆ ì‹œë„í•  ë•Œ ëª‡ ìƒ·
    const MIN_LEN_GOOD = 2500;              // "ì¢‹ìŒ" ê¸°ì¤€ ê¸¸ì´
    const MIN_LEN_WEAK = 1200;              // "ì•½í•˜ì§€ë§Œ ì“¸ë§Œí•¨" ê¸°ì¤€
    const MIN_HITS_GOOD = 3;                // ì„ íƒì§€ íˆíŠ¸ ìˆ˜ ê¸°ì¤€
    const STOP_TOKENS = ["XVRTH", "XURTH"];

    // í˜ì´ì§€ë³„ í…ìŠ¤íŠ¸ ë° í’ˆì§ˆ
    const pageData = new Map(); // page -> { text, len, hits, score, isStop }
    let weakPages = [];         // í’ˆì§ˆ ì• ë§¤í•œ í˜ì´ì§€
    let failedPages = [];       // ì™„ì „ ì‹¤íŒ¨í•œ í˜ì´ì§€
    let stopPageIndex = null;

    let lastAnswersText = "";   // ì •ë‹µ TTS ë‹¤ì‹œ ë“£ê¸°ìš©

    // ===== ìœ í‹¸ =====
    function nowStr() {
      const d = new Date();
      const h = String(d.getHours()).padStart(2, "0");
      const m = String(d.getMinutes()).padStart(2, "0");
      const s = String(d.getSeconds()).padStart(2, "0");
      return `${h}ì‹œ ${m}ë¶„ ${s}ì´ˆ`;
    }

    function log(msg) {
      const line = `[${nowStr()}] ${msg}`;
      console.log(line);
      logEl.value = line + "\n" + logEl.value;
    }

    function sleep(ms) {
      return new Promise(res => setTimeout(res, ms));
    }

    // ===== ì˜¤ë””ì˜¤/TTS =====
    function initVoices() {
      const voices = window.speechSynthesis.getVoices() || [];
      yunaVoice = null;
      for (const v of voices) {
        if (v.lang === "ko-KR" && /yuna/i.test(v.name)) {
          yunaVoice = v;
          break;
        }
      }
      if (!yunaVoice) {
        // í•œêµ­ì–´ ì•„ë¬´ê±°ë‚˜
        for (const v of voices) {
          if (v.lang === "ko-KR") {
            yunaVoice = v;
            break;
          }
        }
      }
    }

    function speak(text, opts = {}) {
      try {
        if (!audioReady) return;
        const utter = new SpeechSynthesisUtterance(text);
        utter.lang = "ko-KR";
        utter.rate = opts.rate || 1.0;
        utter.pitch = 1.0;
        utter.volume = 1.0;
        if (!yunaVoice) {
          initVoices();
        }
        if (yunaVoice) utter.voice = yunaVoice;
        window.speechSynthesis.speak(utter);
      } catch (e) {
        console.warn("TTS error", e);
      }
    }

    async function prepareAudio() {
      try {
        if (audioReady) {
          log("ì˜¤ë””ì˜¤ ì¤€ë¹„ëŠ” ì´ë¯¸ ì™„ë£Œë¨.");
          return;
        }
        // iOSìš© AudioContext "ì–¸ë½"
        if (window.AudioContext || window.webkitAudioContext) {
          const AC = window.AudioContext || window.webkitAudioContext;
          const ctx = new AC();
          await ctx.resume();
        }
        window.speechSynthesis.cancel();
        initVoices();
        audioReady = true;
        log("AudioContext ì–¸ë½ ì™„ë£Œ ëŒ€ê¸° ì¤‘");
        speak("ì˜¤ë””ì˜¤ ì¤€ë¹„ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ ìë™ ì‹œì‘ì„ ëˆŒëŸ¬ ì£¼ì„¸ìš”.");
      } catch (e) {
        log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì—ëŸ¬: " + e.message);
      }
    }

    // ===== ì¹´ë©”ë¼ =====
    async function openCamera() {
      if (mediaStream) return;
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: "environment",
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          },
          audio: false
        });
        videoEl.srcObject = mediaStream;
        log("ì¹´ë©”ë¼ OK");
      } catch (e) {
        log("ì¹´ë©”ë¼ ì—´ê¸° ì‹¤íŒ¨: " + e.message);
        throw e;
      }
    }

    function closeCamera() {
      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
        videoEl.srcObject = null;
      }
    }

    function captureFrame() {
      const video = videoEl;
      const canvas = canvasEl;

      const vw = video.videoWidth || 0;
      const vh = video.videoHeight || 0;
      if (!vw || !vh) {
        throw new Error("ë¹„ë””ì˜¤ í”„ë ˆì„ì´ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•ŠìŒ");
      }

      canvas.width = vw;
      canvas.height = vh;
      const ctx = canvas.getContext("2d");
      ctx.drawImage(video, 0, 0, vw, vh);

      const dataUrl = canvas.toDataURL("image/jpeg", 0.9);
      snapshotEl.src = dataUrl;
      return dataUrl;
    }

    // ===== OCR í˜¸ì¶œ =====
    async function callOcr(imageDataUrl, pageIndex, shotIndex) {
      const payload = {
        image: imageDataUrl,
        pageIndex,
        shot: shotIndex
      };
      const resp = await fetch("/.netlify/functions/ocr", {
        method: "POST",
        headers: { "content-type": "application/json" },
        body: JSON.stringify(payload)
      });
      const data = await resp.json().catch(() => ({}));
      return data; // { ok:true, text, conf } or { ok:false, error }
    }

    function includesStopToken(text) {
      const up = String(text || "").toUpperCase();
      return STOP_TOKENS.some(tok => up.includes(tok));
    }

    function estimateQuality(text) {
      const t = String(text || "");
      const len = t.replace(/\s+/g, "").length;

      let hits = 0;
      // â‘ â‘¡â‘¢â‘£â‘¤
      const m1 = t.match(/[â‘ â‘¡â‘¢â‘£â‘¤]/g);
      if (m1) hits += m1.length;
      // " 1) ", "2." ë“±
      const m2 = t.match(/\b[1-5]\s*[\)\.]/g);
      if (m2) hits += m2.length;
      // "(1)" "(2)"
      const m3 = t.match(/\(\s*[1-5]\s*\)/g);
      if (m3) hits += m3.length;

      const score = len / 100 + hits * 5;
      return { len, hits, score };
    }

    // í˜ì´ì§€ í•œ ë²ˆ(ì—¬ëŸ¬ ì‹œë„ í¬í•¨) OCR
    async function captureAndOcrPage(pageIndex, isRetryRound = false) {
      let best = null; // { text, len, hits, score, isStop }
      let accepted = false;
      let isStopPage = false;

      for (let attempt = 1; attempt <= MAX_ATTEMPTS_PER_PAGE; attempt++) {
        if (!autoRunning) return null;

        log(`í˜ì´ì§€ ${pageIndex} OCR ì‹œë„ ${attempt}/${MAX_ATTEMPTS_PER_PAGE}`);

        for (let shot = 1; shot <= SHOTS_PER_ATTEMPT; shot++) {
          if (!autoRunning) return null;

          await sleep(400); // ì† ë–¨ë¦¼ ë°©ì§€ ì•½ê°„ì˜ ë”œë ˆì´
          let image;
          try {
            image = captureFrame();
          } catch (e) {
            log(`í˜ì´ì§€ ${pageIndex} / ìƒ· ${shot} ìº¡ì³ ì‹¤íŒ¨: ${e.message}`);
            continue;
          }

          log(`í˜ì´ì§€ ${pageIndex} / ìƒ· ${shot} ì´¬ì˜`);

          let ocr;
          try {
            ocr = await callOcr(image, pageIndex, shot);
          } catch (e) {
            log(`í˜ì´ì§€ ${pageIndex} / ìƒ· ${shot} OCR ì˜¤ë¥˜: ${e.message}`);
            continue;
          }

          if (!ocr || !ocr.ok) {
            log(`OCR FAIL page=${pageIndex} shot=${shot}: ${ocr?.error || "unknown error"}`);
            continue;
          }

          const text = String(ocr.text || "");
          const { len, hits, score } = estimateQuality(text);
          const hasStop = includesStopToken(text);
          log(`OCR OK page=${pageIndex} shot=${shot} len=${len} hits=${hits} score=${score.toFixed(1)}${hasStop ? " (STOP í›„ë³´)" : ""}`);

          // ë””ë²„ê·¸ í…ìŠ¤íŠ¸ ëˆ„ì 
          ocrDebugEl.value += `\n\n[PAGE ${pageIndex} / shot ${shot}]\n` + text;

          const cur = { text, len, hits, score, isStop: hasStop };
          if (!best || cur.score > best.score) {
            best = cur;
          }

          // STOP í˜ì´ì§€ë§Œ ìˆê³  ë‚´ìš© ê±°ì˜ ì—†ì„ ë•Œ: ë°”ë¡œ ì¸ì •
          if (hasStop && len <= 20) {
            isStopPage = true;
            accepted = true;
            break;
          }
        }

        if (!best) continue;

        if (!accepted && !isStopPage) {
          if (best.len >= MIN_LEN_GOOD && best.hits >= MIN_HITS_GOOD) {
            accepted = true;
          } else {
            log(`í˜ì´ì§€ ${pageIndex} í’ˆì§ˆ ì•½í•¨(len=${best.len}, hits=${best.hits}) â†’ ì¬ì‹œë„`);
          }
        }

        if (accepted) break;
      }

      if (!best) {
        log(`í˜ì´ì§€ ${pageIndex} ì™„ì „ ì‹¤íŒ¨(í…ìŠ¤íŠ¸ ì—†ìŒ).`);
        failedPages.push(pageIndex);
        return { ok: false, isStop: false };
      }

      pageData.set(pageIndex, best);

      if (!accepted && !best.isStop) {
        log(`í˜ì´ì§€ ${pageIndex} OCR í’ˆì§ˆì´ ì•½í•˜ì§€ë§Œ ì¼ë‹¨ ì €ì¥(len=${best.len}, hits=${best.hits}). (weak ëª©ë¡ì— ì¶”ê°€)`);
        if (!weakPages.includes(pageIndex)) weakPages.push(pageIndex);
      } else {
        // ì¢‹ì€ í’ˆì§ˆë¡œ ì¸ì •
        const tag = isRetryRound ? "ì¬ì‹œë„ ì„±ê³µ" : "ì •ìƒ";
        log(`í˜ì´ì§€ ${pageIndex} OCR ${tag}: len=${best.len}, hits=${best.hits}, score=${best.score.toFixed(1)}${best.isStop ? " (STOP í¬í•¨)" : ""}`);
      }

      if (best.isStop) {
        isStopPage = true;
        if (stopPageIndex == null) stopPageIndex = pageIndex;
      }

      return { ok: true, isStop: isStopPage };
    }

    // ===== ì „ì²´ í”Œë¡œìš° =====
    async function runAuto() {
      if (autoRunning) {
        log("ì´ë¯¸ ìë™ ëª¨ë“œê°€ ì‹¤í–‰ ì¤‘ì´ë‹¤.");
        return;
      }

      autoRunning = true;
      weakPages = [];
      failedPages = [];
      pageData.clear();
      stopPageIndex = null;
      lastAnswersText = "";
      ocrDebugEl.value = "";

      log("AUTO START");
      if (!audioReady) {
        await prepareAudio();
      }
      speak("ìë™ ì´¬ì˜ê³¼ ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");

      try {
        await openCamera();
      } catch (e) {
        autoRunning = false;
        speak("ì¹´ë©”ë¼ë¥¼ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„¤ì •ì—ì„œ ê¶Œí•œì„ í™•ì¸í•´ ì£¼ì„¸ìš”.");
        return;
      }

      // 1ì°¨: í˜ì´ì§€ 1ë¶€í„° STOP ë‚˜ì˜¬ ë•Œê¹Œì§€
      for (let page = 1; page <= MAX_PAGES; page++) {
        if (!autoRunning) {
          log("ì‚¬ìš©ìì— ì˜í•´ ì¤‘ì§€ë¨.");
          return;
        }

        const r = await captureAndOcrPage(page, false);
        if (!r) {
          log("ìº¡ì³/ocr ì¤‘ë‹¨.");
          return;
        }

        if (r.isStop) {
          stopPageIndex = page;
          log(`STOP í† í° ê°ì§€ (í˜ì´ì§€ ${page}) â†’ ì´í›„ í˜ì´ì§€ëŠ” ì´¬ì˜ ì•ˆ í•¨.`);
          break;
        } else {
          // ë‹¤ìŒ í˜ì´ì§€ ì•ˆë‚´
          speak(`í˜ì´ì§€ ${page} ì´¬ì˜ì´ ëë‚¬ìŠµë‹ˆë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ í™”ë©´ì— ì˜¬ë ¤ ì£¼ì„¸ìš”.`);
          await sleep(1500);
        }
      }

      if (!autoRunning) return;

      if (stopPageIndex == null) {
        stopPageIndex = pageData.size > 0 ? Math.max(...pageData.keys()) : 0;
        log(`STOP í† í°ì´ ëª…í™•íˆ ì¸ì‹ë˜ì§€ ì•Šì•„, ë§ˆì§€ë§‰ ì´¬ì˜ í˜ì´ì§€(${stopPageIndex})ê¹Œì§€ë§Œ ì‚¬ìš©í•œë‹¤.`);
      }

      // 2ì°¨: weak í˜ì´ì§€ ì¬ì‹œë„
      if (weakPages.length > 0 && autoRunning) {
        log(`í’ˆì§ˆì´ ì• ë§¤í•œ í˜ì´ì§€(weak): ${weakPages.join(", ")} â†’ ì¬ì´¬ì˜ ì‹œë„`);
        // ë²ˆí˜¸ìˆœìœ¼ë¡œ
        weakPages.sort((a, b) => a - b);
        for (const page of weakPages.slice()) {
          if (!autoRunning) return;
          speak(`ì§€ê¸ˆë¶€í„° í˜ì´ì§€ ${page}ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•˜ê² ìŠµë‹ˆë‹¤. í•´ë‹¹ í˜ì´ì§€ë¥¼ í™”ë©´ì— ì˜¬ë ¤ ì£¼ì„¸ìš”.`);
          await sleep(3500);
          const r = await captureAndOcrPage(page, true);
          if (r && r.ok) {
            // ì¬ì‹œë„ í›„ì—ë„ í’ˆì§ˆì´ ë‚˜ì˜ë©´ weakPagesì— ê·¸ëŒ€ë¡œ ë‚¨ê²¨ë‘ê³  ì‚¬ìš©
            // ì„±ê³µ/ì‹¤íŒ¨ ì—¬ë¶€ëŠ” ë¡œê·¸ë¡œë§Œ ì•ˆë‚´
          }
        }
      }

      if (!autoRunning) return;

      // ì „ì²´ í…ìŠ¤íŠ¸ í•©ì¹˜ê¸°
      const orderedPages = Array.from(pageData.keys()).sort((a, b) => a - b);
      let allText = "";
      for (const p of orderedPages) {
        const d = pageData.get(p);
        allText += `\n[PAGE ${p}]\n${d.text}\n`;
      }

      log("ëª¨ë“  í˜ì´ì§€ OCR ì™„ë£Œ â†’ í’€ì´ ì‹œì‘");
      await solveAndSpeak(allText);
    }

    async function solveAndSpeak(allText) {
      try {
        // 1ë‹¨ê³„: íŒŒì‹±
        const parseResp = await fetch("/.netlify/functions/parse-questions", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ text: allText })
        });
        const parseData = await parseResp.json().catch(() => ({}));
        if (!parseData || !parseData.ok) {
          log("ë¬¸í•­ íŒŒì‹± ì‹¤íŒ¨: " + (parseData?.error || "unknown"));
          speak("ë¬¸í•­ì„ ì¸ì‹í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. OCR ê²°ê³¼ë¥¼ ë‹¤ì‹œ í™•ì¸í•´ ì£¼ì„¸ìš”.");
          return;
        }

        const questions = Array.isArray(parseData.questions) ? parseData.questions : [];
        if (!questions.length) {
          log("ë¬¸í•­ íŒŒì‹± ì‹¤íŒ¨: ì§ˆë¬¸ì´ 0ê°œ");
          speak("ë¬¸í•­ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.");
          return;
        }

        log(`ë¬¸í•­ íŒŒì‹± ì„±ê³µ: ${questions.length}ë¬¸í•­`);

        // 2ë‹¨ê³„: ì •ë‹µ ê³„ì‚°
        const solveResp = await fetch("/.netlify/functions/solve", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ questions })
        });
        const solveData = await solveResp.json().catch(() => ({}));

        if (!solveData || !solveData.ok) {
          log("ì •ë‹µ ê³„ì‚° ì‹¤íŒ¨: " + (solveData?.error || "unknown"));
          speak("ì •ë‹µì„ ê³„ì‚°í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
          return;
        }

        const answers = solveData.answers || {};
        const entries = Object.entries(answers)
          .map(([k, v]) => [parseInt(k, 10), parseInt(v, 10)])
          .filter(([q, c]) => Number.isFinite(q) && Number.isFinite(c))
          .sort((a, b) => a[0] - b[0]);

        if (!entries.length) {
          log("ì •ë‹µ ë°ì´í„°ê°€ ë¹„ì–´ ìˆìŒ.");
          speak("ì •ë‹µì„ ë°›ì•˜ì§€ë§Œ ë‚´ìš©ì´ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        const numToLetter = (n) => String.fromCharCode(64 + n); // 1â†’A, 2â†’B...

        let lineForLog = "";
        let lineForTts = "";
        for (const [q, c] of entries) {
          const letter = numToLetter(c);
          lineForLog += `${q}ë²ˆ:${letter} `;
          lineForTts += `${q}ë²ˆ ${letter}, `;
        }

        lastAnswersText = lineForTts;
        log("ì •ë‹µ: " + lineForLog.trim());

        // ìš”ì²­: ì •ë‹µì„ 4íšŒ, ë¬¸í•­ ì‚¬ì´ 2ì´ˆ ê°„ê²©ìœ¼ë¡œ ì½ê¸°
        speakAnswersMultiple(entries, 4);

      } catch (e) {
        log("solveAndSpeak ì—ëŸ¬: " + e.message);
        speak("ì •ë‹µì„ ì²˜ë¦¬í•˜ëŠ” ì¤‘ ì—ëŸ¬ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.");
      }
    }

    function speakAnswersMultiple(entries, repeatCount) {
      const numToLetter = (n) => String.fromCharCode(64 + n);

      // queue ë°©ì‹ìœ¼ë¡œ ìˆœì°¨ ì¬ìƒ
      let round = 0;

      const speakRound = () => {
        if (round >= repeatCount) return;
        round++;

        // í•œ ë¼ìš´ë“œ: 1ë²ˆ A, (2ì´ˆ ì‰¬ê³ ) 2ë²ˆ B, (2ì´ˆ) ...
        let idx = 0;

        const speakNext = () => {
          if (idx >= entries.length) {
            // ë¼ìš´ë“œ ëë‚˜ë©´ ë‹¤ìŒ ë¼ìš´ë“œ ì˜ˆì•½
            setTimeout(speakRound, 1500);
            return;
          }
          const [q, c] = entries[idx++];
          const letter = numToLetter(c);
          speak(`${q}ë²ˆ ${letter}`);
          setTimeout(speakNext, 2000); // ë¬¸í•­ ì‚¬ì´ 2ì´ˆ
        };

        speakNext();
      };

      speakRound();
    }

    function replayAnswers() {
      if (!lastAnswersText) {
        log("ì¬ìƒí•  ì •ë‹µì´ ì—†ìŒ.");
        return;
      }
      const text = lastAnswersText;
      speak("ì´ì „ ì •ë‹µì„ ë‹¤ì‹œ ì½ê² ìŠµë‹ˆë‹¤.");
      setTimeout(() => {
        window.speechSynthesis.cancel();
        speak(text, { rate: 1.0 });
      }, 600);
    }

    // ===== ë²„íŠ¼ ë°”ì¸ë”© =====
    btnAudio.addEventListener("click", () => {
      prepareAudio();
    });

    btnStart.addEventListener("click", () => {
      runAuto().catch(e => {
        log("ìë™ ì‹¤í–‰ ì¤‘ ì—ëŸ¬: " + e.message);
        autoRunning = false;
      });
    });

    btnStop.addEventListener("click", () => {
      if (!autoRunning) {
        log("ì´ë¯¸ ì •ì§€ ìƒíƒœ.");
        return;
      }
      autoRunning = false;
      window.speechSynthesis.cancel();
      closeCamera();
      log("STOP");
    });

    btnReplay.addEventListener("click", replayAnswers);

    // iOSì—ì„œ voice ì´ˆê¸°í™”ë¥¼ ìœ„í•´
    if (typeof window !== "undefined" && window.speechSynthesis) {
      window.speechSynthesis.onvoiceschanged = () => {
        if (!yunaVoice) initVoices();
      };
    }
  </script>
</body>
</html>
