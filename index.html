<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</title>
  <style>
    body { font-family: -apple-system, system-ui, Arial, sans-serif; margin: 16px; }
    h1 { font-size: 22px; margin: 0 0 12px; }
    .box { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 10px 0; }
    #log { width: 100%; height: 150px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; }
    button {
      padding: 12px 14px; border-radius: 12px; border: 1px solid #ddd; background: #fff;
      font-size: 16px; min-width: 150px;
    }
    button:disabled { opacity: .45; }
    video { width: 100%; border-radius: 16px; background: #000; }
    #status { font-weight: 700; }
    #ocrDebug { width: 100%; height: 160px; }
    .hint { color: #444; font-size: 13px; line-height: 1.4; white-space: pre-wrap; }
    .small { font-size: 12px; color:#666; }
  </style>
</head>

<body>
  <h1>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</h1>

  <div class="box">
    <div id="status">ëŒ€ê¸° ì¤‘</div>
    <div class="small">â€» iOSëŠ” â€œì˜¤ë””ì˜¤ ì¤€ë¹„â€ë¥¼ í•œ ë²ˆ ëˆŒëŸ¬ì•¼ TTSê°€ ì•ˆì •ì ìœ¼ë¡œ ë‚˜ì˜¨ë‹¤.</div>
  </div>

  <div class="box">
    <textarea id="log" readonly></textarea>
    <div class="row" style="margin-top:10px;">
      <button id="btnAudio">ğŸ”Š ì˜¤ë””ì˜¤ ì¤€ë¹„(í•œ ë²ˆë§Œ)</button>
      <button id="btnStart" disabled>ğŸ“¸ ìë™ ì‹œì‘</button>
      <button id="btnStop" disabled>â›” ì¤‘ì§€</button>
      <button id="btnReplay" disabled>ğŸ” ì •ë‹µ ë‹¤ì‹œë“£ê¸°</button>
    </div>
  </div>

  <div class="box hint" id="guide">
- ë§ˆì§€ë§‰ í˜ì´ì§€(ë˜ëŠ” ë§ˆì§€ë§‰ ì´¬ì˜ìš© ì¢…ì´)ì— STOP TOKENì„ êµµê³  í¬ê²Œ ì ì–´ë¼. ì˜ˆ: XVRTH
- STOP TOKENì´ OCR í…ìŠ¤íŠ¸ì—ì„œ ê°ì§€ë˜ë©´ ìë™ìœ¼ë¡œ OCRì„ ì¢…ë£Œí•˜ê³  í’€ì´(/solve)ë¥¼ í˜¸ì¶œí•œë‹¤.
- OCRì´ ë¶ˆì•ˆì •í•˜ë©´ ìë™ìœ¼ë¡œ â€œë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”â€ë¼ê³  ë§í•˜ê³  í•´ë‹¹ í˜ì´ì§€ë¥¼ ì¬ì‹œë„í•œë‹¤.
- ì´¬ì˜ íŒ(ì¤‘ìš”):
  1) ì¢…ì´ê°€ í™”ë©´ì„ ìµœëŒ€í•œ ê½‰ ì±„ìš°ê²Œ í•˜ê³ , ë°˜ì‚¬/ê·¸ë¦¼ì ì—†ê²Œ
  2) í”ë“¤ë¦¼ ìµœì†Œ(ì±…ìƒì— íŒ” ê³ ì •)
  3) ê¸€ì”¨ê°€ ì‘ìœ¼ë©´ â€œì¡°ê¸ˆ ë” ê°€ê¹Œì´â€
  </div>

  <div class="box">
    <video id="video" playsinline muted></video>
    <canvas id="canvas" style="display:none;"></canvas>
  </div>

  <div class="box">
    <div style="font-weight:700; margin-bottom:8px;">OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸)</div>
    <textarea id="ocrDebug" readonly placeholder="ìë™ OCR ê²°ê³¼ê°€ ëˆ„ì ëœë‹¤(ìˆ˜ë™ ìˆ˜ì • ê¸ˆì§€)."></textarea>
  </div>

<script>
(() => {
  // ====== ì„¤ì • ======
  const STOP_TOKEN = "XVRTH";         // ë„¤ê°€ ë§ˆì§€ë§‰ í˜ì´ì§€ì— ì ëŠ” ì˜ë¬¸ í† í°(ê¶Œì¥)
  const MAX_PAGES = 30;               // ì•ˆì „ ìƒí•œ
  const SHOTS_PER_PAGE = 3;           // í˜ì´ì§€ë‹¹ 3ìƒ·
  const MAX_PAGE_TRIES = 4;           // í˜ì´ì§€ í’ˆì§ˆ ë‚®ìœ¼ë©´ ì¬ì‹œë„(ìë™)
  const BETWEEN_SHOTS_MS = 450;       // ìƒ· ê°„ ìµœì†Œ ë”œë ˆì´(ë„ˆê°€ ì›í•œ â€œ5ì´ˆ ì œê±°â€)
  const BETWEEN_PAGES_MS = 1400;      // í˜ì´ì§€ ë„˜ê¹€ ì•ˆë‚´ í›„ ì´¬ì˜ê¹Œì§€ ëŒ€ê¸°
  const OCR_TIMEOUT_MS = 25000;       // /ocr ì‘ë‹µ ì œí•œ(í”„ë¡ íŠ¸ ì¸¡)
  const SOLVE_TIMEOUT_MS = 25000;     // /solve ì‘ë‹µ ì œí•œ(í”„ë¡ íŠ¸ ì¸¡)
  const ANSWER_REPEAT = 4;            // ì •ë‹µ 4íšŒ
  const ANSWER_GAP_MS = 2000;         // â€œ1ë²ˆ~ 2ì´ˆ í›„ 2ë²ˆ~â€
  const AFTER_CYCLE_GAP_MS = 2500;    // í•œ ì‚¬ì´í´(1~N) ëë‚˜ê³  ë‹¤ìŒ ì‚¬ì´í´ ì „ ì‰¬ê¸°

  // 2ë‹¨ í¬ë¡­(í•µì‹¬): í™”ë©´ ì „ì²´ì—ì„œ ì¢Œ/ìš° ì»¬ëŸ¼ì„ ìë™ ë¶„ë¦¬
  // ë„ˆë¬´ ë¹¡ë¹¡í•˜ë©´ ê¸€ì ëˆ„ë½ -> ì•½ê°„ ì˜¤ë²„ë©(ê²¹ì¹¨) ì¤€ë‹¤.
  const CROP_OVERLAP = 0.06;          // 6% ê²¹ì¹˜ê¸°
  const TOP_CROP = 0.08;             // ìƒë‹¨ ì—¬ë°± ì¡°ê¸ˆ ì œê±°(ì œëª©/í‘œ ë¨¸ë¦¬ ë“±)
  const BOTTOM_CROP = 0.03;          // í•˜ë‹¨ ì—¬ë°± ì¡°ê¸ˆ ì œê±°

  // ====== DOM ======
  const $log = document.getElementById("log");
  const $status = document.getElementById("status");
  const $video = document.getElementById("video");
  const $canvas = document.getElementById("canvas");
  const $ocrDebug = document.getElementById("ocrDebug");

  const $btnAudio = document.getElementById("btnAudio");
  const $btnStart = document.getElementById("btnStart");
  const $btnStop  = document.getElementById("btnStop");
  const $btnReplay= document.getElementById("btnReplay");

  // ====== ìƒíƒœ ======
  let stream = null;
  let running = false;
  let audioReady = false;

  let pageIndex = 1;
  const pageTexts = [];     // {page, text, score}
  let allText = "";

  let lastAnswers = null;   // {"1":2, ...}

  // ====== ìœ í‹¸ ======
  function now() {
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    const ss = String(d.getSeconds()).padStart(2,"0");
    return `${hh}:${mm}:${ss}`;
  }

  function log(msg) {
    $log.value += `[${now()}] ${msg}\n`;
    $log.scrollTop = $log.scrollHeight;
  }

  function setStatus(s) {
    $status.textContent = s;
  }

  function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

  function withTimeout(promise, ms, label) {
    let t = null;
    const timeout = new Promise((_, rej) => {
      t = setTimeout(() => rej(new Error(label + " timeout")), ms);
    });
    return Promise.race([promise, timeout]).finally(() => clearTimeout(t));
  }

  // ====== ì˜¤ë””ì˜¤(TTS + WebAudio) ======
  let audioCtx = null;
  function beep(freq=880, ms=120) {
    if (!audioCtx) return;
    try {
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "sine";
      o.frequency.value = freq;
      g.gain.value = 0.04;
      o.connect(g); g.connect(audioCtx.destination);
      o.start();
      setTimeout(() => { try { o.stop(); } catch(_){} }, ms);
    } catch(_) {}
  }

  function pickKoreanVoice() {
    const voices = speechSynthesis.getVoices() || [];
    // â€œìœ ë‚˜(ko-KR)â€ ê°™ì€ ë¡œì»¬ ìŒì„±ì´ ìˆìœ¼ë©´ ìš°ì„ 
    let v = voices.find(x => (x.lang || "").toLowerCase().startsWith("ko") && /yuna|ìœ ë‚˜/i.test(x.name));
    if (!v) v = voices.find(x => (x.lang || "").toLowerCase().startsWith("ko"));
    return v || null;
  }

  function speak(text, {rate=1.0}={}) {
    return new Promise((resolve) => {
      if (!audioReady) return resolve(false);
      try {
        speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(String(text));
        u.lang = "ko-KR";
        u.rate = rate;
        u.pitch = 1.0;
        const v = pickKoreanVoice();
        if (v) u.voice = v;
        u.onend = () => resolve(true);
        u.onerror = () => resolve(false);
        speechSynthesis.speak(u);
      } catch(_) {
        resolve(false);
      }
    });
  }

  async function unlockAudio() {
    // iOS: ì‚¬ìš©ì ì œìŠ¤ì²˜ ì•ˆì—ì„œ AudioContext resume + ì§§ì€ TTSë¥¼ ê°™ì´ í•´ì„œ â€œì–¸ë½â€
    try {
      audioCtx = audioCtx || new (window.AudioContext || window.webkitAudioContext)();
      await audioCtx.resume();
      beep(990, 120);
      // voices ë¡œë”© íŠ¸ë¦­
      speechSynthesis.getVoices();
      await sleep(150);
      speechSynthesis.getVoices();
      const v = pickKoreanVoice();
      log(`TTS voice: ${v ? v.name : "ì•Œ ìˆ˜ ì—†ìŒ"} (${v ? v.lang : "?"})`);
      await speak("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ", {rate:1.0});
      audioReady = true;
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ(ë²„íŠ¼)");
      setStatus("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ. ìë™ ì‹œì‘ ê°€ëŠ¥.");
      return true;
    } catch (e) {
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì‹¤íŒ¨: " + (e?.message || e));
      setStatus("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì‹¤íŒ¨. ë¬´ìŒëª¨ë“œ/ë³¼ë¥¨/ê¶Œí•œ í™•ì¸.");
      audioReady = false;
      return false;
    }
  }

  // ====== ì¹´ë©”ë¼ ======
  async function startCamera() {
    if (!navigator.mediaDevices?.getUserMedia) {
      setStatus("ì´ ë¸Œë¼ìš°ì €ëŠ” ì¹´ë©”ë¼ë¥¼ ì§€ì›í•˜ì§€ ì•ŠëŠ”ë‹¤.");
      log("getUserMedia ë¯¸ì§€ì›");
      return false;
    }
    try {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }

      // ì¤Œ ê°•ì œ ì„¤ì • ê¸ˆì§€(ìš”êµ¬ì‚¬í•­)
      const constraints = {
        audio: false,
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        }
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      $video.srcObject = stream;
      $video.setAttribute("playsinline", "");
      await $video.play();

      // ì‹¤ì œ í•´ìƒë„ ë¡œê·¸
      const vw = $video.videoWidth || 0;
      const vh = $video.videoHeight || 0;
      log(`ì¹´ë©”ë¼ OK (${vw}x${vh})`);
      setStatus("ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ. ì¢…ì´ë¥¼ í™”ë©´ì— í¬ê²Œ ë§ì¶°ë¼.");
      return true;
    } catch (e) {
      log("ì¹´ë©”ë¼ ì‹¤íŒ¨: " + (e?.message || e));
      setStatus("ì¹´ë©”ë¼ ê¶Œí•œ/HTTPS/Safari ì„¤ì • í™•ì¸ í•„ìš”.");
      return false;
    }
  }

  // ====== ìº¡ì²˜ + 2ë‹¨ í¬ë¡­ ======
  function captureFrameToDataURL(quality=0.82) {
    const vw = $video.videoWidth;
    const vh = $video.videoHeight;
    if (!vw || !vh) return null;

    $canvas.width = vw;
    $canvas.height = vh;
    const ctx = $canvas.getContext("2d", { alpha:false, willReadFrequently:false });
    ctx.drawImage($video, 0, 0, vw, vh);

    return $canvas.toDataURL("image/jpeg", quality);
  }

  async function makeColumnCrops(dataUrl) {
    // dataUrl -> ì´ë¯¸ì§€ ë¡œë“œ -> ì¢Œ/ìš° ì»¬ëŸ¼ í¬ë¡­ 2ê°œ ë§Œë“¤ì–´ì„œ base64(jpeg) ë°˜í™˜
    const img = await new Promise((resolve, reject) => {
      const im = new Image();
      im.onload = () => resolve(im);
      im.onerror = () => reject(new Error("image load fail"));
      im.src = dataUrl;
    });

    const w = img.naturalWidth;
    const h = img.naturalHeight;

    const top = Math.floor(h * TOP_CROP);
    const bottom = Math.floor(h * (1 - BOTTOM_CROP));
    const ch = Math.max(10, bottom - top);

    const mid = Math.floor(w / 2);
    const ov = Math.floor(w * CROP_OVERLAP);

    const leftX = 0;
    const leftW = clamp(mid + ov, 10, w);

    const rightX = clamp(mid - ov, 0, w-10);
    const rightW = w - rightX;

    function cropToJpeg(x, y, cw, chh) {
      const c = document.createElement("canvas");
      c.width = cw;
      c.height = chh;
      const cx = c.getContext("2d", { alpha:false });
      cx.drawImage(img, x, y, cw, chh, 0, 0, cw, chh);
      return c.toDataURL("image/jpeg", 0.86);
    }

    const left = cropToJpeg(leftX, top, leftW, ch);
    const right = cropToJpeg(rightX, top, rightW, ch);

    return { left, right };
  }

  // ====== OCR í˜¸ì¶œ ======
  async function callOcr(base64Jpeg, meta={}) {
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), OCR_TIMEOUT_MS);

    try {
      const resp = await fetch("/.netlify/functions/ocr", {
        method: "POST",
        headers: { "content-type": "application/json" },
        signal: controller.signal,
        body: JSON.stringify({
          image: base64Jpeg,
          mode: "dual",
          ...meta
        })
      });
      const data = await resp.json().catch(() => ({}));
      return data;
    } finally {
      clearTimeout(t);
    }
  }

  function normalizeText(s) {
    return String(s || "")
      .replace(/\r/g, "\n")
      .replace(/[ \t]+\n/g, "\n")
      .replace(/\n{3,}/g, "\n\n")
      .trim();
  }

  function scoreText(t) {
    // OCR í’ˆì§ˆ íœ´ë¦¬ìŠ¤í‹±: ê¸¸ì´ + â€œë¬¸í•­ ë²ˆí˜¸ í”ì â€ + ë³´ê¸° í”ì 
    const text = String(t || "");
    const len = text.length;

    // ë¬¸í•­ ë²ˆí˜¸(01~50) í”ì 
    const qHits = (text.match(/(^|\n)\s*(0?[1-9]|[1-4][0-9]|50)\b/g) || []).length;
    // ë³´ê¸° í”ì (ë¶ˆë¦¿/ë™ê·¸ë¼ë¯¸ OCR ì”ì¬)
    const optHits = (text.match(/(^|\n)\s*[@â€¢Â®Â©\*^]|(^|\n)\s*[1-5]\)/g) || []).length;

    // ì ìˆ˜: ê¸¸ì´(ìƒí•œ) + ê°€ì¤‘ì¹˜
    const lenScore = Math.min(1.0, len / 2500);  // ëŒ€ì¶© í•œ í˜ì´ì§€ì— 2500ì ì´ìƒì´ë©´ 1
    const qScore = Math.min(1.0, qHits / 10);
    const optScore = Math.min(1.0, optHits / 15);

    // 0~100
    const score = (lenScore * 55) + (qScore * 25) + (optScore * 20);
    return score;
  }

  async function ocrOneShot(page, shot) {
    const raw = captureFrameToDataURL(0.82);
    if (!raw) return { ok:false, text:"", conf:0, score:0 };

    // 2ë‹¨ ìë™ í¬ë¡­(í•µì‹¬)
    const crops = await makeColumnCrops(raw);

    // ì¢Œ -> ìš° ìˆœì„œë¡œ OCR (ë¬¸í•­ ë°°ì¹˜ê°€ 2ë‹¨ì´ë¯€ë¡œ ì´ ìˆœì„œê°€ ì•ˆì •ì )
    const leftRes = await callOcr(crops.left, { pageIndex: page, shot, part: "L" });
    const rightRes = await callOcr(crops.right, { pageIndex: page, shot, part: "R" });

    const leftText = normalizeText(leftRes?.text || "");
    const rightText = normalizeText(rightRes?.text || "");

    const merged = normalizeText(leftText + "\n\n" + rightText);

    const confL = Number(leftRes?.conf || 0);
    const confR = Number(rightRes?.conf || 0);
    const conf = (confL && confR) ? (confL + confR) / 2 : (confL || confR || 0);

    const score = scoreText(merged);

    return {
      ok: Boolean(leftRes?.ok || rightRes?.ok),
      text: merged,
      conf,
      score
    };
  }

  function appendPageText(page, text, score) {
    const header = `[PAGE ${page}] (score=${score.toFixed(1)})\n`;
    allText += header + text + "\n\n";
    $ocrDebug.value = allText.trim();
  }

  // ====== /solve í˜¸ì¶œ ======
  async function callSolve(ocrText) {
    const controller = new AbortController();
    const t = setTimeout(() => controller.abort(), SOLVE_TIMEOUT_MS);

    try {
      const resp = await fetch("/.netlify/functions/solve", {
        method: "POST",
        headers: { "content-type": "application/json" },
        signal: controller.signal,
        body: JSON.stringify({ ocr_text: ocrText })
      });
      const data = await resp.json().catch(() => ({}));
      return data;
    } finally {
      clearTimeout(t);
    }
  }

  function numToLetter(n) {
    const map = {1:"A",2:"B",3:"C",4:"D",5:"E"};
    return map[n] || "?";
  }

  async function speakAnswers(answers) {
    if (!answers || typeof answers !== "object") return;

    // ë¬¸í•­ ë²ˆí˜¸ ì •ë ¬
    const keys = Object.keys(answers).map(k => parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);

    for (let r = 1; r <= ANSWER_REPEAT; r++) {
      log(`ì •ë‹µ ì½ê¸° ì‹œì‘(${r}/${ANSWER_REPEAT})`);
      for (const k of keys) {
        const v = parseInt(answers[String(k)], 10);
        const letter = numToLetter(v);
        await speak(`${k}ë²ˆ ${letter}`, {rate:0.95});
        await sleep(ANSWER_GAP_MS);
      }
      await sleep(AFTER_CYCLE_GAP_MS);
    }
  }

  // ====== ë©”ì¸ ë£¨í”„ ======
  async function runAuto() {
    if (running) return;
    running = true;

    $btnStart.disabled = true;
    $btnStop.disabled = false;
    $btnReplay.disabled = true;

    pageIndex = 1;
    pageTexts.length = 0;
    allText = "";
    $ocrDebug.value = "";

    setStatus("ìë™ OCR ì‹œì‘");

    await speak("ìë™ ì˜¤ì”¨ì•Œì„ ì‹œì‘í•©ë‹ˆë‹¤.", {rate:1.0});

    while (running && pageIndex <= MAX_PAGES) {
      setStatus(`í˜ì´ì§€ ${pageIndex} ì¸ì‹ ì¤‘...`);

      let best = null;

      for (let attempt = 1; attempt <= MAX_PAGE_TRIES && running; attempt++) {
        log(`í˜ì´ì§€ ${pageIndex} OCR ì‹œë„ ${attempt}/${MAX_PAGE_TRIES}`);

        const results = [];
        for (let shot = 1; shot <= SHOTS_PER_PAGE && running; shot++) {
          await sleep(BETWEEN_SHOTS_MS);
          const res = await withTimeout(ocrOneShot(pageIndex, shot), OCR_TIMEOUT_MS + 3000, "ocrOneShot").catch(e => ({ok:false, text:"", conf:0, score:0, _err:e}));
          const len = (res?.text || "").length;
          if (len > 0) {
            log(`OCR OK page=${pageIndex} shot=${shot} len=${len} conf=${Number(res.conf||0).toFixed(1)} score=${Number(res.score||0).toFixed(1)}`);
          } else {
            log(`OCR FAIL page=${pageIndex} shot=${shot} len=0 conf=0 score=0`);
          }
          results.push(res);
        }

        // best pick
        results.sort((a,b) => (b.score||0) - (a.score||0));
        best = results[0] || null;

        const bestLen = (best?.text || "").length;
        const bestScore = Number(best?.score || 0);

        if (bestLen > 200 && bestScore >= 20) break; // í†µê³¼ ê¸°ì¤€(ë„ˆë¬´ ë¹¡ì„¸ë©´ ë£¨í”„ë§Œ ëˆë‹¤)

        // ì‹¤íŒ¨ -> ìë™ ì¬ì´¬ì˜ ì•ˆë‚´
        await speak(`ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ${pageIndex}í˜ì´ì§€ ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”.`, {rate:1.0});
        setStatus(`í˜ì´ì§€ ${pageIndex} ì¬ì‹œë„ ì¤‘...`);
        await sleep(800);
      }

      if (!running) break;

      const text = normalizeText(best?.text || "");
      const score = Number(best?.score || 0);

      // ì™„ì „ ì‹¤íŒ¨ë©´ ì¢…ë£Œ
      if (!text || text.length < 50) {
        await speak(`${pageIndex}í˜ì´ì§€ ì¸ì‹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì¢…ì´ë¥¼ ë” í¬ê²Œ ì¡ê³  ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.`, {rate:1.0});
        setStatus("OCR ì‹¤íŒ¨ë¡œ ì¤‘ì§€");
        running = false;
        break;
      }

      // STOP TOKEN ê°ì§€
      if (text.toUpperCase().includes(STOP_TOKEN)) {
        log(`STOP TOKEN ê°ì§€ (${STOP_TOKEN}) â†’ OCR ì¢…ë£Œ`);
        await speak("ì´¬ì˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.", {rate:1.0});
        running = false;
        break;
      }

      // ì €ì¥
      pageTexts.push({ page: pageIndex, text, score });
      appendPageText(pageIndex, text, score);

      // í˜ì´ì§€ ë„˜ê¹€ ì•ˆë‚´
      await speak(`${pageIndex}í˜ì´ì§€ ì¸ì‹ ì™„ë£Œ. ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ê²¨ ì£¼ì„¸ìš”.`, {rate:1.0});
      await sleep(BETWEEN_PAGES_MS);

      pageIndex++;
    }

    // OCR ì¤‘ì§€ ìƒíƒœë©´(í† í° ê°ì§€ë¡œ ì¢…ë£Œí–ˆê±°ë‚˜ stop) => í’€ì´ í˜¸ì¶œ
    if (pageTexts.length > 0) {
      setStatus("ì •ë‹µ ê³„ì‚° ì‹œì‘(/solve í˜¸ì¶œ)");
      log("ì •ë‹µ ê³„ì‚° ì‹œì‘(/solve í˜¸ì¶œ)");

      const payloadText = pageTexts.map(p => `[PAGE ${p.page}]\n${p.text}`).join("\n\n");

      const solveRes = await withTimeout(callSolve(payloadText), SOLVE_TIMEOUT_MS + 3000, "solve").catch(e => ({ok:false, error:String(e?.message||e)}));

      if (solveRes?.ok && solveRes?.answers) {
        lastAnswers = solveRes.answers;
        log("ì •ë‹µ ìˆ˜ì‹  OK");
        setStatus("ì •ë‹µ ìˆ˜ì‹  ì™„ë£Œ. TTS ì¬ìƒ ì¤‘...");
        $btnReplay.disabled = false;
        await speakAnswers(lastAnswers);
        setStatus("ì™„ë£Œ");
      } else {
        log("ì •ë‹µ ì‹¤íŒ¨: " + (solveRes?.error || "unknown"));
        setStatus("ì •ë‹µ ì‹¤íŒ¨. OCR/íŒŒì‹± ë³´ì™„ í•„ìš”.");
        if (solveRes?.bad_questions?.length) {
          // ìë™ ì•ˆë‚´(ì™„ì „ ìë™ ìœ ì§€)
          await speak(`ì¼ë¶€ ë¬¸í•­ í…ìŠ¤íŠ¸ê°€ ì´ìƒí•©ë‹ˆë‹¤. ${solveRes.bad_questions.slice(0,5).join(", ")}ë²ˆ ë¬¸í•­ì´ ì˜ ì•ˆ ì½í˜”ìŠµë‹ˆë‹¤. ì´¬ì˜ì„ ë” ì„ ëª…í•˜ê²Œ í•´ ì£¼ì„¸ìš”.`, {rate:1.0});
        } else {
          await speak("ì •ë‹µ ê³„ì‚°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì´¬ì˜ í’ˆì§ˆì„ ë†’ì´ê³  ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.", {rate:1.0});
        }
      }
    }

    $btnStart.disabled = false;
    $btnStop.disabled = true;
  }

  function stopAll() {
    running = false;
    setStatus("ì¤‘ì§€");
    log("STOP");
  }

  // ====== ì´ë²¤íŠ¸ ======
  $btnAudio.addEventListener("click", async () => {
    await unlockAudio();
    // ì¹´ë©”ë¼ë„ ê°™ì´ ì¤€ë¹„í•´ë‘ë©´ UX ì¢‹ìŒ
    const camOk = await startCamera();
    $btnStart.disabled = !(audioReady && camOk);
  });

  $btnStart.addEventListener("click", async () => {
    // iOS ì•ˆì „: ì‹œì‘ ë²„íŠ¼ì—ì„œë„ ì˜¤ë””ì˜¤ ì–¸ë½ ì‹œë„(ì‚¬ìš©ì ìš”ì²­ëŒ€ë¡œ â€œë²„íŠ¼ í¬í•¨â€)
    if (!audioReady) await unlockAudio();
    const camOk = await startCamera();
    if (!camOk) return;

    $btnStart.disabled = true;
    $btnAudio.disabled = true;

    log("AUTO START");
    setStatus("ìë™ OCR ì‹¤í–‰ ì¤‘...");
    runAuto();
  });

  $btnStop.addEventListener("click", () => {
    stopAll();
    $btnStart.disabled = false;
    $btnAudio.disabled = false;
    $btnStop.disabled = true;
  });

  $btnReplay.addEventListener("click", async () => {
    if (!audioReady) await unlockAudio();
    if (lastAnswers) {
      await speakAnswers(lastAnswers);
    }
  });

  // iOS voices ë¡œë”©
  window.speechSynthesis?.addEventListener?.("voiceschanged", () => {
    const v = pickKoreanVoice();
    if (v) log(`TTS voice updated: ${v.name} (${v.lang})`);
  });

  // ì´ˆê¸° ìƒíƒœ
  setStatus("ëŒ€ê¸° ì¤‘. ì˜¤ë””ì˜¤ ì¤€ë¹„ ë²„íŠ¼ë¶€í„° ëˆŒëŸ¬ë¼.");
  log("ëŒ€ê¸° ì¤‘");
})();
</script>
</body>
</html>
