<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <title>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui,-apple-system,BlinkMacSystemFont,"Helvetica Neue",sans-serif; margin:0; padding:16px; background:#fafafa;}
    h1 { font-size:22px; margin-bottom:12px;}
    #log { white-space:pre-line; font-size:13px; border:1px solid #ddd; padding:8px; height:120px; overflow:auto; background:#fff;}
    .btn-row { display:flex; gap:8px; margin-top:12px; flex-wrap:wrap;}
    button { padding:10px 14px; border-radius:10px; border:none; font-size:15px; cursor:pointer;}
    #btn-audio { background:#e0f0ff;}
    #btn-start { background:#ffe8b3;}
    #btn-stop { background:#ffb3b3;}
    #btn-replay { background:#e0e0ff;}
    #video-wrap { margin-top:12px; background:#000; border-radius:12px; overflow:hidden; display:flex; justify-content:center;}
    video { width:100%; max-height:60vh; object-fit:contain; background:#000;}
    #ocrText { width:100%; height:120px; margin-top:12px;}
    small { font-size:12px; color:#555;}
  </style>
</head>
<body>
  <h1>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</h1>
  <div id="log"></div>

  <div class="btn-row">
    <button id="btn-audio">ğŸ”Š ì˜¤ë””ì˜¤ ì¤€ë¹„(í•œ ë²ˆë§Œ)</button>
    <button id="btn-start">ğŸ“¸ ìë™ ì‹œì‘</button>
    <button id="btn-stop">â›” ì¤‘ì§€</button>
    <button id="btn-replay" disabled>ğŸ” ì •ë‹µ ë‹¤ì‹œ ë“£ê¸°</button>
  </div>

  <small>
    - ë§ˆì§€ë§‰ í˜ì´ì§€ ì–´ë””ì—ë“  <b>XVRTH</b> ë˜ëŠ” <b>XV RTH</b>ë¥¼ í¬ê²Œ ì“°ë©´, ê·¸ í˜ì´ì§€ OCR í›„ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br>
    - iOS ë¬´ìŒ(ì‚¬ì¼ëŸ°íŠ¸) ëª¨ë“œë©´ TTSê°€ ì•ˆ ë“¤ë¦´ ìˆ˜ ìˆë‹¤. ë¬´ìŒ í•´ì œ + ë³¼ë¥¨ ì˜¬ë ¤ë¼.<br>
    - ì‹œí—˜ì§€ëŠ” ê¸€ìê°€ ë˜ë ·í•˜ê²Œ ë³´ì´ë„ë¡ í™”ë©´ì„ ê±°ì˜ ê½‰ ì±„ìš°ëŠ” ëŠë‚Œìœ¼ë¡œ ê°€ê¹Œì´ ì°ì–´ë¼.
  </small>

  <div id="video-wrap">
    <video id="video" autoplay playsinline></video>
  </div>

  <h3>OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸)</h3>
  <textarea id="ocrText" readonly></textarea>

  <script>
    const logBox = document.getElementById('log');
    const video = document.getElementById('video');
    const ocrTextBox = document.getElementById('ocrText');

    const btnAudio = document.getElementById('btn-audio');
    const btnStart = document.getElementById('btn-start');
    const btnStop  = document.getElementById('btn-stop');
    const btnReplay= document.getElementById('btn-replay');

    let mediaStream = null;
    let running = false;
    let pageIndex = 1;
    let answersForReplay = null;

    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');

    function log(msg) {
      const t = new Date().toTimeString().slice(0,8);
      logBox.textContent = '[' + t + '] ' + msg + '\n' + logBox.textContent;
    }

    // ===== ì˜¤ë””ì˜¤ / TTS =====
    let audioReady = false;
    let ttsVoice = null;

    function initAudio() {
      try {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!AC) {
          log('AudioContext ë¯¸ì§€ì›');
          return;
        }
        const ac = new AC();
        if (ac.state === 'suspended') ac.resume();

        if ('speechSynthesis' in window) {
          const synth = window.speechSynthesis;
          const pick = () => {
            const voices = synth.getVoices();
            ttsVoice = voices.find(v => v.lang === 'ko-KR') || voices[0] || null;
            log('TTS voice: ' + (ttsVoice ? ttsVoice.name + ' (' + ttsVoice.lang + ')' : 'none'));
          };
          pick();
          if (!ttsVoice) synth.onvoiceschanged = pick;
        } else {
          log('SpeechSynthesis ë¯¸ì§€ì›');
        }

        audioReady = true;
        speak('ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ');  // ğŸ”Š ë²„íŠ¼ ëˆ„ë¥´ë©´ ë°”ë¡œ í•œ ë²ˆ ë§í•˜ê²Œ
        log('ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ');
      } catch (e) {
        log('ì˜¤ë””ì˜¤ ì´ˆê¸°í™” ì‹¤íŒ¨: ' + e);
      }
    }

    function speak(text, rate = 1.0, onend) {
      if (!audioReady || !('speechSynthesis' in window)) return;
      const synth = window.speechSynthesis;
      const u = new SpeechSynthesisUtterance(text);
      if (ttsVoice) u.voice = ttsVoice;
      u.lang = 'ko-KR';
      u.rate = rate;
      if (onend) u.onend = onend;
      synth.speak(u);
    }

    btnAudio.addEventListener('click', () => {
      initAudio();
    });

    // ===== ì¹´ë©”ë¼ =====
    async function ensureCamera() {
      if (mediaStream) return;
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: 'environment',
            width:  { ideal: 1280 },   // ğŸ” í•´ìƒë„ â†‘ (ì˜ˆì „ 480x640ì—ì„œ ì—…ê·¸ë ˆì´ë“œ)
            height: { ideal: 720  }
          },
          audio: false
        });
        video.srcObject = mediaStream;
        log('ì¹´ë©”ë¼ OK');
      } catch (e) {
        log('ì¹´ë©”ë¼ ì‹¤íŒ¨: ' + e);
        alert('ì¹´ë©”ë¼ ê¶Œí•œì„ í™•ì¸í•´ë¼ (Safari > ì´ ì‚¬ì´íŠ¸ > ì¹´ë©”ë¼ í—ˆìš©).');
      }
    }

    function captureFrame() {
      if (!video.videoWidth || !video.videoHeight) return null;
      const targetW = 1280;
      const targetH = Math.round(video.videoHeight * (targetW / video.videoWidth));
      canvas.width = targetW;
      canvas.height = targetH;
      ctx.drawImage(video, 0, 0, targetW, targetH);
      return canvas.toDataURL('image/jpeg', 0.9);
    }

    // ===== OCR ë£¨í”„ =====
    async function doOcr(imageDataUrl, page, shot) {
      try {
        const resp = await fetch('/.netlify/functions/ocr', {
          method: 'POST',
          headers: { 'content-type':'application/json' },
          body: JSON.stringify({ image:imageDataUrl, pageIndex:page, shot, mode:'eng' })
        });
        const data = await resp.json();
        if (!data.ok) {
          log('OCR FAIL page=' + page + ' shot=' + shot + ': ' + (data.error || 'unknown'));
        } else {
          log('OCR OK page=' + page + ' shot=' + shot + ' len=' + data.text.length + ' conf=' + data.conf);
        }
        return data;
      } catch (e) {
        log('OCR ìš”ì²­ ì—ëŸ¬ page=' + page + ' shot=' + shot + ': ' + e);
        return { ok:false, error:String(e) };
      }
    }

    async function autoRun() {
      await ensureCamera();
      if (!mediaStream) return;

      running = true;
      btnStart.disabled = true;
      pageIndex = 1;
      answersForReplay = null;
      ocrTextBox.value = '';

      log('AUTO START');

      while (running) {
        log('í˜ì´ì§€ ' + pageIndex + ' OCR ì‹œì‘');
        let best = { score:0, text:'', conf:0, stopToken:false };
        const maxShots = 3;

        for (let shot=1; shot<=maxShots && running; shot++) {
          log('í˜ì´ì§€ ' + pageIndex + ' / ìƒ· ' + shot + ' ì´¬ì˜');
          const frame = captureFrame();
          if (!frame) {
            log('ìº¡ì²˜ ì‹¤íŒ¨ (ë¹„ë””ì˜¤ ì¤€ë¹„ ì•ˆ ë¨)');
            await new Promise(r=>setTimeout(r,800));
            continue;
          }
          const res = await doOcr(frame, pageIndex, shot);
          if (!running) return;

          if (!res.ok) {
            // API í‚¤/ì„œë²„ ë¬¸ì œë©´ ê·¸ëƒ¥ ë°”ë¡œ ì¤‘ë‹¨
            if (res.error && String(res.error).includes('API key')) {
              speak('OCR API í‚¤ ì˜¤ë¥˜. Netlify í™˜ê²½ë³€ìˆ˜ë¥¼ ë‹¤ì‹œ í™•ì¸í•´ë¼.');
              running = false;
              btnStart.disabled = false;
              return;
            }
            continue;
          }

          if (res.stopToken) {
            best.stopToken = true;
            best.text += '\n' + (res.text || '');
            break;
          }

          const score = (res.conf || 0) + (res.text ? res.text.length / 1000 : 0);
          if (score > best.score) {
            best = { score, text:res.text || '', conf:res.conf || 0, stopToken:false };
          }
        }

        if (!running) break;

        // ì´ í˜ì´ì§€ì—ì„œ ì“¸ë§Œí•œ í…ìŠ¤íŠ¸ê°€ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ â†’ ë‹¤ìŒ í˜ì´ì§€ë¡œ ì•ˆ ë„˜ì–´ê°, ë°”ë¡œ ì¢…ë£Œ + ì•ˆë‚´
        if (!best.text || best.score <= 0) {
          log('í˜ì´ì§€ ' + pageIndex + ' OCR ì‹¤íŒ¨: ìœ íš¨í•œ í…ìŠ¤íŠ¸ ì—†ìŒ â†’ ìë™ ì¢…ë£Œ');
          speak('í˜ì´ì§€ ' + pageIndex + ' ê¸€ìê°€ ì „í˜€ ì¸ì‹ë˜ì§€ ì•ŠëŠ”ë‹¤. ë” ê°€ê¹Œì´ì—ì„œ ë‹¤ì‹œ ì°ì–´ë¼.');
          running = false;
          btnStart.disabled = false;
          return;
        }

        ocrTextBox.value += '\n[PAGE ' + pageIndex + ']\n' + best.text + '\n';

        if (best.stopToken || pageIndex >= 5) {
          log('STOP TOKEN ë˜ëŠ” ìµœëŒ€ í˜ì´ì§€ â†’ í’€ì´ë¡œ ì´ë™');
          break;
        }

        pageIndex++;
        await new Promise(r=>setTimeout(r,800));
      }

      running = false;
      btnStart.disabled = false;

      const text = ocrTextBox.value;
      if (!text.trim()) {
        log('ëˆ„ì  OCR í…ìŠ¤íŠ¸ ì—†ìŒ. í’€ì´ ë‹¨ê³„ ìƒëµ.');
        return;
      }
      await solveAndSpeak(text);
    }

    async function solveAndSpeak(fullText) {
      try {
        const resp = await fetch('/.netlify/functions/parse-questions', {
          method: 'POST',
          headers: { 'content-type':'application/json' },
          body: JSON.stringify({ ocrText: fullText })
        });
        const data = await resp.json();
        if (!data.ok) {
          log('ë¬¸í•­ íŒŒì‹± ì‹¤íŒ¨: ' + data.error);
          speak('ë¬¸ì œë¥¼ ì¸ì‹í•˜ì§€ ëª»í–ˆë‹¤. OCR ê²°ê³¼ë¥¼ í™•ì¸í•´ë¼.');
          return;
        }
        const questions = data.questions || [];
        log('ë¬¸í•­ íŒŒì‹± OK: ' + questions.length + 'ë¬¸í•­');

        const solveResp = await fetch('/.netlify/functions/solve', {
          method: 'POST',
          headers: { 'content-type':'application/json' },
          body: JSON.stringify({ questions })
        });
        const solveData = await solveResp.json();
        if (!solveData.ok) {
          log('ì •ë‹µ ê³„ì‚° ì‹¤íŒ¨: ' + solveData.error);
          speak('ì •ë‹µ ê³„ì‚°ì— ì‹¤íŒ¨í–ˆë‹¤.');
          return;
        }

        const ansMap = solveData.answers || {};
        answersForReplay = ansMap;

        const nums = Object.keys(ansMap).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
        let spokenText = '';
        for (const n of nums) {
          const choice = ansMap[String(n)];
          const letter = ['A','B','C','D','E'][choice-1] || '';
          spokenText += n + 'ë²ˆ ' + letter + ', ';
        }
        log('ì •ë‹µ: ' + JSON.stringify(ansMap));
        btnReplay.disabled = false;

        const chunks = chunkTextForTts(spokenText, 40);
        const say = (i) => {
          if (i >= chunks.length) return;
          speak(chunks[i], 0.95, () => say(i+1));
        };
        say(0);
      } catch (e) {
        log('solveAndSpeak ì—ëŸ¬: ' + e);
      }
    }

    function chunkTextForTts(text, maxLen) {
      const out = [];
      let cur = '';
      const parts = text.split(',');
      for (const raw of parts) {
        const p = raw.trim();
        if (!p) continue;
        const add = (cur ? ', ' : '') + p;
        if (cur.length + add.length > maxLen) {
          if (cur) out.push(cur);
          cur = p;
        } else {
          cur += add;
        }
      }
      if (cur) out.push(cur);
      return out;
    }

    btnStart.addEventListener('click', () => {
      if (!running) autoRun();
    });
    btnStop.addEventListener('click', () => {
      running = false;
      log('STOP');
    });
    btnReplay.addEventListener('click', () => {
      if (!answersForReplay) return;
      const nums = Object.keys(answersForReplay).map(n=>parseInt(n,10)).sort((a,b)=>a-b);
      let spoken = '';
      for (const n of nums) {
        const c = answersForReplay[String(n)];
        const letter = ['A','B','C','D','E'][c-1] || '';
        spoken += n + 'ë²ˆ ' + letter + ', ';
      }
      const chunks = chunkTextForTts(spoken, 40);
      const say = (i) => {
        if (i >= chunks.length) return;
        speak(chunks[i], 0.95, () => say(i+1));
      };
      say(0);
    });

    // ì²˜ìŒ ë“¤ì–´ê°€ë©´ ì¹´ë©”ë¼ë§Œ ë¯¸ë¦¬ ì¼œë‘ 
    ensureCamera();
  </script>
</body>
</html>
