<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>answer-site</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: center; }
    button, input, textarea { font-size: 16px; }
    button { padding: 10px 12px; }
    input { padding: 8px 10px; width: 90px; }
    .videoWrap { width: 100%; }
    video { width: 100%; max-height: 70vh; background: #000; border-radius: 10px; }
    img { width: 100%; max-height: 40vh; object-fit: contain; border: 1px solid #ddd; border-radius: 10px; }
    textarea { width: 100%; min-height: 180px; padding: 10px; }
    pre { white-space: pre-wrap; word-break: break-word; background:#0b1020; color:#e8f0ff; padding:12px; border-radius:10px; }
    .col { flex: 1 1 420px; }
    .muted { color:#666; font-size: 13px; }
  </style>
</head>
<body>
  <h2>answer-site (OCR → solve)</h2>

  <div class="row">
    <button id="btnStart">카메라 켜기</button>
    <button id="btnCapture" disabled>촬영 & OCR</button>
    <button id="btnReset">리셋</button>

    <label>page
      <input id="page" type="number" min="1" max="99" value="1" />
    </label>

    <label>jpegQ
      <input id="jpegQ" type="number" min="0.5" max="1" step="0.01" value="0.92" />
    </label>

    <label>자동 다음(초)
      <input id="autoSec" type="number" min="0" max="30" value="10" />
    </label>
  </div>

  <p class="muted">
    - 촬영은 <b>시험지가 화면에 꽉 차게</b>, 흔들림 최소.<br/>
    - 답은 무조건 출력되며, 확신이 낮으면 마지막에 <b>UNSURE</b>로 번호를 모아서 표시한다.
  </p>

  <div class="videoWrap">
    <video id="video" playsinline></video>
  </div>

  <div class="row" style="margin-top:12px;">
    <div class="col">
      <h3>캡처 프리뷰</h3>
      <img id="preview" alt="preview" />
    </div>
    <div class="col">
      <h3>로그</h3>
      <pre id="log"></pre>
    </div>
  </div>

  <div class="row" style="margin-top:12px;">
    <div class="col">
      <h3>OCR 텍스트 (확인/수정 가능)</h3>
      <textarea id="ocrText" placeholder="OCR 결과가 여기 표시됨"></textarea>
      <div class="row" style="margin-top:8px;">
        <button id="btnSolve" disabled>이 OCR로 solve만 실행</button>
      </div>
    </div>

    <div class="col">
      <h3>정답 출력</h3>
      <textarea id="ansText" placeholder="정답이 여기 표시됨"></textarea>
    </div>
  </div>

<script>
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const video = $("video");
  const preview = $("preview");
  const ocrTextEl = $("ocrText");
  const ansTextEl = $("ansText");
  const btnStart = $("btnStart");
  const btnCapture = $("btnCapture");
  const btnSolve = $("btnSolve");
  const btnReset = $("btnReset");
  const pageEl = $("page");
  const jpegQEl = $("jpegQ");
  const autoSecEl = $("autoSec");

  let stream = null;
  let busy = false;
  let countdownTimer = null;

  function log(msg) {
    const now = new Date();
    const hh = String(now.getHours()).padStart(2,"0");
    const mm = String(now.getMinutes()).padStart(2,"0");
    const ss = String(now.getSeconds()).padStart(2,"0");
    logEl.textContent += `[${hh}:${mm}:${ss}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }

  function resetUI() {
    ocrTextEl.value = "";
    ansTextEl.value = "";
    preview.src = "";
    if (countdownTimer) { clearInterval(countdownTimer); countdownTimer = null; }
    busy = false;
    btnCapture.disabled = !stream;
    btnSolve.disabled = true;
  }

  async function startCamera() {
    resetUI();
    if (stream) {
      log("이미 카메라가 켜져 있음");
      return;
    }
    try {
      log("STATUS: 카메라 켜는 중...");
      stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: "environment" },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      log("STATUS: 카메라가 켜졌어. 시험지를 화면에 꽉 차게 맞춰줘.");
      btnCapture.disabled = false;
    } catch (e) {
      log("ERROR: 카메라 접근 실패 - " + (e?.message || e));
    }
  }

  function stopCamera() {
    if (!stream) return;
    for (const t of stream.getTracks()) t.stop();
    stream = null;
    video.srcObject = null;
    btnCapture.disabled = true;
  }

  function dataURLSizeBytes(dataURL) {
    // rough estimate for log
    const b64 = dataURL.split(",")[1] || "";
    return Math.floor(b64.length * 0.75);
  }

  function captureJpegDataURL() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) throw new Error("video not ready");

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);

    const jpegQ = Math.max(0.5, Math.min(1, Number(jpegQEl.value || 0.92)));
    const dataURL = canvas.toDataURL("image/jpeg", jpegQ);
    return { dataURL, w, h, jpegQ, bytes: dataURLSizeBytes(dataURL) };
  }

  async function postJSON(url, body) {
    const res = await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
    const json = await res.json().catch(() => null);
    if (!res.ok || !json) throw new Error(`HTTP ${res.status}: ${JSON.stringify(json)}`);
    return json;
  }

  function startAutoCountdown(sec, fn) {
    if (countdownTimer) clearInterval(countdownTimer);
    if (!sec || sec <= 0) return;

    let left = sec;
    log(`STATUS: ${left}초 후 자동 다음 촬영`);
    countdownTimer = setInterval(() => {
      left -= 1;
      if (left <= 0) {
        clearInterval(countdownTimer);
        countdownTimer = null;
        fn();
      } else {
        log(`STATUS: ${left}...`);
      }
    }, 1000);
  }

  async function runSolve(text, pageNum) {
    log("STATUS: 정답 생성 중...");
    const solve = await postJSON("/.netlify/functions/solve", { text, page: pageNum });
    if (!solve.ok) throw new Error("solve failed: " + JSON.stringify(solve));
    ansTextEl.value = solve.text || "";
    log("solve response " + JSON.stringify(solve).slice(0, 4000));
    return solve;
  }

  async function captureAndRun() {
    if (!stream) return;
    if (busy) return;
    busy = true;
    btnCapture.disabled = true;
    btnSolve.disabled = true;

    try {
      const pageNum = Number(pageEl.value || 1);
      log(`STATUS: 페이지 ${pageNum} 촬영 중... 시험지를 흔들리지 않게 잡고 있어줘.`);

      const shot = captureJpegDataURL();
      preview.src = shot.dataURL;
      log(`capture size ${JSON.stringify({width: shot.w, height: shot.h, jpegQ: shot.jpegQ, length: shot.bytes})}`);

      log("STATUS: OCR 처리 중...");
      const ocr = await postJSON("/.netlify/functions/ocr", { image: shot.dataURL, page: pageNum });
      if (!ocr.ok) throw new Error("ocr failed: " + JSON.stringify(ocr));

      ocrTextEl.value = ocr.text || "";
      btnSolve.disabled = !(ocrTextEl.value || "").trim();
      log("OCR response " + JSON.stringify(ocr).slice(0, 4000));
      log(`STATUS: OCR 완료 (번호 패턴 수: ${ocr.patternCount ?? "?"}).`);

      // solve immediately
      await runSolve(ocrTextEl.value, pageNum);
      log("STATUS: 페이지 정답 생성 완료. XURTH가 보이면 이 페이지는 끝.");

      // auto next
      const sec = Number(autoSecEl.value || 0);
      startAutoCountdown(sec, async () => {
        pageEl.value = String(pageNum + 1);
        await captureAndRun();
      });

    } catch (e) {
      log("ERROR: " + (e?.message || e));
    } finally {
      busy = false;
      btnCapture.disabled = !stream;
    }
  }

  btnStart.addEventListener("click", startCamera);
  btnCapture.addEventListener("click", captureAndRun);
  btnSolve.addEventListener("click", async () => {
    try {
      const pageNum = Number(pageEl.value || 1);
      const text = (ocrTextEl.value || "").trim();
      if (!text) return;
      await runSolve(text, pageNum);
    } catch (e) {
      log("ERROR: " + (e?.message || e));
    }
  });

  btnReset.addEventListener("click", () => {
    resetUI();
    stopCamera();
    log("STATUS: 리셋 완료");
  });

  // init
  log("STATUS: 준비됨. 카메라 켜기를 눌러.");
</script>
</body>
</html>

