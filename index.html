<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>NONSUL Auto OCR + Auto Solve (Stable)</title>

  <!-- Tesseract v4 (ì•ˆì •íŒ) -->
  <script src="https://unpkg.com/tesseract.js@4/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body { margin:0; padding:10px; background:#000; color:#fff; font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif; }
    .wrap { max-width:980px; margin:0 auto; }
    #videoBox { position:relative; width:100%; background:#000; border-radius:12px; overflow:hidden; border:1px solid rgba(0,255,0,0.35); }
    #video { width:100%; height:auto; transform-origin:center center; transform:scale(0.8); } /* í‘œì‹œìš© 0.8 */
    .btnRow { display:flex; gap:10px; flex-wrap:wrap; margin:10px 0; }
    button { padding:10px 12px; border-radius:10px; border:1px solid #444; background:#111; color:#fff; font-size:14px; }
    button:active { transform:scale(0.98); }
    .panel { border:1px solid #333; border-radius:12px; padding:12px; background:#0b0b0b; margin-top:10px; white-space:pre-wrap; line-height:1.35; font-size:14px; }
    .title { font-weight:700; margin-bottom:8px; font-size:15px; }
    pre { margin:0; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace; font-size:12.5px;
          white-space:pre-wrap; word-break:break-word; max-height:360px; overflow:auto; padding:10px; border-radius:10px; background:#000; border:1px solid #222; }
    #answerOut { max-height:520px; font-size:13px; }
  </style>
</head>

<body>
<div class="wrap">
  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <div class="btnRow">
    <button id="btnTTS">ğŸ”Š ìŒì„± ì—°ê²°(í•œ ë²ˆ íƒ­)</button>
    <button id="btnForceSolve">âš¡ ì§€ê¸ˆê¹Œì§€ë¡œ ê°•ì œ í’€ì´</button>
    <button id="btnRestart">ğŸ” OCR ì¬ì‹œì‘(ìƒˆë¡œê³ ì¹¨)</button>
  </div>

  <div class="panel" id="statusPanel">ë¡œë”© ì¤‘...</div>

  <div class="panel">
    <div class="title">ì‹¤ì‹œê°„ OCR(ëˆ„ì )</div>
    <pre id="ocrPreview"></pre>
  </div>

  <div class="panel">
    <div class="title">ë‹µì•ˆ</div>
    <pre id="answerOut"></pre>
  </div>
</div>

<script>
(() => {
  // =========================
  // ì„¤ì •
  // =========================
  const SOLVE_URL = "/.netlify/functions/solve";

  const OCR_INTERVAL_MS = 3000;                      // 3ì´ˆë§ˆë‹¤ OCR ì‹œë„
  const INSUFFICIENT_WARN_MS = 60 * 1000;            // 1ë¶„ ì•ˆë‚´
  const INSUFFICIENT_AUTO_SOLVE_MS = 8 * 60 * 1000;  // 8ë¶„ì´ë©´ ë¶€ì¡±ì´ì–´ë„ ìë™í’€ì´
  const READY_LEN_TARGET = 2400;                     // ê³µë°± ì œì™¸ ëˆ„ì  ê¸¸ì´ ê¸°ì¤€
  const MAX_PREVIEW_CHARS = 16000;                   // í™”ë©´ í‘œì‹œ ìµœëŒ€
  const MAX_SEND_CHARS = 9000;                       // solve ì „ì†¡ ìµœëŒ€(ë’¤ì—ì„œ ìë¦„)

  const OCR_LANG = "kor";

  // âœ… í•µì‹¬: kor ì–¸ì–´íŒŒì¼ CDN 3ê°œë¥¼ ìˆœì„œëŒ€ë¡œ ìë™ ì¬ì‹œë„
  const LANG_PATHS = [
    "https://cdn.jsdelivr.net/npm/@tesseract.js-data/kor/4.0.0_best/",
    "https://unpkg.com/@tesseract.js-data/kor@4.0.0_best/",
    "https://tessdata.projectnaptha.com/4.0.0/"
  ];

  // ìˆ«ì/ê¸°í˜¸ ì œê±°(ìš”ì²­ì‚¬í•­: OCR ê²°ê³¼ì—ì„œ ì œê±°)
  function normalizeText(raw) {
    const s = (raw || "")
      .replace(/\r/g, "")
      .replace(/[0-9]/g, "")                              // ìˆ«ì ì œê±°
      .replace(/[~`^_=+<>\\|]/g, " ")
      .replace(/[â– â–¡â—†â—‡â—â—‹â–²â–³â–¼â–½â€»â˜…â˜†]/g, " ")
      .replace(/[(){}\[\]]/g, " ")
      .replace(/[â€œâ€"']/g, " ")
      .replace(/[â€¢Â·]/g, " ")
      .replace(/[â€”â€“]/g, "-")
      // í•œê¸€/ê¸°ë³¸ë¬¸ì¥ë¶€í˜¸/ê³µë°±/ì¤„ë°”ê¿ˆë§Œ ë‚¨ê¹€
      .replace(/[^\uAC00-\uD7A3\u3131-\u318E\u314F-\u3163\s\.\,\!\?\:\;\-\n]/g, " ")
      .replace(/[ \t]+/g, " ")
      .replace(/\n{3,}/g, "\n\n")
      .trim();

    return s.split("\n").map(x => x.trim()).join("\n").trim();
  }

  function effectiveLen(s) { return (s || "").replace(/\s/g, "").length; }

  // =========================
  // DOM
  // =========================
  const video = document.getElementById("video");
  const statusPanel = document.getElementById("statusPanel");
  const ocrPreview = document.getElementById("ocrPreview");
  const answerOut = document.getElementById("answerOut");
  const btnTTS = document.getElementById("btnTTS");
  const btnForceSolve = document.getElementById("btnForceSolve");
  const btnRestart = document.getElementById("btnRestart");

  // =========================
  // ìƒíƒœ
  // =========================
  let stream = null;

  let worker = null;
  let engineReady = false;
  let engineError = "";
  let ocrBusy = false;

  let segments = []; // {text, conf, sig}
  let avgConf = 0;

  let insufficientSince = null;
  let insufficientWarned = false;
  let solvedOnce = false;

  let ttsUnlocked = false;

  // =========================
  // TTS
  // =========================
  function speak(text) {
    if (!ttsUnlocked) return;
    try {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(String(text || "").slice(0, 2200));
      u.lang = "ko-KR";
      u.rate = 1.02;
      u.pitch = 1.0;
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  btnTTS.addEventListener("click", () => {
    ttsUnlocked = true;
    btnTTS.textContent = "ğŸ”Š ìŒì„± ì—°ê²°ë¨";
    speak("ìŒì„± ì—°ê²° ì™„ë£Œ. ë‹µì•ˆì´ ë‚˜ì˜¤ë©´ ìë™ìœ¼ë¡œ ì½ì–´ì¤ë‹ˆë‹¤.");
  });

  btnRestart.addEventListener("click", () => location.reload());
  btnForceSolve.addEventListener("click", () => triggerSolve(true, "ì‚¬ìš©ì ê°•ì œ í’€ì´", false));

  // =========================
  // ì¹´ë©”ë¼
  // =========================
  async function startCamera() {
    try {
      const constraints = {
        video: { facingMode: { ideal: "environment" }, width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } },
        audio: false
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      setStatus("ì¹´ë©”ë¼ ON\nOCR ì—”ì§„ ë¡œë”© ì¤‘...");
    } catch (e) {
      setStatus("ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: " + String(e && e.message ? e.message : e));
    }
  }

  // =========================
  // OCR ì—”ì§„ ì´ˆê¸°í™” (CDN 3ê°œ ìë™ ì¬ì‹œë„ + íƒ€ì„ì•„ì›ƒ)
  // =========================
  async function initOcrEngine() {
    engineReady = false;
    engineError = "";

    if (worker) {
      try { await worker.terminate(); } catch (e) {}
      worker = null;
    }

    worker = Tesseract.createWorker({
      logger: (m) => {
        if (!m || !m.status) return;
        const st = String(m.status);
        if (st.includes("loading") || st.includes("initializing")) {
          setStatus(buildStatusText("OCR ì—”ì§„ ë¡œë”© ì¤‘...", st));
        }
      }
    });

    // worker.load ìì²´ë„ ë©ˆì¶œ ìˆ˜ ìˆì–´ì„œ íƒ€ì„ì•„ì›ƒ ê±¸ê¸°
    const withTimeout = (p, ms, msg) =>
      Promise.race([p, new Promise((_, rej) => setTimeout(() => rej(new Error(msg)), ms))]);

    try {
      await withTimeout(worker.load(), 25000, "worker.load timeout");

      // âœ… ì–¸ì–´íŒŒì¼ ê²½ë¡œ 3ê°œ ì‹œë„
      let ok = false;
      let lastErr = "";

      for (let i = 0; i < LANG_PATHS.length; i++) {
        const lp = LANG_PATHS[i];
        setStatus(buildStatusText("OCR ì–¸ì–´íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹œë„", `langPath: ${lp}`));

        try {
          await withTimeout(worker.loadLanguage(OCR_LANG, lp), 35000, "loadLanguage timeout");
          await withTimeout(worker.initialize(OCR_LANG), 25000, "initialize timeout");

          // ìˆ«ì/ê¸°í˜¸ ë°©í•´ ì¤„ì´ê¸°(ì™„ë²½ ì°¨ë‹¨ì€ ë¶ˆê°€. + ê²°ê³¼ normalizeë¡œ 2ì°¨ ì œê±°)
          await worker.setParameters({
            tessedit_pageseg_mode: "6",
            preserve_interword_spaces: "1",
            tessedit_char_blacklist: "0123456789@#$%^&*_=+<>|{}[]~`",
          });

          ok = true;
          engineReady = true;
          engineError = "";
          setStatus(buildStatusText("OCR ì—”ì§„ ë¡œë”© ì™„ë£Œ", `ì‚¬ìš© langPath: ${lp}`));
          break;
        } catch (e) {
          lastErr = String(e && e.message ? e.message : e);
          // ë‹¤ìŒ CDNìœ¼ë¡œ ì¬ì‹œë„
          try { await worker.terminate(); } catch (x) {}
          worker = Tesseract.createWorker({ logger: () => {} });
          await withTimeout(worker.load(), 25000, "worker.load timeout(redo)");
        }
      }

      if (!ok) {
        engineReady = false;
        engineError = "ì–¸ì–´íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹¤íŒ¨(ë„¤íŠ¸ì›Œí¬/CDN ì°¨ë‹¨ ê°€ëŠ¥). ì™€ì´íŒŒì´/í•«ìŠ¤íŒŸìœ¼ë¡œ ë³€ê²½ í›„ ìƒˆë¡œê³ ì¹¨ í•„ìš”.\n" + lastErr;
        setStatus(buildStatusText("OCR ì—”ì§„ ë¡œë”© ì‹¤íŒ¨", engineError));
      }

    } catch (e) {
      engineReady = false;
      engineError = String(e && e.message ? e.message : e);
      setStatus(buildStatusText("OCR ì—”ì§„ ë¡œë”© ì‹¤íŒ¨", engineError));
    }
  }

  // =========================
  // í”„ë ˆì„ â†’ ìº”ë²„ìŠ¤(ë‹¤ìš´ìŠ¤ì¼€ì¼ + ëŒ€ë¹„)
  // =========================
  function buildOcrCanvas() {
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    if (!vw || !vh) {
      canvas.width = 640; canvas.height = 360;
      ctx.fillStyle = "black"; ctx.fillRect(0,0,canvas.width,canvas.height);
      return canvas;
    }

    const maxW = 1280;
    const scale = Math.min(1, maxW / vw);
    const outW = Math.floor(vw * scale);
    const outH = Math.floor(vh * scale);
    canvas.width = outW; canvas.height = outH;
    ctx.drawImage(video, 0, 0, outW, outH);

    const img = ctx.getImageData(0, 0, outW, outH);
    const d = img.data;
    const contrast = 1.28;
    const intercept = 128 * (1 - contrast);

    for (let i = 0; i < d.length; i += 4) {
      const r = d[i], g = d[i+1], b = d[i+2];
      let gray = (r*0.299 + g*0.587 + b*0.114);
      gray = gray * contrast + intercept;
      if (gray < 0) gray = 0;
      if (gray > 255) gray = 255;
      d[i] = d[i+1] = d[i+2] = gray;
      d[i+3] = 255;
    }
    ctx.putImageData(img, 0, 0);
    return canvas;
  }

  // =========================
  // ëˆ„ì (ë¹„ìŠ·í•˜ë©´ ë” ì¢‹ì€ ê±¸ë¡œ êµì²´)
  // =========================
  function makeSig(s) {
    return (s || "").replace(/\s+/g, "").slice(0, 600);
  }

  function mergeSegment(text, conf) {
    const sig = makeSig(text);
    let best = -1;

    for (let i=0;i<segments.length;i++){
      const a = segments[i].sig.slice(0, 200);
      const b = sig.slice(0, 200);
      if (a && b && a === b) { best = i; break; }
    }

    if (best >= 0) {
      const old = segments[best];
      const oldLen = effectiveLen(old.text);
      const newLen = effectiveLen(text);
      if (newLen > oldLen || conf > old.conf + 3) {
        segments[best] = { text, conf, sig };
      }
    } else {
      segments.push({ text, conf, sig });
      if (segments.length > 40) segments = segments.slice(-40);
    }

    const sum = segments.reduce((a,s)=>a+(s.conf||0),0);
    avgConf = segments.length ? (sum / segments.length) : 0;
  }

  function getAccumulatedText() {
    const joined = segments.map(s=>s.text).join("\n\n");
    if (joined.length <= 16000) return joined;
    return joined.slice(joined.length - 16000);
  }

  // =========================
  // ì§€ë¬¸ ë¶€ì¡±
  // =========================
  function markInsufficient() {
    const now = Date.now();
    if (!insufficientSince) insufficientSince = now;
  }
  function clearInsufficient() {
    insufficientSince = null;
    insufficientWarned = false;
  }

  // =========================
  // ìƒíƒœ í…ìŠ¤íŠ¸
  // =========================
  function buildStatusText(lastMsg, extra) {
    const acc = getAccumulatedText();
    const accLen = effectiveLen(acc);
    const now = Date.now();
    const dur = insufficientSince ? (now - insufficientSince) : 0;
    const sec = Math.floor(dur / 1000);

    const lines = [];
    lines.push("ìë™ OCR(ëˆ„ì ) â†’ ìë™ í’€ì´");
    lines.push("í”„ë¦¬ë·° ë°°ìœ¨: 0.8 (í‘œì‹œìš©)");
    lines.push("ì„¸ê·¸ë¨¼íŠ¸(í˜ì´ì§€ ì¶”ì •) ìˆ˜: " + segments.length);
    lines.push("ëˆ„ì  OCR ê¸¸ì´(ê³µë°±ì œì™¸): " + accLen + " / ê¸°ì¤€ " + READY_LEN_TARGET);
    lines.push("í‰ê·  OCR ì‹ ë¢°ë„(ëŒ€ëµ): " + (avgConf ? avgConf.toFixed(1) : "0.0") + "%");
    lines.push("ì§€ë¬¸ ë¶€ì¡± ì§€ì†: " + (insufficientSince ? (sec + "ì´ˆ (1ë¶„ ì•ˆë‚´, 8ë¶„ ìë™í’€ì´)") : "0ì´ˆ"));
    lines.push("OCR ì—”ì§„: " + (engineReady ? "ì¤€ë¹„ë¨" : "ë¡œë”©/ë¶ˆì•ˆì •"));
    lines.push("ë§ˆì§€ë§‰ ë©”ì‹œì§€: " + (lastMsg || "-"));
    if (!engineReady && engineError) lines.push("ì—”ì§„ ì—ëŸ¬: " + engineError);
    if (extra) lines.push(String(extra));
    return lines.join("\n");
  }

  function setStatus(txt) { statusPanel.textContent = String(txt || ""); }

  // =========================
  // OCR 1íšŒ
  // =========================
  async function runOcrOnce() {
    if (!engineReady || !worker) return;
    if (ocrBusy) return;

    if (!video.videoWidth || !video.videoHeight) {
      markInsufficient();
      setStatus(buildStatusText("ë¹„ë””ì˜¤ ì¤€ë¹„ ëŒ€ê¸°", ""));
      return;
    }

    ocrBusy = true;
    try {
      setStatus(buildStatusText("OCR ì§„í–‰ ì¤‘...", ""));

      const canvas = buildOcrCanvas();
      const res = await worker.recognize(canvas);

      const conf = (res && res.data && typeof res.data.confidence === "number") ? res.data.confidence : 0;
      const raw = (res && res.data && res.data.text) ? res.data.text : "";

      const cleaned = normalizeText(raw);
      const len = effectiveLen(cleaned);

      if (len < 30) {
        markInsufficient();
        setStatus(buildStatusText("OCR ë„ˆë¬´ ì§§ìŒ(ì§€ë¬¸ ë¶€ì¡±)", `len=${len}, conf=${conf.toFixed(1)}%`));
        return;
      }

      mergeSegment(cleaned, conf);

      const acc = getAccumulatedText();
      const accLen = effectiveLen(acc);
      ocrPreview.textContent = acc;

      if (accLen >= READY_LEN_TARGET) clearInsufficient();
      else markInsufficient();

      if (!solvedOnce) {
        if (accLen >= READY_LEN_TARGET) {
          await triggerSolve(false, "ëˆ„ì  ì§€ë¬¸ì´ ì¶©ë¶„í•´ ìë™ í’€ì´í•©ë‹ˆë‹¤.", false);
        } else {
          const now = Date.now();
          const dur = insufficientSince ? (now - insufficientSince) : 0;

          if (!insufficientWarned && dur >= INSUFFICIENT_WARN_MS) {
            insufficientWarned = true;
            speak("ì§€ë¬¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ì¢…ì´ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë¹„ì¶”ê³  5ì´ˆ ì´ìƒ í”ë“¤ë¦¼ ì—†ì´ ê³ ì •í•´ ì£¼ì„¸ìš”.");
          }

          if (dur >= INSUFFICIENT_AUTO_SOLVE_MS) {
            await triggerSolve(false, "ì§€ë¬¸ ë¶€ì¡±ì´ ì˜¤ë˜ ì§€ì†ë˜ì–´ í˜„ì¬ê¹Œì§€ë¡œ ìë™ í’€ì´í•©ë‹ˆë‹¤.", true);
          }
        }
      }

      setStatus(buildStatusText("OCR ì™„ë£Œ", `len=${len}, conf=${conf.toFixed(1)}%`));
    } catch (e) {
      const msg = String(e && e.message ? e.message : e);
      setStatus(buildStatusText("OCR ì—ëŸ¬ â†’ ì—”ì§„ ì¬ì‹œì‘", msg));

      engineReady = false;
      engineError = msg;

      try {
        if (worker) { try { await worker.terminate(); } catch (x) {} worker = null; }
        await initOcrEngine();
      } catch (x) {}

      markInsufficient();
    } finally {
      ocrBusy = false;
    }
  }

  // =========================
  // solve í˜¸ì¶œ + ë‹µì•ˆ TTS
  // =========================
  async function triggerSolve(force, reason, becauseInsufficient) {
    if (solvedOnce && !force) return;

    const acc = getAccumulatedText();
    let sendText = acc;
    if (sendText.length > MAX_SEND_CHARS) sendText = sendText.slice(sendText.length - MAX_SEND_CHARS);

    const sendLen = effectiveLen(sendText);
    if (!force && sendLen < 80) return;

    solvedOnce = true;
    answerOut.textContent = "í’€ì´ ìƒì„± ì¤‘...\n" + reason;

    try {
      const payload = { mode: "NONSUL", ocr_text: sendText, ocrText: sendText };
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();
      let out = "";

      if (ct.includes("application/json")) {
        const data = await res.json();
        out = (data && data.answer) ? String(data.answer) : JSON.stringify(data);
      } else {
        out = await res.text();
      }

      if (!res.ok) {
        answerOut.textContent = "ì„œë²„ ì—ëŸ¬(" + res.status + ")\n" + out.slice(0, 2000);
        solvedOnce = false;
        return;
      }

      if (becauseInsufficient) out = "â€» ì§€ë¬¸ì´ ë¶€ì¡±í•˜ì—¬ í˜„ì¬ê¹Œì§€ë¡œ ìë™ í’€ì´í•©ë‹ˆë‹¤.\n\n" + out;

      answerOut.textContent = out;
      speak(out);
    } catch (e) {
      answerOut.textContent = "solve í˜¸ì¶œ ì‹¤íŒ¨: " + String(e && e.message ? e.message : e);
      solvedOnce = false;
    }
  }

  // =========================
  // ë¶€íŒ… + ìë™ ë£¨í”„
  // =========================
  async function boot() {
    await startCamera();
    await initOcrEngine();

    setInterval(() => {
      if (!engineReady) {
        setStatus(buildStatusText("OCR ì—”ì§„ ë¡œë”©/ë¶ˆì•ˆì •(ë„¤íŠ¸ì›Œí¬ í™•ì¸)", ""));
        return;
      }
      runOcrOnce();
    }, OCR_INTERVAL_MS);
  }

  boot();
})();
</script>
</body>
</html>
