<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OCR → Solve</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Noto Sans KR", sans-serif; background:#0b0b0d; color:#eaeaf0; }
    .wrap { max-width: 820px; margin: 0 auto; padding: 14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    button { padding:12px 14px; border-radius:14px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06); color:#eaeaf0; font-weight:700; }
    button:active { transform: scale(.99); }
    .card { background: rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.10); border-radius:18px; padding:12px; margin-top:12px; }
    .title { font-size:18px; font-weight:900; margin: 2px 0 10px; }
    video { width: 100%; border-radius:16px; background:#111; }
    textarea { width:100%; min-height: 140px; resize: vertical; border-radius:16px; border:1px solid rgba(255,255,255,.12); background: rgba(0,0,0,.35); color:#eaeaf0; padding:12px; box-sizing:border-box; font-size:14px; line-height:1.5; }
    pre { white-space: pre-wrap; word-break: break-word; margin:0; font-size:14px; line-height:1.55; }
    .muted { opacity:.75; font-size:13px; line-height:1.45; }
    .pill { display:inline-block; padding:8px 10px; border-radius:999px; border:1px solid rgba(255,255,255,.12); background: rgba(255,255,255,.06); font-size:13px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div class="pill" id="ocrBadge">OCR 엔진: 로딩 중…</div>
      <div class="row">
        <button id="btnCam">카메라 시작(필수 1회 탭)</button>
        <button id="btnVoice">음성 연결/테스트(필수 1회 탭)</button>
      </div>
    </div>

    <div class="card">
      <video id="video" playsinline muted autoplay></video>
      <div class="muted" style="margin-top:10px;">
        iOS는 카메라/음성이 “첫 탭”이 필요하다. 위 버튼 2개는 반드시 한 번 눌러라.
      </div>
    </div>

    <div class="card">
      <div class="row">
        <button id="btnReset">OCR 재시작(새로고침)</button>
        <button id="btnSolveNow">지금까지로 풀이</button>
      </div>

      <div class="card" style="margin-top:12px;">
        <div class="title">자동 OCR(누적) → 자동 풀이</div>
        <pre id="status">준비 중…</pre>
      </div>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div class="title">실시간 OCR(누적)</div>
      </div>
      <textarea id="ocrBox" placeholder="OCR 누적 텍스트가 여기에 쌓임" readonly></textarea>
    </div>

    <div class="card">
      <div class="row" style="justify-content:space-between; align-items:center;">
        <div class="title">답안</div>
        <button id="btnStopVoice">음성 중지</button>
      </div>
      <textarea id="ansBox" placeholder="아직 답안 없음" readonly></textarea>
    </div>
  </div>

  <!-- Tesseract.js (CDN 고정) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    // ===== 설정 (안정/퀄리티 우선) =====
    const OCR_LANG = "kor";
    const OCR_INTERVAL_MS = 2500;            // 너무 자주 돌리면 불안정해짐
    const STABLE_HOLD_MS = 900;              // 흔들림 멈춘 뒤 이 시간 지나야 OCR
    const THRESH_LEN = 2400;                 // 공백 제외 길이 기준
    const THRESH_CONF = 65;                  // 평균 신뢰도 대략 기준
    const MAX_INPUT_CHARS = 6500;            // solve로 넘길 최대 길이(너무 길면 타임아웃↑)
    const SOLVE_ENDPOINT = "/.netlify/functions/solve";

    // ===== UI =====
    const video = document.getElementById("video");
    const ocrBadge = document.getElementById("ocrBadge");
    const statusEl = document.getElementById("status");
    const ocrBox = document.getElementById("ocrBox");
    const ansBox = document.getElementById("ansBox");

    const btnCam = document.getElementById("btnCam");
    const btnVoice = document.getElementById("btnVoice");
    const btnReset = document.getElementById("btnReset");
    const btnSolveNow = document.getElementById("btnSolveNow");
    const btnStopVoice = document.getElementById("btnStopVoice");

    // ===== 상태 =====
    let worker = null;
    let ocrReady = false;
    let camReady = false;
    let voiceReady = false;

    let running = false;
    let lastFrameSmall = null;
    let lastStableAt = 0;
    let lastOcrAt = 0;

    let accText = "";
    let accConfSum = 0;
    let accConfCnt = 0;
    let segments = 0;

    let solving = false;

    // ===== 유틸 =====
    function now() { return Date.now(); }
    function noSpaceLen(s) { return (s || "").replace(/\s+/g, "").length; }
    function clampText(s, maxChars) {
      if (!s) return "";
      if (s.length <= maxChars) return s;
      return s.slice(s.length - maxChars);
    }
    function avgConf() {
      if (accConfCnt <= 0) return 0;
      return accConfSum / accConfCnt;
    }
    function safeSetAnswer(text) {
      ansBox.value = (text || "").trim();
    }
    function safeSetOCR(text) {
      ocrBox.value = (text || "").trim();
    }

    // ===== 음성(TTS) =====
    function speak(text) {
      if (!voiceReady) return;
      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "ko-KR";
        u.rate = 1.0;
        u.pitch = 1.0;
        window.speechSynthesis.speak(u);
      } catch {}
    }
    btnStopVoice.addEventListener("click", () => {
      try { window.speechSynthesis.cancel(); } catch {}
    });

    btnVoice.addEventListener("click", () => {
      // iOS: 사용자 제스처로 한 번 재생을 "열어줘야" 함
      voiceReady = true;
      speak("음성 연결 완료");
    });

    // ===== 카메라 =====
    btnCam.addEventListener("click", async () => {
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: "environment" },
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          },
          audio: false
        });
        video.srcObject = stream;
        video.muted = true;
        await video.play();
        camReady = true;
        lastStableAt = now();
      } catch (e) {
        camReady = false;
        alert("카메라 권한/접근 실패: Safari 설정에서 카메라=허용 확인 후 새로고침");
      }
    });

    // ===== OCR 워커 초기화 (tesseract.js v5 호환 + CDN 경로 고정) =====
    async function initOCR() {
      ocrBadge.textContent = "OCR 엔진: 로딩 중…";
      ocrReady = false;

      try {
        const { createWorker } = Tesseract;

        worker = await createWorker({
          logger: () => {},
          workerPath: "https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/worker.min.js",
          corePath: "https://cdn.jsdelivr.net/npm/tesseract.js-core@5/tesseract-core.wasm.js",
          langPath: "https://tessdata.projectnaptha.com/4.0.0"
        });

        // v4/v5 겸용 방어코드
        if (typeof worker.load === "function") await worker.load();
        if (typeof worker.loadLanguage === "function") await worker.loadLanguage(OCR_LANG);
        if (typeof worker.initialize === "function") await worker.initialize(OCR_LANG);
        if (typeof worker.setParameters === "function") {
          await worker.setParameters({
            preserve_interword_spaces: "1"
          });
        }

        ocrReady = true;
        ocrBadge.textContent = "OCR 엔진: 준비됨";
      } catch (e) {
        ocrReady = false;
        ocrBadge.textContent = "OCR 엔진: 로딩/불안정";
        // 화면에 이유라도 남겨서 폰에서도 확인 가능하게
        statusEl.textContent = "OCR 엔진 로딩 실패:\n" + String(e && e.message ? e.message : e);
      }
    }

    // ===== 프레임 캡처 + 간단 전처리(명암/선명도) =====
    const capCanvas = document.createElement("canvas");
    const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

    function captureImageData() {
      const w = video.videoWidth || 0;
      const h = video.videoHeight || 0;
      if (!w || !h) return null;

      // 해상도 1.5배(퀄리티↑, 대신 느려짐)
      capCanvas.width = Math.floor(w * 1.5);
      capCanvas.height = Math.floor(h * 1.5);
      capCtx.drawImage(video, 0, 0, capCanvas.width, capCanvas.height);

      // 그레이스케일 + 약한 임계값(텍스트 대비↑)
      const img = capCtx.getImageData(0, 0, capCanvas.width, capCanvas.height);
      const d = img.data;

      for (let i = 0; i < d.length; i += 4) {
        const r = d[i], g = d[i+1], b = d[i+2];
        let y = (0.299*r + 0.587*g + 0.114*b);
        // 대비 살짝 올리기
        y = (y - 128) * 1.2 + 128;
        // 약한 threshold
        const v = (y > 160) ? 255 : (y < 90 ? 0 : y);
        d[i] = d[i+1] = d[i+2] = v;
        d[i+3] = 255;
      }

      capCtx.putImageData(img, 0, 0);
      return capCanvas;
    }

    // ===== 흔들림(모션) 측정: 작은 프레임 diff =====
    const smallCanvas = document.createElement("canvas");
    const smallCtx = smallCanvas.getContext("2d", { willReadFrequently: true });

    function motionScore() {
      const w = video.videoWidth || 0;
      const h = video.videoHeight || 0;
      if (!w || !h) return 999;

      const sw = 96, sh = 72;
      smallCanvas.width = sw;
      smallCanvas.height = sh;
      smallCtx.drawImage(video, 0, 0, sw, sh);
      const img = smallCtx.getImageData(0, 0, sw, sh).data;

      if (!lastFrameSmall) {
        lastFrameSmall = new Uint8ClampedArray(img);
        return 999;
      }

      let diff = 0;
      for (let i = 0; i < img.length; i += 16) { // 샘플링
        diff += Math.abs(img[i] - lastFrameSmall[i]);
      }
      lastFrameSmall.set(img);
      return diff / (img.length / 16);
    }

    // ===== 누적: 중복 라인 제거(너무 난잡해지는 거 방지) =====
    const seen = new Set();
    function addToAcc(text, conf) {
      if (!text) return;

      const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
      let added = 0;

      for (const line of lines) {
        const key = line.replace(/\s+/g, "");
        if (key.length < 6) continue; // 너무 짧은 쓰레기 제거
        if (seen.has(key)) continue;
        seen.add(key);
        accText += (accText ? "\n" : "") + line;
        added++;
      }

      if (added > 0) segments = Math.min(99, segments + 1);
      if (typeof conf === "number" && conf > 0) {
        accConfSum += conf;
        accConfCnt += 1;
      }
      safeSetOCR(accText);
    }

    // ===== solve 호출 =====
    async function callSolve(reason) {
      if (solving) return;
      solving = true;

      const payloadText = clampText(accText, MAX_INPUT_CHARS);

      safeSetAnswer("풀이 요청 중… (" + reason + ")");

      try {
        const res = await fetch(SOLVE_ENDPOINT, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text: payloadText })
        });

        const ct = res.headers.get("content-type") || "";
        let out = "";
        if (ct.includes("application/json")) {
          const j = await res.json();
          out = (j && j.answer) ? j.answer : JSON.stringify(j);
        } else {
          out = await res.text();
        }

        // HTML(타임아웃 페이지) 그대로 박히는 것 방지
        if (out.includes("<HTML") || out.includes("Inactivity Timeout")) {
          safeSetAnswer("서버 타임아웃(504). 입력이 길거나 모델 응답이 늦음.\n→ OCR 누적을 조금 줄이거나(최대 6500자), OPENROUTER_MODEL을 빠른 모델로 바꿔.");
        } else {
          safeSetAnswer(out.trim() || "No answer (모델 응답 비어있음). 입력을 더 줄여서 다시 시도");
          if (voiceReady && out.trim()) speak(out.trim());
        }
      } catch (e) {
        safeSetAnswer("서버 호출 실패: " + String(e && e.message ? e.message : e));
      } finally {
        solving = false;
      }
    }

    btnSolveNow.addEventListener("click", () => callSolve("수동"));

    // ===== 리셋 =====
    btnReset.addEventListener("click", async () => {
      accText = "";
      accConfSum = 0;
      accConfCnt = 0;
      segments = 0;
      seen.clear();
      safeSetOCR("");
      safeSetAnswer("");
      lastFrameSmall = null;
      lastStableAt = now();
      lastOcrAt = 0;

      try {
        if (worker && typeof worker.terminate === "function") await worker.terminate();
      } catch {}
      worker = null;
      await initOCR();
    });

    // ===== 메인 루프 =====
    async function loop() {
      if (!running) {
        running = true;
        await initOCR();
      }

      const ms = motionScore();
      const t = now();

      if (ms < 6) {
        // 안정
        if (!lastStableAt) lastStableAt = t;
      } else {
        // 흔들림
        lastStableAt = 0;
      }

      const stableFor = lastStableAt ? (t - lastStableAt) : 0;
      const canOcr = camReady && ocrReady && stableFor >= STABLE_HOLD_MS && (t - lastOcrAt >= OCR_INTERVAL_MS);

      const len = noSpaceLen(accText);
      const conf = avgConf();

      statusEl.textContent =
`자동 OCR(누적) → 자동 풀이
누적 길이(공백제외): ${len} / 기준 ${THRESH_LEN}
세그먼트(페이지 추정) 수: ${segments}
평균 OCR 신뢰도(대략): ${conf.toFixed(1)}%
카메라 상태: ${camReady ? "정상" : "미시작(버튼 탭 필요)"}
흔들림 점수: ${ms.toFixed(1)} | 안정 유지: ${Math.floor(stableFor)}ms
OCR 엔진: ${ocrReady ? "준비됨" : "로딩/불안정"}
마지막: ${canOcr ? "OCR 시도" : "대기(1초 고정 필요)"}`;

      if (canOcr) {
        lastOcrAt = t;
        try {
          const canvas = captureImageData();
          if (canvas) {
            const r = await worker.recognize(canvas);
            const text = (r && r.data && r.data.text) ? r.data.text : "";
            const c = (r && r.data && typeof r.data.confidence === "number") ? r.data.confidence : 0;

            addToAcc(text, c);

            const newLen = noSpaceLen(accText);
            const newConf = avgConf();

            // 자동 solve 트리거 (안정/퀄리티 기준 충족)
            if (newLen >= THRESH_LEN && newConf >= THRESH_CONF) {
              await callSolve("자동(충분한 지문)");
            }
          }
        } catch (e) {
          ocrReady = false;
          ocrBadge.textContent = "OCR 엔진: 로딩/불안정";
          statusEl.textContent += "\n\nOCR 에러:\n" + String(e && e.message ? e.message : e);
          // 재시도
          try { if (worker && typeof worker.terminate === "function") await worker.terminate(); } catch {}
          worker = null;
          await initOCR();
        }
      }

      requestAnimationFrame(loop);
    }

    // 시작
    loop();
  </script>
</body>
</html>
