<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>autononsul - OCR/solve</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <style>
    * { box-sizing: border-box; }
    body { margin:0; padding:12px; font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif; background:#0b0b0b; color:#fff; }
    h1 { font-size:16px; margin:0 0 10px; }
    #status { font-size:12px; color:#c4f1ff; white-space:pre-wrap; padding:8px; border:1px solid #333; border-radius:10px; background:#070707; }
    #videoBox { margin-top:10px; border:1px solid #333; border-radius:10px; overflow:hidden; background:#000; }
    video { width:100%; height:auto; display:block; }
    .row { display:flex; gap:8px; margin-top:10px; }
    button { flex:1; padding:10px 12px; font-size:14px; border-radius:10px; border:1px solid #555; background:#151515; color:#fff; }
    button:active { transform: scale(0.98); }
    textarea { width:100%; min-height:140px; margin-top:8px; padding:10px; border-radius:10px; border:1px solid #333; background:#060606; color:#fff; font-size:12px; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; white-space:pre-wrap; }
    .hint { font-size:11px; color:#aaa; margin-top:6px; }
    #errOverlay {
      position:fixed; inset:0; background:rgba(0,0,0,0.92); color:#fff; padding:14px;
      display:none; z-index:9999; overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }
    #errOverlay button { margin-top:10px; width:auto; }
    .smallRow { display:flex; gap:8px; margin-top:8px; align-items:center; }
    select { padding:8px; border-radius:10px; border:1px solid #444; background:#111; color:#fff; }
    label { font-size:12px; color:#bbb; }
  </style>
</head>

<body>
  <div id="errOverlay"></div>

  <h1>ì—°ì„¸ëŒ€ ë…¼ìˆ  ìë™ OCR/í’€ì´</h1>
  <div id="status">í˜ì´ì§€ ë¡œë”©ë¨. ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...</div>

  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <div class="smallRow">
    <span style="font-size:12px;">OCR ëª¨ë“œ: <strong>dual(í•œê¸€+ì˜ì–´ ê³ ì •)</strong></span>
    <span style="margin-left:auto; font-size:12px;">í˜ì´ì§€</span>
    <select id="pageSel"></select>
  </div>

  <div class="row">
    <button id="btnShutter">ğŸ“¸ ì…”í„°(í˜ì´ì§€ 5íšŒ ìë™ ì´¬ì˜)</button>
    <button id="btnSolve">ğŸ“ í’€ê¸°(ìˆ˜ë™)</button>
  </div>

  <div class="hint">
    - ì…”í„° í•œ ë²ˆ ëˆ„ë¥´ë©´ í˜„ì¬ í˜ì´ì§€ë¥¼ 5íšŒ ìë™ ì´¬ì˜ í›„ ê°€ì¥ ì˜ ë‚˜ì˜¨ ê²°ê³¼ë§Œ ì‚¬ìš©í•œë‹¤.<br/>
    - ë§ˆì§€ë§‰ í˜ì´ì§€ì—ì„œ â€œì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤â€ê°€ ì¸ì‹ë˜ë©´ ìë™ìœ¼ë¡œ í’€ì´ë¥¼ ì‹œì‘í•œë‹¤.<br/>
    - ë‹µì•ˆì€ ì›ê³ ì§€ ëª¨ë“œë¡œ ë§¤ìš° ëŠë¦¬ê²Œ ë°˜ë³µ ë‚­ë…ëœë‹¤.
  </div>

  <textarea id="ocrBox" placeholder="OCR ëˆ„ì  í…ìŠ¤íŠ¸"></textarea>
  <textarea id="answerBox" placeholder="AI ë‹µì•ˆ"></textarea>

<script>
(function(){
  "use strict";

  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnShutter = document.getElementById("btnShutter");
  const btnSolve = document.getElementById("btnSolve");
  const ocrBox = document.getElementById("ocrBox");
  const answerBox = document.getElementById("answerBox");
  const errOverlay = document.getElementById("errOverlay");
  const pageSel = document.getElementById("pageSel");

  const OCR_URL = "/.netlify/functions/ocr";
  const SOLVE_URL = "/.netlify/functions/solve";

  const MAX_PAGE = 12;
  let currentPage = 1;

  // ìë™ ì´¬ì˜ ê´€ë ¨
  const SHOTS_PER_PAGE = 5;
  const SHOT_INTERVAL_MS = 5000;
  let isAutoShooting = false;

  // TTS ê´€ë ¨
  let ttsReady = false;
  let ttsVoice = null;
  let answerRepeating = false;
  let lastAnswerRaw = "";
  let wakeLock = null;

  // í˜ì´ì§€ ì„ íƒ ì´ˆê¸°í™”
  for (let i = 1; i <= MAX_PAGE; i++) {
    const opt = document.createElement("option");
    opt.value = String(i);
    opt.textContent = String(i);
    pageSel.appendChild(opt);
  }
  pageSel.value = "1";

  // ì—ëŸ¬ ì˜¤ë²„ë ˆì´
  function showErrorOverlay(title, detail) {
    try {
      errOverlay.style.display = "block";
      errOverlay.textContent = "[ERROR]\n" + (title || "") + "\n\n" + (detail || "") + "\n\n(ì•„ë˜ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ ë‹«í™ë‹ˆë‹¤)";
      const btn = document.createElement("button");
      btn.textContent = "ë‹«ê¸°";
      btn.onclick = function () {
        errOverlay.style.display = "none";
        errOverlay.innerHTML = "";
      };
      errOverlay.appendChild(document.createElement("br"));
      errOverlay.appendChild(btn);
    } catch (e) {}
  }

  window.addEventListener("error", function (e) {
    showErrorOverlay(e.message || "Unknown JS error", (e.error && e.error.stack) ? e.error.stack : "");
  });

  window.addEventListener("unhandledrejection", function (e) {
    const msg = e && e.reason ? (e.reason.message || String(e.reason)) : "unhandled rejection";
    const stack = e && e.reason && e.reason.stack ? e.reason.stack : "";
    showErrorOverlay(msg, stack);
  });

  // ---- TTS ê¸°ë³¸ ----
  function loadVoices() {
    try {
      const voices = window.speechSynthesis ? window.speechSynthesis.getVoices() : [];
      if (voices && voices.length) {
        const koVoices = voices.filter(v => v.lang && v.lang.toLowerCase().startsWith("ko"));
        if (koVoices.length) {
          ttsVoice = koVoices[0];
        } else {
          ttsVoice = voices[0];
        }
      }
    } catch (e) {}
  }

  if (window.speechSynthesis) {
    loadVoices();
    window.speechSynthesis.onvoiceschanged = loadVoices;
  }

  function toWongojiSpeech(text) {
    let t = String(text || "");
    t = t.replace(/\r/g, "");
    t = t.replace(/\n+/g, " ì¤„ë°”ê¿ˆ ");
    t = t.replace(/ /g, " ë„ìš°ê³  ");
    t = t.replace(/\./g, " ë§ˆì¹¨í‘œ ");
    t = t.replace(/,/g, " ì‰¼í‘œ ");
    t = t.replace(/!/g, " ëŠë‚Œí‘œ ");
    t = t.replace(/\?/g, " ë¬¼ìŒí‘œ ");
    t = t.replace(/\[/g, " ëŒ€ê´„í˜¸ ì—¬ëŠ” ê´„í˜¸ ");
    t = t.replace(/\]/g, " ëŒ€ê´„í˜¸ ë‹«ëŠ” ê´„í˜¸ ");
    t = t.replace(/\(/g, " ì†Œê´„í˜¸ ì—¬ëŠ” ê´„í˜¸ ");
    t = t.replace(/\)/g, " ì†Œê´„í˜¸ ë‹«ëŠ” ê´„í˜¸ ");
    t = t.replace(/%/g, " í¼ì„¼íŠ¸ ");
    t = t.replace(/:/g, " ì½œë¡  ");
    t = t.replace(/;/g, " ì„¸ë¯¸ì½œë¡  ");
    t = t.replace(/\"/g, " í°ë”°ì˜´í‘œ ");
    t = t.replace(/'/g, " ì‘ì€ë”°ì˜´í‘œ ");
    return t;
  }

  function speakInternal(text, options) {
    if (!window.speechSynthesis) return;
    const opts = options || {};
    const rate = typeof opts.rate === "number" ? opts.rate : 0.9;
    const wongoji = !!opts.wongoji;
    const onend = typeof opts.onend === "function" ? opts.onend : null;
    const skipCancel = !!opts.skipCancel;

    try {
      const content = wongoji ? toWongojiSpeech(text) : String(text || "");
      if (!content.trim()) return;

      if (!skipCancel) {
        window.speechSynthesis.cancel();
      }

      const u = new SpeechSynthesisUtterance(content);
      u.lang = "ko-KR";
      u.rate = rate;
      u.pitch = 1.0;
      if (ttsVoice) u.voice = ttsVoice;

      u.onend = function () {
        if (onend) onend();
      };
      u.onerror = function () {
        if (onend) onend();
      };

      window.speechSynthesis.speak(u);
    } catch (e) {
      // silent
    }
  }

  function primeTTS() {
    if (ttsReady) return;
    ttsReady = true;
    if (!window.speechSynthesis) return;
    // ì§§ì€ í”„ë¼ì„ ìŒì„±
    speakInternal("ìŒì„± ì¤€ë¹„ ì™„ë£Œ", { rate: 1.0, wongoji: false });
    window.speechSynthesis.cancel();
  }

  function speakStatus(text) {
    if (!ttsReady) return;
    if (answerRepeating) {
      // ë‹µì•ˆ ë‚­ë… ì¤‘ì—ëŠ” ìƒíƒœ ìŒì„±ì€ ìƒëµ(í™”ë©´ í…ìŠ¤íŠ¸ë§Œ ì‚¬ìš©)
      return;
    }
    speakInternal(text, { rate: 0.95, wongoji: false });
  }

  function speakAnswer(text, isRevision) {
    if (!ttsReady) return;
    answerRepeating = true;

    const playOnce = function () {
      speakInternal(text, {
        rate: 0.45, // ë§¤ìš° ëŠë¦¬ê²Œ
        wongoji: true,
        onend: function () {
          if (answerRepeating) {
            setTimeout(playOnce, 1000);
          }
        }
      });
    };

    if (isRevision) {
      speakInternal("ì´ì „ ë‹µì•ˆì„ ìˆ˜ì •í•˜ê² ìŠµë‹ˆë‹¤. ë” ë‚˜ì€ ìµœì¢… ë‹µì•ˆì„ ì½ì–´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.", {
        rate: 0.9,
        wongoji: false,
        onend: function () {
          setTimeout(playOnce, 500);
        }
      });
    } else {
      playOnce();
    }
  }

  function stopAnswerRepeat() {
    answerRepeating = false;
    if (window.speechSynthesis) {
      window.speechSynthesis.cancel();
    }
  }

  // ì²« íƒ­ì—ì„œ TTS + í™”ë©´ ê¹¨ìš°ê¸° ë‘˜ ë‹¤ ìš”ì²­
  document.addEventListener("click", function () {
    primeTTS();
    requestWakeLock();
  }, { once: true });

  // ---- Screen Wake Lock ----
  async function requestWakeLock() {
    if (!("wakeLock" in navigator) || !navigator.wakeLock || !navigator.wakeLock.request) {
      return;
    }
    try {
      wakeLock = await navigator.wakeLock.request("screen");
      if (wakeLock && wakeLock.addEventListener) {
        wakeLock.addEventListener("release", function () {
          // í•„ìš” ì‹œ ìƒíƒœ í‘œì‹œ ê°€ëŠ¥
        });
      }
    } catch (e) {
      console.log("wakeLock error", e);
    }
  }

  // ---- ì¹´ë©”ë¼ ----
  let stream = null;

  async function startCamera() {
    try {
      statusEl.textContent = "ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­ ì¤‘...";
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 2560 },
          height: { ideal: 1440 }
        },
        audio: false
      });
      video.srcObject = stream;
      statusEl.textContent = "ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ. ì…”í„°ë¥¼ ëˆ„ë¥´ë©´ 5íšŒ ìë™ ì´¬ì˜í•©ë‹ˆë‹¤.";
    } catch (e) {
      statusEl.textContent = "ì¹´ë©”ë¼ ì‹¤íŒ¨: " + (e.message || String(e));
      showErrorOverlay("ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨", String(e && e.message ? e.message : e));
    }
  }

  function captureDataUrl() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) return null;

    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);
    return canvas.toDataURL("image/jpeg", 0.9);
  }

  // ê³µí†µ OCR í˜¸ì¶œ
  async function callOCR(dataUrl, pageIndex) {
    if (!dataUrl) {
      return { ok:false, error:"NO_FRAME" };
    }
    try {
      const res = await fetch(OCR_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          imageBase64: dataUrl,
          pageIndex: pageIndex,
          mode: "dual" // í•­ìƒ í•œê¸€+ì˜ì–´
        })
      });
      const json = await res.json().catch(function(){ return null; });
      return json || { ok:false, error:"NO_JSON" };
    } catch (e) {
      return { ok:false, error:"FETCH_ERROR", message: e && e.message ? e.message : String(e) };
    }
  }

  function sleep(ms) {
    return new Promise(function(resolve){ setTimeout(resolve, ms); });
  }

  // í˜ì´ì§€ ë‹¨ìœ„ 5íšŒ ìë™ ì´¬ì˜
  async function runPageAutoShot() {
    if (isAutoShooting) {
      return;
    }
    isAutoShooting = true;
    stopAnswerRepeat(); // ë‹µì•ˆ ì½ëŠ” ì¤‘ì´ë©´ ì •ì§€

    const page = Number(pageSel.value || currentPage || 1);
    currentPage = page;

    statusEl.textContent = "í˜ì´ì§€ " + page + " ìë™ ì´¬ì˜ ì‹œì‘ (ì´ " + SHOTS_PER_PAGE + "íšŒ)...";

    let bestText = "";
    let bestConf = -1;
    let foundSolveCue = false;

    for (let i = 1; i <= SHOTS_PER_PAGE; i++) {
      statusEl.textContent = "í˜ì´ì§€ " + page + " ì´¬ì˜ " + i + " / " + SHOTS_PER_PAGE + " ì§„í–‰ ì¤‘...";

      const dataUrl = captureDataUrl();
      if (!dataUrl) {
        statusEl.textContent = "ì˜ìƒ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤. 1~2ì´ˆ í›„ ìë™ ì¬ì‹œë„...";
        await sleep(SHOT_INTERVAL_MS);
        continue;
      }

      const res = await callOCR(dataUrl, page);

      if (res && res.ok && res.text && String(res.text).trim()) {
        const txt = String(res.text);
        const conf = typeof res.conf === "number" ? res.conf : 0;

        if (conf > bestConf) {
          bestConf = conf;
          bestText = txt;
        }

        if (/ì´ì œ\s*í’€ì´ë¥¼\s*ì‹œì‘í•˜ì‹œì˜¤/.test(txt)) {
          foundSolveCue = true;
        }

        statusEl.textContent = "í˜ì´ì§€ " + page + " ì´¬ì˜ " + i + " / " + SHOTS_PER_PAGE + " ì™„ë£Œ (ì‹ ë¢°ë„ ëŒ€ëµ " + (conf.toFixed ? conf.toFixed(1) : conf) + "%)";
      } else {
        const msg = res && (res.message || res.error) ? (res.message || res.error) : "OCR ì‹¤íŒ¨";
        statusEl.textContent = "í˜ì´ì§€ " + page + " ì´¬ì˜ " + i + " / " + SHOTS_PER_PAGE + " ì‹¤íŒ¨: " + msg;
      }

      if (i < SHOTS_PER_PAGE) {
        await sleep(SHOT_INTERVAL_MS);
      }
    }

    if (!bestText || !bestText.trim()) {
      statusEl.textContent = "í˜ì´ì§€ " + page + "ì—ì„œ ìœ íš¨í•œ OCR ê²°ê³¼ë¥¼ ì–»ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.";
    } else {
      const block = "\n\n[í˜ì´ì§€ " + page + "]-------------------\n" + bestText;
      ocrBox.value = (ocrBox.value || "") + block;
      statusEl.textContent = "í˜ì´ì§€ " + page + " OCR ì™„ë£Œ (ìµœê³  ì‹ ë¢°ë„ ëŒ€ëµ " + (bestConf >= 0 && bestConf.toFixed ? bestConf.toFixed(1) : "0.0") + "%)";
    }

    // ë‹¤ìŒ í˜ì´ì§€ ì•ˆë‚´ ì¹´ìš´íŠ¸ë‹¤ìš´
    speakStatus("5 4 3 2 1. ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ê²¨ ì£¼ì„¸ìš”.");

    // í˜ì´ì§€ ë²ˆí˜¸ ì¦ê°€
    if (currentPage < MAX_PAGE) {
      currentPage++;
      pageSel.value = String(currentPage);
    }

    isAutoShooting = false;

    // ë§ˆì§€ë§‰ í˜ì´ì§€ë¡œ íŒë‹¨ë˜ë©´ ìë™ í’€ì´
    if (foundSolveCue && bestText && bestText.trim()) {
      statusEl.textContent += "\në§ˆì§€ë§‰ í˜ì´ì§€ë¡œ ì¸ì‹ë˜ì–´ ìë™ìœ¼ë¡œ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.";
      await doSolve(true);
    }
  }

  // solve í˜¸ì¶œ
  async function doSolve(isAuto) {
    primeTTS();

    const text = (ocrBox.value || "").trim();
    if (!text) {
      statusEl.textContent = "ë¨¼ì € ì…”í„°ë¡œ OCRì„ ìŒ“ì•„ì£¼ì„¸ìš”.";
      speakStatus("ë¨¼ì € ì˜¤ì”¨ì•Œì„ ì§„í–‰í•˜ì„¸ìš”.");
      return;
    }

    statusEl.textContent = isAuto ? "ìë™ìœ¼ë¡œ AI í’€ì´ë¥¼ ìš”ì²­ ì¤‘..." : "AI í’€ì´ ìš”ì²­ ì¤‘...";
    try {
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          text: text,
          targetChars: 1000,
          tolerance: 120
        })
      });

      const json = await res.json().catch(function(){ return null; });
      if (!json || !json.ok) {
        const msg = json && (json.message || json.error) ? (json.message || json.error) : "solve ì‹¤íŒ¨";
        statusEl.textContent = "í’€ì´ ì‹¤íŒ¨: " + msg;
        speakStatus("í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        return;
      }

      const answer = (json.answer || "").trim();
      if (!answer) {
        statusEl.textContent = "í’€ì´ ê²°ê³¼ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.";
        speakStatus("í’€ì´ ê²°ê³¼ê°€ ë¹„ì–´ ìˆìŠµë‹ˆë‹¤.");
        return;
      }

      const isRevision = !!lastAnswerRaw && lastAnswerRaw !== answer;
      lastAnswerRaw = answer;

      answerBox.value = answer;
      statusEl.textContent = "í’€ì´ ì™„ë£Œ. (ì›ê³ ì§€ ëª¨ë“œë¡œ ë§¤ìš° ëŠë¦¬ê²Œ ë°˜ë³µ ë‚­ë… ì¤‘)";

      speakAnswer(answer, isRevision);
    } catch (e) {
      statusEl.textContent = "í’€ì´ ìš”ì²­ ì‹¤íŒ¨: " + (e.message || String(e));
      showErrorOverlay("solve ìš”ì²­ ì‹¤íŒ¨", String(e && e.stack ? e.stack : e));
    }
  }

  btnShutter.addEventListener("click", function () {
    runPageAutoShot();
  });

  btnSolve.addEventListener("click", function () {
    doSolve(false);
  });

  startCamera();
})();
</script>
</body>
</html>
