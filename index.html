<script>
// ===== 강화된 정규화(보기 추출 보강) =====
function normalizeOCR(raw) {
  if (!raw) return "";
  let t = raw;

  // 흔한 잘못 인식들을 숫자 보기로 강제 매핑
  // ①/⓵/❶/➀/➊ -> 1), ② -> 2) ...
  t = t
    .replace(/[①⓵❶➀➊]/g, " 1) ")
    .replace(/[②⓶❷➁➋]/g, " 2) ")
    .replace(/[③⓷❸➂➌]/g, " 3) ")
    .replace(/[④⓸❹➃➍]/g, " 4) ")
    .replace(/[⑤⓹❺➄➎]/g, " 5) ");

  // "1. " 패턴도 보기로 치환
  t = t
    .replace(/\b1\.\s/g, " 1) ")
    .replace(/\b2\.\s/g, " 2) ")
    .replace(/\b3\.\s/g, " 3) ")
    .replace(/\b4\.\s/g, " 4) ")
    .replace(/\b5\.\s/g, " 5) ");

  // 기괴한 패턴 보정: @D, ©, ® 같은 것들이 보기 구분자로 나타나는 경우
  // 줄 시작의 특수문자+단어를 "N) 단어"로 유추
  t = t.replace(/(?:^|\n)\s*[@©®∘○•◦]\s*([a-zA-Z가-힣][^\n]+)/g, (m, g1) => `\n ?) ${g1}`);

  // 하이픈 줄바꿈, 중복 공백/줄바꿈 정리
  t = t.replace(/-\n/g, "")
       .replace(/\n{2,}/g, "\n")
       .replace(/[ \t]+/g, " ")
       .trim();

  // 보기 라인 모으기
  const choices = [];
  // 1)~5) 뽑기
  for (let k = 1; k <= 5; k++) {
    const r = new RegExp(`(?:^|\\n)\\s*${k}\\)\\s*([^\\n]+)`);
    const m = t.match(r);
    if (m) choices.push(`${k}) ${m[1].trim()}`);
  }
  // 1)~5) 제대로 못 뽑았으면 후보 라인 추정(한 줄에 단어 하나/짧은 구)
  if (choices.length < 2) {
    const lines = t.split("\n").map(s => s.trim());
    const cand = lines.filter(s => /^[a-zA-Z가-힣][a-zA-Z가-힣\- ]{0,20}$/.test(s)).slice(-5);
    if (cand.length >= 2) {
      // 뒤쪽 5개를 1)~N)로 라벨링
      const lab = cand.slice(-5).map((v, i) => `${i + 1}) ${v}`);
      choices.push(...lab);
    }
  }

  if (choices.length >= 2) {
    const body = t.replace(/\n?\s*[1-5]\)\s*[^\n]+/g, "").trim();
    t = `${body}\n\n[CHOICES] ${choices.join(" | ")}`;
  }
  return t;
}
</script>
