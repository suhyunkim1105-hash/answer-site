<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Auto OCR(누적) → Auto Solve (KOR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <!-- Tesseract v5 -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 10px;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    .wrap { max-width: 980px; margin: 0 auto; }

    #videoBox {
      position: relative;
      width: 100%;
      border: 1px solid #333;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
    }
    #video {
      width: 100%;
      height: auto;
      display: block;
      transform-origin: center center;
    }
    #overlay {
      position: absolute;
      inset: 0;
      border: 2px solid rgba(0, 255, 0, 0.30);
      pointer-events: none;
    }

    #status {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #111;
      font-size: 13px;
      line-height: 1.4;
      white-space: pre-wrap;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .panel {
      border: 1px solid #333;
      border-radius: 10px;
      background: #0b0b0b;
      padding: 10px;
    }
    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #cfcfcf;
      font-weight: 600;
    }
    textarea, pre {
      width: 100%;
      border: 1px solid #222;
      border-radius: 8px;
      background: #000;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 10px;
      margin: 0;
    }
    textarea { height: 240px; resize: vertical; }
    pre { min-height: 260px; white-space: pre-wrap; }

    .hint {
      margin-top: 6px;
      font-size: 12px;
      color: #aaa;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="videoBox">
      <video id="video" autoplay playsinline></video>
      <div id="overlay"></div>
    </div>

    <div id="status">초기화 중...</div>

    <div class="grid">
      <div class="panel">
        <h3>실시간 OCR(누적)</h3>
        <textarea id="ocrPreview" readonly></textarea>
        <div class="hint">iOS에서 TTS가 안 나오면: 화면을 한 번 탭/터치하면 음성이 활성화되는 경우가 많음.</div>
      </div>

      <div class="panel">
        <h3>답안</h3>
        <pre id="answerBox"></pre>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // 0) 설정(요구 반영)
  // =========================
  const OCR_INTERVAL_MS = 3000;

  // 한국어만 OCR + 결과 필터
  const OCR_LANG = "kor";
  const KOREAN_ONLY_FILTER = true;

  // 누적 텍스트로 "전체가 보였다" 판단(임시)
  const TEXT_THRESHOLD_EFFECTIVE = 2400;

  // "정말 부족할 때만" 안내: 연속 1분
  const INSUFFICIENT_WARN_MS = 60 * 1000;

  // 지문 부족 지속: 8분이면 자동 풀이
  const MAX_WAIT_MS = 8 * 60 * 1000;

  // solve 함수
  const SOLVE_URL = "/.netlify/functions/solve";

  // 캡처 품질(정확도↑, 느려질 수 있음)
  const CAP_MAX_W = 2200;
  const PREPROCESS_BINARIZE = true;

  // 화면 프리뷰 배율(0.8로 멀어 보이게)
  const PREVIEW_SCALE = 0.8;

  // 카메라 줌(가능하면 0.8 적용 시도)
  const REQUESTED_CAMERA_ZOOM = 0.8;

  // TTS
  const TTS_ENABLED = true;
  const TTS_RATE = 1.05;
  const TTS_PITCH = 1.0;
  const TTS_STATUS_COOLDOWN_MS = 12000;

  // "마지막까지 봤다" 추정: 새 페이지(세그먼트) 변화가 한동안 없으면 풀이
  const NO_NEW_SEGMENT_SOLVE_MS = 20000;

  // =========================
  // 1) DOM
  // =========================
  const video = document.getElementById("video");
  const statusEl = document.getElementById("status");
  const ocrPreviewEl = document.getElementById("ocrPreview");
  const answerBoxEl = document.getElementById("answerBox");

  // =========================
  // 2) 내부 상태
  // =========================
  let stream = null;
  let track = null;

  let ocrRunning = false;
  let lastOcrAt = 0;

  // 누적(페이지 단위 세그먼트)
  const segments = []; // { text, effLen, conf, updatedAt, sig }
  let lastNewSegmentAt = 0;

  // 누적 전체
  let cumulativeText = "";
  let cumulativeEffLen = 0;
  let cumulativeAvgConf = 0;

  // 가려짐/거리 추정
  let blocked = false;
  let tooNear = false;
  let tooFar = false;

  // 부족 타이머
  let insufficientSince = null;

  // solve 상태
  let solved = false;
  let solving = false;

  // TTS 상태
  let lastStatusSpokenAt = 0;
  let audioUnlocked = false;

  // 카메라 줌 적용 결과
  let appliedZoomInfo = "알 수 없음";

  // 밝기/움직임 분석용
  const BW = 64, BH = 36;
  const bCanvas = document.createElement("canvas");
  bCanvas.width = BW;
  bCanvas.height = BH;
  const bCtx = bCanvas.getContext("2d", { willReadFrequently: true });
  let prevThumb = null;
  let lastStableStart = 0;

  // 캡처 캔버스(재사용)
  const capCanvas = document.createElement("canvas");
  const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

  // =========================
  // 3) iOS 음성 언락(탭 1회)
  // =========================
  function unlockAudioOnce() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    if (!TTS_ENABLED) return;
    speak("음성이 활성화되었습니다.", true);
  }
  document.addEventListener("click", unlockAudioOnce, { passive: true, once: true });
  document.addEventListener("touchstart", unlockAudioOnce, { passive: true, once: true });

  // =========================
  // 4) 유틸
  // =========================
  function now() { return Date.now(); }

  function effectiveLenOf(text) {
    return (text || "").replace(/\s/g, "").length;
  }

  function normalizeForCompare(text) {
    return (text || "")
      .replace(/\s/g, "")
      .replace(/[^\uAC00-\uD7A30-9]/g, ""); // 한글/숫자만 남겨 비교 안정화
  }

  function signatureOf(text) {
    const n = normalizeForCompare(text);
    return n.slice(0, 240);
  }

  function similarity(a, b) {
    const A = a || "", B = b || "";
    if (!A || !B) return 0;
    const len = Math.max(A.length, B.length);
    if (len === 0) return 0;
    const min = Math.min(A.length, B.length);
    let same = 0;
    for (let i = 0; i < min; i++) if (A[i] === B[i]) same++;
    return same / len;
  }

  function setStatus(lines) {
    statusEl.textContent = lines.join("\n");
  }

  function speak(text, force = false) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const t = (text || "").trim();
    if (!t) return;

    const tNow = now();
    if (!force && tNow - lastStatusSpokenAt < TTS_STATUS_COOLDOWN_MS) return;

    try {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(t);
      u.lang = "ko-KR";
      u.rate = TTS_RATE;
      u.pitch = TTS_PITCH;
      lastStatusSpokenAt = tNow;
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  function speakLong(text) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const t = (text || "").trim();
    if (!t) return;

    const chunkSize = 900;
    const chunks = [];
    for (let i = 0; i < t.length; i += chunkSize) chunks.push(t.slice(i, i + chunkSize));

    try {
      window.speechSynthesis.cancel();
      let idx = 0;
      const speakNext = () => {
        if (idx >= chunks.length) return;
        const u = new SpeechSynthesisUtterance(chunks[idx]);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        u.onend = () => { idx += 1; speakNext(); };
        window.speechSynthesis.speak(u);
      };
      speakNext();
    } catch (e) {}
  }

  // =========================
  // 5) 텍스트 정리(이상한 기호 제거 + 한국어만)
  // =========================
  function cleanOcrText(raw) {
    let t = (raw || "").replace(/\r/g, "").replace(/\s+\n/g, "\n").trim();

    if (KOREAN_ONLY_FILTER) {
      t = t.replace(/[A-Za-z]/g, "");
    }

    // 한글(완성형+자모), 숫자, 공백/줄바꿈, 기본 문장부호만 허용
    t = t.replace(/[^ \n0-9\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3.,!?'"“”‘’()\[\]{}<>:;~\-–—·%\/]/g, "");

    t = t.replace(/[ \t]{2,}/g, " ");
    t = t.replace(/\n{3,}/g, "\n\n");

    return t.trim();
  }

  // =========================
  // 6) Otsu 이진화(인쇄물 OCR 개선용)
  // =========================
  function otsuBinarize(ctx, w, h) {
    const img = ctx.getImageData(0, 0, w, h);
    const d = img.data;

    const hist = new Array(256).fill(0);
    const gray = new Uint8Array(w * h);

    for (let i = 0, p = 0; i < d.length; i += 4, p++) {
      const g = (d[i] * 0.299 + d[i + 1] * 0.587 + d[i + 2] * 0.114) | 0;
      gray[p] = g;
      hist[g]++;
    }

    const total = w * h;
    let sum = 0;
    for (let i = 0; i < 256; i++) sum += i * hist[i];

    let sumB = 0, wB = 0, wF = 0;
    let varMax = 0, threshold = 128;

    for (let t = 0; t < 256; t++) {
      wB += hist[t];
      if (wB === 0) continue;
      wF = total - wB;
      if (wF === 0) break;

      sumB += t * hist[t];
      const mB = sumB / wB;
      const mF = (sum - sumB) / wF;

      const varBetween = wB * wF * (mB - mF) * (mB - mF);
      if (varBetween > varMax) {
        varMax = varBetween;
        threshold = t;
      }
    }

    for (let i = 0, p = 0; i < d.length; i += 4, p++) {
      const v = gray[p] < threshold ? 0 : 255;
      d[i] = v; d[i + 1] = v; d[i + 2] = v; d[i + 3] = 255;
    }
    ctx.putImageData(img, 0, 0);
  }

  // =========================
  // 7) 카메라 시작 + 0.8 줌 시도
  // =========================
  async function startCamera() {
    try {
      video.style.transform = `scale(${PREVIEW_SCALE})`;

      setStatus([
        "카메라 요청 중...",
        "권한 팝업이 뜨면 '허용'."
      ]);

      const constraints = {
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 3840 },
          height: { ideal: 2160 },
          frameRate: { ideal: 30 }
        },
        audio: false
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      track = stream.getVideoTracks()[0] || null;

      await new Promise((resolve) => {
        if (video.readyState >= 2) return resolve();
        video.onloadedmetadata = () => resolve();
      });

      await tryApplyZoom(track, REQUESTED_CAMERA_ZOOM);

      setStatus(buildStatusLines("카메라 ON · 자동 OCR 시작"));
      requestAnimationFrame(analyzeLoop);
      scheduleOcrLoop();
    } catch (e) {
      console.error(e);
      setStatus(["카메라 접근 실패", String(e)]);
      speak("카메라 접근에 실패했습니다.", true);
    }
  }

  async function tryApplyZoom(track, requested) {
    try {
      if (!track || typeof track.getCapabilities !== "function") {
        appliedZoomInfo = "zoom cap 없음";
        return;
      }
      const cap = track.getCapabilities();
      if (!cap || typeof cap.zoom === "undefined") {
        appliedZoomInfo = "zoom 미지원";
        return;
      }

      const minZ = cap.zoom.min;
      const maxZ = cap.zoom.max;
      const target = Math.max(minZ, Math.min(maxZ, requested));

      if (typeof track.applyConstraints === "function") {
        await track.applyConstraints({ advanced: [{ zoom: target }] });
        appliedZoomInfo = `요청 ${requested} → 적용 ${target} (cap ${minZ}-${maxZ})`;
      } else {
        appliedZoomInfo = "applyConstraints 없음";
      }
    } catch (e) {
      appliedZoomInfo = "zoom 적용 실패";
    }
  }

  // =========================
  // 8) 밝기/움직임 분석(가려짐)
  // =========================
  function analyzeFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      return { blocked: false, stable: false, avgBright: 255, diffAvg: 0 };
    }

    bCtx.drawImage(video, 0, 0, BW, BH);
    const img = bCtx.getImageData(0, 0, BW, BH).data;

    const len = BW * BH;
    const currThumb = new Uint8Array(len);

    let sumBright = 0;
    let diffSum = 0;

    for (let i = 0, p = 0; i < img.length; i += 4, p++) {
      const r = img[i], g = img[i + 1], b = img[i + 2];
      const gray = (r + g + b) / 3;
      currThumb[p] = gray;
      sumBright += gray;
      if (prevThumb) diffSum += Math.abs(gray - prevThumb[p]);
    }

    const avgBright = sumBright / len;
    const diffAvg = prevThumb ? (diffSum / len) : 0;
    prevThumb = currThumb;

    const isBlocked = avgBright < 20;

    const tNow = now();
    let stable = false;
    if (diffAvg < 8) {
      if (!lastStableStart) lastStableStart = tNow;
      if (tNow - lastStableStart >= 900) stable = true;
    } else {
      lastStableStart = 0;
    }

    return { blocked: isBlocked, stable, avgBright, diffAvg };
  }

  function analyzeLoop() {
    const a = analyzeFrame();
    blocked = a.blocked;
    requestAnimationFrame(analyzeLoop);
  }

  // =========================
  // 9) 캡처(최대한 많이 담기) + 전처리
  // =========================
  function captureToCanvas() {
    const vw = video.videoWidth;
    const vh = video.videoHeight;

    if (!vw || !vh) {
      capCanvas.width = 640;
      capCanvas.height = 360;
      capCtx.fillStyle = "black";
      capCtx.fillRect(0, 0, capCanvas.width, capCanvas.height);
      return capCanvas;
    }

    // 크롭 최소화(전체를 담기)
    const cropW = vw;
    const cropH = vh;
    const cropX = 0;
    const cropY = 0;

    const scale = Math.min(1, CAP_MAX_W / cropW);
    const outW = Math.max(480, Math.floor(cropW * scale));
    const outH = Math.max(360, Math.floor(cropH * scale));

    capCanvas.width = outW;
    capCanvas.height = outH;

    capCtx.imageSmoothingEnabled = false;
    capCtx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, outW, outH);

    if (PREPROCESS_BINARIZE) {
      otsuBinarize(capCtx, outW, outH);
    }

    return capCanvas;
  }

  // =========================
  // 10) 자동 OCR: "멈추지 않게"
  // =========================
  function shouldTryOcr() {
    if (solved || solving) return false;
    if (ocrRunning) return false;
    if (blocked) return false;

    const tNow = now();
    if (tNow - lastOcrAt < OCR_INTERVAL_MS) return false;

    // stable 조건으로 OCR 자체를 막지 않는다(한 번 하고 멈춘 것처럼 보이는 문제 방지)
    return true;
  }

  async function doOcrOnce() {
    if (!shouldTryOcr()) return;
    ocrRunning = true;
    lastOcrAt = now();

    try {
      const canvas = captureToCanvas();
      setStatus(buildStatusLines("OCR 진행 중..."));

      const result = await Tesseract.recognize(canvas, OCR_LANG, {
        logger: (m) => {
          if (m && m.status === "recognizing text") {
            const p = Math.round((m.progress || 0) * 100);
            setStatus(buildStatusLines(`OCR 진행 중... ${p}%`));
          }
        }
      });

      const rawText = (result && result.data && result.data.text) ? result.data.text : "";
      const conf = (result && result.data && typeof result.data.confidence === "number")
        ? result.data.confidence
        : 0;

      const text = cleanOcrText(rawText);
      const effLen = effectiveLenOf(text);

      if (effLen < 30 || conf < 5) {
        setStatus(buildStatusLines("OCR 완료(너무 짧음/낮은 신뢰도)"));
        return;
      }

      // 거리 추정(휴리스틱)
      tooFar = (effLen < 450 && conf < 35);
      tooNear = (effLen >= 900 && conf < 35);

      updateSegments(text, effLen, conf);
      updateCumulative();

      // 부족 타이머(누적 기준)
      const tNow = now();
      if (cumulativeEffLen < TEXT_THRESHOLD_EFFECTIVE) {
        if (!insufficientSince) insufficientSince = tNow;
      } else {
        insufficientSince = null;
      }

      ocrPreviewEl.value = cumulativeText;
      setStatus(buildStatusLines("OCR 완료"));

      // 자동 풀이 조건:
      // 1) 누적 충분 + 새 세그먼트 변화가 한동안 없음
      // 2) 또는 부족이 8분 지속되면 부족해도 풀이
      if (!solved && !solving) {
        const enough = cumulativeEffLen >= TEXT_THRESHOLD_EFFECTIVE;
        const noNewFor = lastNewSegmentAt ? (tNow - lastNewSegmentAt) : 0;
        const insufficientDuration = insufficientSince ? (tNow - insufficientSince) : 0;

        // 1분 연속 부족이면 안내(정말 부족할 때만)
        if (insufficientSince && insufficientDuration >= INSUFFICIENT_WARN_MS && insufficientDuration < MAX_WAIT_MS) {
          speak(buildInsufficientReason(), false);
        }

        if (enough && noNewFor >= NO_NEW_SEGMENT_SOLVE_MS) {
          await autoSolve("누적 충분 + 새 페이지 변화 없음");
          return;
        }

        if (insufficientSince && insufficientDuration >= MAX_WAIT_MS) {
          await autoSolve("최대 대기시간 초과(지문 부족). 현재 누적 내용으로 풀이");
          return;
        }
      }

    } catch (e) {
      console.error(e);
      setStatus(buildStatusLines("OCR 에러: " + String(e)));
    } finally {
      ocrRunning = false;
    }
  }

  function updateSegments(text, effLen, conf) {
    const sig = signatureOf(text);

    let bestIdx = -1;
    let bestSim = 0;

    for (let i = 0; i < segments.length; i++) {
      const s = segments[i];
      const sim = similarity(sig, s.sig);
      if (sim > bestSim) {
        bestSim = sim;
        bestIdx = i;
      }
    }

    const SAME_PAGE_SIM = 0.62;

    if (bestIdx >= 0 && bestSim >= SAME_PAGE_SIM) {
      const prev = segments[bestIdx];

      const better =
        (effLen > prev.effLen + 80) ||
        (Math.abs(effLen - prev.effLen) <= 80 && conf > prev.conf + 5);

      if (better) {
        segments[bestIdx] = { text, effLen, conf, updatedAt: now(), sig };
      } else {
        segments[bestIdx].updatedAt = now();
      }
      return;
    }

    segments.push({ text, effLen, conf, updatedAt: now(), sig });
    lastNewSegmentAt = now();
  }

  function updateCumulative() {
    let out = "";
    let totalEff = 0;
    let confSum = 0;

    for (let i = 0; i < segments.length; i++) {
      const s = segments[i];
      if (i > 0) out += "\n\n----------\n\n";
      out += s.text;
      totalEff += s.effLen;
      confSum += s.conf;
    }

    cumulativeText = out.trim();
    cumulativeEffLen = totalEff;
    cumulativeAvgConf = segments.length ? (confSum / segments.length) : 0;
  }

  // =========================
  // 11) 상태/안내
  // =========================
  function buildInsufficientReason() {
    if (blocked) return "카메라가 가려졌습니다. 렌즈를 가리지 않게 해주세요.";
    if (tooFar) return "지문이 너무 멀어 보입니다. 종이를 화면에 더 크게 채워주세요.";
    if (tooNear) return "지문이 너무 가까워 보입니다. 5에서 10센티미터 정도만 멀리 두고 다시 비춰주세요.";
    return "아직 지문이 부족합니다. 첫 제시문부터 마지막 질문까지 천천히 비춰주세요.";
  }

  function buildStatusLines(extraLine) {
    const lines = [];
    lines.push("자동 OCR(누적) → 자동 풀이");
    lines.push(`프리뷰 배율: ${PREVIEW_SCALE} | 카메라 zoom: ${appliedZoomInfo}`);
    lines.push(`카메라 상태: ${blocked ? "가려짐" : "정상"}`);

    let dist = "정상(추정)";
    if (tooFar) dist = "너무 멂(추정)";
    else if (tooNear) dist = "너무 가까움(추정)";
    lines.push(`거리 상태: ${dist}`);

    lines.push(`세그먼트(페이지 추정) 수: ${segments.length}`);
    lines.push(`누적 OCR 길이(공백제외): ${cumulativeEffLen} / 기준 ${TEXT_THRESHOLD_EFFECTIVE}`);
    lines.push(`평균 OCR 신뢰도(대략): ${cumulativeAvgConf.toFixed(1)}%`);

    if (insufficientSince && cumulativeEffLen < TEXT_THRESHOLD_EFFECTIVE) {
      const sec = Math.floor((now() - insufficientSince) / 1000);
      lines.push(`지문 부족 지속: ${sec}초 (1분 안내, 8분이면 자동 풀이)`);
    } else {
      lines.push("지문 부족 지속: 0초");
    }

    if (extraLine) lines.push(String(extraLine));
    return lines;
  }

  // =========================
  // 12) 자동 풀이(solve) + "지문 부족" 안내문/음성
  // =========================
  async function autoSolve(reason) {
    if (solved || solving) return;
    solving = true;

    const payloadText = (cumulativeText || "").trim();
    if (!payloadText) {
      answerBoxEl.textContent = "누적 OCR 텍스트가 없습니다.";
      solving = false;
      return;
    }

    setStatus(buildStatusLines(`풀이 요청 중... (${reason})`));
    answerBoxEl.textContent = "풀이 생성 중...";

    // solve.js는 { ocrText } 기대(네 코드 기준)
    const body = JSON.stringify({ ocrText: payloadText });

    try {
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();

      let out = "";
      if (ct.includes("application/json")) {
        let data;
        try { data = await res.json(); }
        catch (e) { out = "JSON 파싱 에러: " + String(e); }
        if (!out) {
          if (data && typeof data.answer === "string") out = data.answer;
          else if (data && typeof data.body === "string") out = data.body;
          else out = JSON.stringify(data);
        }
      } else {
        out = await res.text();
      }

      if (!res.ok) {
        answerBoxEl.textContent = `서버 에러 (status ${res.status})\n\n${out.slice(0, 4000)}`;
        speak("서버 에러가 발생했습니다.", true);
        solving = false;
        return;
      }

      // 성공
      solved = true;

      const isInsufficientSolve =
        (reason || "").includes("최대 대기시간") ||
        (reason || "").includes("지문 부족");

      const prefix = isInsufficientSolve
        ? "지문이 부족하여 현재까지 인식된 내용으로 자동 풀이를 시작합니다.\n\n"
        : "";

      answerBoxEl.textContent = prefix + out;
      setStatus(buildStatusLines("풀이 완료"));

      if (isInsufficientSolve) {
        speak("지문이 부족하여 현재까지 인식된 내용으로 자동 풀이를 시작합니다.", true);
      } else {
        speak("답안이 생성되었습니다.", true);
      }

      speakLong(prefix + out);

    } catch (e) {
      console.error(e);
      answerBoxEl.textContent = "요청 실패: " + String(e);
      speak("요청에 실패했습니다.", true);
    } finally {
      solving = false;
    }
  }

  // =========================
  // 13) OCR 루프 시작
  // =========================
  function scheduleOcrLoop() {
    doOcrOnce();
    setInterval(() => { doOcrOnce(); }, OCR_INTERVAL_MS);
  }

  // =========================
  // 14) 시작
  // =========================
  startCamera();
})();
</script>
</body>
</html>



