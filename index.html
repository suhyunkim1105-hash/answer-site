<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 16px; }
    #status { white-space: pre-wrap; padding: 10px; border: 1px solid #ddd; border-radius: 8px; min-height: 96px; }
    button { padding: 12px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; font-size: 16px; }
    button:disabled { opacity: 0.5; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    textarea { width: 100%; min-height: 140px; margin-top: 10px; }
    .small { font-size: 12px; color: #666; line-height: 1.45; }

    /* Video + overlay */
    .camWrap { position: relative; width: 100%; max-width: 520px; }
    video { width: 100%; border-radius: 12px; background: #000; display:block; }
    .roiBox {
      position: absolute;
      left: 9%;
      top: 6%;
      width: 82%;
      height: 88%;
      border: 2px solid rgba(255,255,255,0.9);
      border-radius: 10px;
      box-shadow: 0 0 0 2000px rgba(0,0,0,0.25) inset;
      pointer-events: none;
    }
    .roiHint {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 10px;
      text-align: center;
      color: rgba(255,255,255,0.95);
      font-size: 13px;
      text-shadow: 0 1px 2px rgba(0,0,0,0.6);
      pointer-events: none;
    }
  </style>
</head>
<body>
  <h2>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</h2>

  <div id="status">ëŒ€ê¸° ì¤‘</div>

  <div class="row" style="margin:12px 0;">
    <button id="btnAudio">ğŸ”Š ì˜¤ë””ì˜¤ ì¤€ë¹„(í•œ ë²ˆë§Œ)</button>
    <button id="btnStart">ğŸ“¸ ìë™ ì‹œì‘</button>
    <button id="btnStop" disabled>â›” ì¤‘ì§€</button>
    <button id="btnReplay" disabled>ğŸ” ì •ë‹µ ë‹¤ì‹œë“£ê¸°</button>
  </div>

  <div class="small">
    - ì‹œí—˜ì§€ë¥¼ <b>í° ë°•ìŠ¤ì— ê½‰ ì°¨ê²Œ</b> ë§ì¶°ë¼(ì´ê²Œ OCR ì„±ëŠ¥ 90% ê²°ì •).<br/>
    - ë§ˆì§€ë§‰ í˜ì´ì§€ì— <b>XVRTH</b> ë¥¼ êµµê³  í¬ê²Œ ì ìœ¼ë©´ ìë™ìœ¼ë¡œ OCR ì¢…ë£Œ í›„ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br/>
    - iOS ë¬´ìŒëª¨ë“œ(ì‚¬ì¼ëŸ°íŠ¸)ë©´ TTSê°€ ì•ˆ ë“¤ë¦´ ìˆ˜ ìˆë‹¤. ë¬´ìŒ í•´ì œ + ë³¼ë¥¨ ì˜¬ë ¤ë¼.
  </div>

  <div style="margin-top:12px;">
    <div class="camWrap">
      <video id="video" autoplay playsinline muted></video>
      <div class="roiBox"></div>
      <div class="roiHint">ì‹œí—˜ì§€ë¥¼ ì´ ë°•ìŠ¤ ì•ˆì— ê½‰ ì°¨ê²Œ ë§ì¶°ë¼</div>
    </div>
  </div>

  <h3 style="margin-top:16px;">OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸)</h3>
  <textarea id="ocrBox" placeholder="ìë™ OCR ê²°ê³¼ê°€ ëˆ„ì ëœë‹¤(ìˆ˜ë™ ìˆ˜ì • ê¸ˆì§€)."></textarea>

  <h3 style="margin-top:16px;">ì •ë‹µ(ë””ë²„ê·¸)</h3>
  <textarea id="ansBox" placeholder="ìë™ í’€ì´ ê²°ê³¼ê°€ ì—¬ê¸°ì— ì¶œë ¥ëœë‹¤."></textarea>

<script>
(() => {
  const OCR_URL   = "/.netlify/functions/ocr";
  const SOLVE_URL = "/.netlify/functions/solve";

  // ì´¬ì˜/ì¸ì‹ ì„¤ì •
  const SHOTS_PER_PAGE = 3;
  const SHOT_GAP_MS = 120;              // ìƒ· ê°„ ë”œë ˆì´ ìµœì†Œ
  const MAX_PAGES = 25;
  const MAX_RETRY_PER_PAGE = 4;

  // í˜ì´ì§€ ë„˜ê¹€ ì•ˆë‚´ í›„ ë‹¤ìŒ ì´¬ì˜ê¹Œì§€ ëŒ€ê¸°
  const TURN_PAGE_WAIT_MS = 650;

  // OCR í’ˆì§ˆ ê¸°ì¤€
  const MIN_TEXT_LEN = 700;
  const MIN_QNUM_HITS = 2;
  const PASSAGE_LEN_OK = 1400;

  // ì¢…ë£Œ ê°ì§€
  const STOP_PHRASE = "XVRTH";

  // ì •ë‹µ TTS
  const ANSWER_ROUNDS = 4;
  const BETWEEN_ANS_MS = 2000;          // ë¬¸í•­ ì‚¬ì´ 2ì´ˆ
  const BETWEEN_ROUND_MS = 600;

  // âœ… í•µì‹¬: ROI(ì¤‘ì•™ í¬ë¡­) â€” "í”„ë ˆì„ ì „ì²´"ê°€ ì•„ë‹ˆë¼ ì´ ì˜ì—­ë§Œ OCRë¡œ ë³´ë‚¸ë‹¤
  // (í˜„ì¬ UI overlay ë°•ìŠ¤ì™€ ë™ì¼ ë¹„ìœ¨)
  const ROI = { x: 0.09, y: 0.06, w: 0.82, h: 0.88 };

  let running = false;
  let stream = null;

  let currentPage = 1;
  let pages = []; // {page, text, conf, qnums:Set<number>}
  let allText = "";

  let koVoice = null;
  let audioReady = false;
  let lastAnswers = null;

  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnAudio = document.getElementById("btnAudio");
  const btnStart = document.getElementById("btnStart");
  const btnStop = document.getElementById("btnStop");
  const btnReplay = document.getElementById("btnReplay");
  const ocrBox = document.getElementById("ocrBox");
  const ansBox = document.getElementById("ansBox");

  // ì´ˆê¸° ìƒíƒœ ê³ ì •
  btnStart.disabled = false;
  btnStop.disabled = true;
  btnReplay.disabled = true;

  function log(msg) {
    const t = new Date().toLocaleTimeString("ko-KR", { hour12:false });
    statusEl.textContent = `[${t}] ${msg}\n` + statusEl.textContent;
    console.log(msg);
  }
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // ---------- iOS ì˜¤ë””ì˜¤ ì–¸ë½(ì²´ê°ë˜ê²Œ) ----------
  async function beep() {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      const ctx = new AC();
      await ctx.resume().catch(()=>{});
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = 880;
      gain.gain.value = 0.08;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.08);
    } catch (_) {}
  }

  async function unlockAudio() {
    if (audioReady) return true;
    try { speechSynthesis.getVoices(); } catch (_) {}
    await beep();
    audioReady = true;
    log("AudioContext ì–¸ë½ ì™„ë£Œ");
    return true;
  }

  // ---------- TTS ----------
  function pickKoreanVoice() {
    const voices = speechSynthesis.getVoices() || [];
    const ko = voices.filter(v => (v.lang || "").toLowerCase().startsWith("ko"));
    const preferred = ko.find(v => /yuna|ìœ ë‚˜|ì„œí˜„|ì§€ì€|ì•„ë¦¬/i.test(v.name));
    koVoice = preferred || ko[0] || null;
    if (koVoice) log(`TTS voice: ${koVoice.name} (${koVoice.lang})`);
    else log("TTS voice ì„ íƒ ì‹¤íŒ¨");
  }

  function speak(text) {
    return new Promise(resolve => {
      try {
        const u = new SpeechSynthesisUtterance(String(text));
        u.lang = "ko-KR";
        u.rate = 1.0;
        if (koVoice) u.voice = koVoice;
        u.onend = resolve;
        u.onerror = resolve;
        speechSynthesis.speak(u);
      } catch (_) { resolve(); }
    });
  }

  async function speakTurnPage(page) {
    await speak(`í˜ì´ì§€ ${page} ì¸ì‹ ì™„ë£Œ. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë„˜ê²¨ ì£¼ì„¸ìš”.`);
    await sleep(TURN_PAGE_WAIT_MS);
  }

  async function speakAnswers(answerNumMap) {
    const toLetter = (n)=>["A","B","C","D","E"][Number(n)-1] || "";
    const keys = Object.keys(answerNumMap).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);

    try { speechSynthesis.cancel(); } catch (_) {}

    for (let r=1; r<=ANSWER_ROUNDS; r++) {
      for (const q of keys) {
        const a = toLetter(answerNumMap[String(q)]);
        if (!a) continue;
        await speak(`${q}ë²ˆ ${a}`);
        await sleep(BETWEEN_ANS_MS);
      }
      await sleep(BETWEEN_ROUND_MS);
    }
  }

  // ---------- Camera (fallback + zoom) ----------
  async function getStreamWithFallback() {
    const tries = [
      { video: { facingMode: { ideal: "environment" }, width:{ ideal:1920 }, height:{ ideal:1080 } }, audio:false },
      { video: { facingMode: "environment" }, audio:false },
      { video: true, audio:false }
    ];
    let lastErr = null;
    for (const c of tries) {
      try { return await navigator.mediaDevices.getUserMedia(c); }
      catch (e) { lastErr = e; }
    }
    throw lastErr || new Error("getUserMedia failed");
  }

  async function applyBestCameraSettings() {
    try {
      const track = stream?.getVideoTracks?.()[0];
      if (!track || !track.getCapabilities || !track.applyConstraints) return;

      const caps = track.getCapabilities();
      const adv = [];

      // âœ… zoom ê°€ëŠ¥í•˜ë©´ ìµœëŒ€ ê·¼ì²˜ë¡œ ì˜¬ë¦°ë‹¤(ì•„ì´í°ì´ ì§€ì›í•˜ë©´ ì²´ê° í™• ë‹¬ë¼ì§)
      if (caps.zoom) {
        const z = Math.min(caps.zoom.max, Math.max(caps.zoom.min, caps.zoom.max)); // ì‚¬ì‹¤ìƒ max
        adv.push({ zoom: z });
        log(`ì¤Œ ì ìš© ì‹œë„: ${z}`);
      }

      // iOSê°€ ì§€ì›í•˜ë©´ continuous ìª½ ì‹œë„(ì§€ì› ì•ˆ í•˜ë©´ ë¬´ì‹œë¨)
      if (caps.focusMode && Array.isArray(caps.focusMode) && caps.focusMode.includes("continuous")) {
        adv.push({ focusMode: "continuous" });
      }
      if (caps.exposureMode && Array.isArray(caps.exposureMode) && caps.exposureMode.includes("continuous")) {
        adv.push({ exposureMode: "continuous" });
      }
      if (caps.whiteBalanceMode && Array.isArray(caps.whiteBalanceMode) && caps.whiteBalanceMode.includes("continuous")) {
        adv.push({ whiteBalanceMode: "continuous" });
      }

      if (adv.length > 0) {
        await track.applyConstraints({ advanced: adv }).catch(()=>{});
      }
    } catch (_) {}
  }

  async function startCamera() {
    if (stream) return;
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error("ì´ ë¸Œë¼ìš°ì €ëŠ” ì¹´ë©”ë¼ APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŒ");
    }

    stream = await getStreamWithFallback();
    video.srcObject = stream;

    // iOS: play() ê°•ì œ
    try { await video.play(); } catch (_) {}

    // ì¤€ë¹„ ëŒ€ê¸°(readyStateê°€ ì˜¬ë¼ì˜¬ ë•Œê¹Œì§€ ì¡°ê¸ˆ ë” ê¸°ë‹¤ë¦¼)
    const t0 = Date.now();
    while (video.readyState < 2 && Date.now() - t0 < 1500) {
      await sleep(50);
    }

    // ì¤Œ/í¬ì»¤ìŠ¤/ë…¸ì¶œ ìë™ ì¡°ì • ì‹œë„
    await applyBestCameraSettings();

    // í¬ì»¤ìŠ¤ ì•ˆì •í™” ì›Œë°ì—…
    await sleep(200);

    log(`ì¹´ë©”ë¼ OK (${video.videoWidth}x${video.videoHeight})`);
  }

  // ---------- Capture with ROI crop ----------
  function captureRoiBase64Jpeg(quality=0.90) {
    const w = video.videoWidth, h = video.videoHeight;
    if (!w || !h) throw new Error("ì¹´ë©”ë¼ í”„ë ˆì„ í¬ê¸° 0(ìŠ¤íŠ¸ë¦¼ ì¤€ë¹„ ì•ˆ ë¨)");

    // ì›ë³¸ ìº”ë²„ìŠ¤
    const src = document.createElement("canvas");
    src.width = w; src.height = h;
    const sctx = src.getContext("2d", { willReadFrequently: false });
    sctx.drawImage(video, 0, 0, w, h);

    // ROI ì¢Œí‘œ
    const rx = Math.max(0, Math.floor(w * ROI.x));
    const ry = Math.max(0, Math.floor(h * ROI.y));
    const rw = Math.max(1, Math.floor(w * ROI.w));
    const rh = Math.max(1, Math.floor(h * ROI.h));

    // í¬ë¡­ ìº”ë²„ìŠ¤(ROIë§Œ)
    const crop = document.createElement("canvas");
    crop.width = rw;
    crop.height = rh;
    const cctx = crop.getContext("2d", { willReadFrequently: false });
    cctx.drawImage(src, rx, ry, rw, rh, 0, 0, rw, rh);

    // OCRì´ ë” ì˜ ë¨¹ê²Œ ì•½ê°„ ìƒ¤í”„ë‹/ëŒ€ë¹„ëŠ” ì„œë²„ì—ì„œ í•˜ëŠ” ê²Œ ë‚«ì§€ë§Œ,
    // ì—¬ê¸°ì„œëŠ” ì•ˆì „í•˜ê²Œ "í¬ë¡­ë§Œ" í•œë‹¤(ì˜¤ë¥˜ ìµœì†Œ).
    return crop.toDataURL("image/jpeg", quality);
  }

  // ---------- OCR ----------
  async function callOcr(dataUrl, pageIndex) {
    const payload = { image: dataUrl, pageIndex, mode: "dual" };
    const res = await fetch(OCR_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    const j = await res.json().catch(()=>null);
    if (!j || !j.ok) return { ok:false, text:"", conf:0 };
    return { ok:true, text:String(j.text||""), conf:Number(j.conf||0) };
  }

  const normalizeNoSpace = (s)=>String(s||"").replace(/\s+/g,"").trim();
  function detectStop(text) {
    const t = normalizeNoSpace(text);
    return t.includes(normalizeNoSpace(STOP_PHRASE));
  }

  function qnumHits(text) {
    const m = String(text||"").match(/(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g);
    return m ? m.length : 0;
  }

  function extractQnumsFromPage(text) {
    const out = new Set();
    const re = /(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g;
    let m;
    const t = String(text||"");
    while ((m = re.exec(t)) !== null) out.add(parseInt(m[1],10));
    return out;
  }

  function qualityOk(text) {
    const len = String(text||"").length;
    const hits = qnumHits(text);
    if (len >= PASSAGE_LEN_OK) return true;
    if (len >= MIN_TEXT_LEN && hits >= MIN_QNUM_HITS) return true;
    return false;
  }

  async function ocrOnePage(pageIndex) {
    let best = null;

    for (let shot=1; shot<=SHOTS_PER_PAGE; shot++) {
      if (!running) return null;
      await sleep(SHOT_GAP_MS);

      // âœ… ROI í¬ë¡­ ìº¡ì²˜ë¡œ OCRë¡œ ë³´ëƒ„ (ì¤‘ìš”)
      const dataUrl = captureRoiBase64Jpeg(0.92);
      const r = await callOcr(dataUrl, pageIndex);

      const text = r.ok ? r.text : "";
      const conf = r.ok ? r.conf : 0;
      const hits = qnumHits(text);

      const score = (text.length/50) + (hits*30) + (conf*2);
      log(`OCR ${r.ok?"OK":"FAIL"} page=${pageIndex} shot=${shot} len=${text.length} conf=${conf} hits=${hits} score=${score.toFixed(1)}`);

      const cand = { shot, text, conf, score, stop: detectStop(text) };
      if (!best || cand.score > best.score) best = cand;

      if (cand.stop) return cand;
    }

    if (!best) return null;
    best.stop = detectStop(best.text);
    return best;
  }

  function rebuildAllText() {
    allText = "";
    for (const p of pages) {
      allText += `[PAGE ${p.page}] (conf=${(p.conf||0).toFixed(1)})\n${p.text}\n\n`;
    }
    ocrBox.value = allText;
  }

  async function recaptureSpecificPages(targetPages) {
    for (const p of targetPages) {
      if (!running) return;
      await speak(`ë¬¸ì œê°€ ìˆëŠ” í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤. í˜ì´ì§€ ${p}ë¥¼ í° ë°•ìŠ¤ì— ê½‰ ì°¨ê²Œ ë§ì¶° ì£¼ì„¸ìš”.`);
      await sleep(350);

      let ok = false;
      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) return;

        log(`ì¬ì´¬ì˜: í˜ì´ì§€ ${p} ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        const r = await ocrOnePage(p);
        if (!r) break;

        if (r.stop || qualityOk(r.text)) {
          const idx = pages.findIndex(x => x.page === p);
          const qnums = extractQnumsFromPage(r.text);
          const entry = { page:p, text:r.text, conf:r.conf, qnums };
          if (idx >= 0) pages[idx] = entry; else pages.push(entry);
          pages.sort((a,b)=>a.page-b.page);
          rebuildAllText();
          ok = true;
          break;
        }

        await speak(`ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. í˜ì´ì§€ ${p}ë¥¼ í° ë°•ìŠ¤ì— ê½‰ ì°¨ê²Œ ë‹¤ì‹œ ë§ì¶° ì£¼ì„¸ìš”.`);
      }

      if (!ok) {
        await speak(`í˜ì´ì§€ ${p}ê°€ ê³„ì† ì•ˆ ì½í™ë‹ˆë‹¤. ì¡°ëª…ê³¼ ê°ë„ë¥¼ ë°”ê¿” ì£¼ì„¸ìš”.`);
        throw new Error(`ì¬ì´¬ì˜ ì‹¤íŒ¨(page=${p})`);
      }
    }
  }

  // ---------- Solve ----------
  async function callSolve(allText) {
    const res = await fetch(SOLVE_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ text: allText })
    });
    const j = await res.json().catch(()=>null);
    if (!j) return { ok:false, error:"Solve JSON parse failed" };
    return j;
  }

  function answersToText(ansNumMap) {
    const toLetter = (n)=>["A","B","C","D","E"][Number(n)-1] || "";
    const keys = Object.keys(ansNumMap||{}).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);
    return keys.map(k => `${k}ë²ˆ: ${toLetter(ansNumMap[String(k)])}`).join("\n");
  }

  function mapBadQuestionsToPages(badQs) {
    const pagesSet = new Set();
    for (const q of badQs) {
      for (const p of pages) {
        if (p.qnums && p.qnums.has(q)) pagesSet.add(p.page);
      }
    }
    return Array.from(pagesSet).sort((a,b)=>a-b);
  }

  // ---------- Main ----------
  async function runAuto() {
    running = true;
    btnStart.disabled = true;
    btnStop.disabled = false;
    btnReplay.disabled = true;

    pages = [];
    allText = "";
    currentPage = 1;
    ocrBox.value = "";
    ansBox.value = "";
    lastAnswers = null;

    await unlockAudio();
    pickKoreanVoice();

    await startCamera();
    await speak("ìë™ ì´¬ì˜ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì‹œí—˜ì§€ë¥¼ í° ë°•ìŠ¤ì— ê½‰ ì°¨ê²Œ ë§ì¶° ì£¼ì„¸ìš”.");

    while (running && currentPage <= MAX_PAGES) {
      let okPage = false;
      let last = null;

      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) break;

        log(`í˜ì´ì§€ ${currentPage} OCR ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        last = await ocrOnePage(currentPage);
        if (!last) break;

        const ok = last.stop || qualityOk(last.text);

        if (ok) {
          const qnums = extractQnumsFromPage(last.text);
          pages.push({ page: currentPage, text: last.text, conf: last.conf, qnums });
          rebuildAllText();
          okPage = true;
          break;
        } else {
          // âœ… ì‹¤íŒ¨ ì‹œ â€œêµ¬ì²´ ì§€ì‹œâ€
          await speak(`ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. í˜ì´ì§€ ${currentPage}ë¥¼ í° ë°•ìŠ¤ì— ê½‰ ì°¨ê²Œ ë§ì¶° ì£¼ì„¸ìš”.`);
        }
      }

      if (!okPage) {
        await speak(`í˜ì´ì§€ ${currentPage}ë¥¼ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì‹œí—˜ì§€ë¥¼ ë” ê°€ê¹Œì´ ê°€ì ¸ì˜¤ê³  ë°˜ì‚¬ë¥¼ ì—†ì•  ì£¼ì„¸ìš”.`);
        throw new Error(`OCR ì‹¤íŒ¨(page=${currentPage})`);
      }

      if (last && last.stop) {
        log(`STOP(${STOP_PHRASE}) ê°ì§€ â†’ OCR ì¢…ë£Œ`);
        break;
      }

      await speakTurnPage(currentPage);
      currentPage++;
    }

    await speak("ì´ì œ ë¬¸ì œë¥¼ í’‰ë‹ˆë‹¤.");

    for (let attempt=1; attempt<=2; attempt++) {
      const solved = await callSolve(allText);

      if (solved.ok && solved.answers) {
        lastAnswers = solved.answers;
        ansBox.value = answersToText(solved.answers);
        btnReplay.disabled = false;
        await speak("ì •ë‹µì„ ì½ê² ìŠµë‹ˆë‹¤.");
        await speakAnswers(solved.answers);
        log("ì™„ë£Œ");
        return;
      }

      const badQs = Array.isArray(solved.bad_questions) ? solved.bad_questions : [];
      if (badQs.length === 0 || attempt === 2) {
        log(`SOLVE ì‹¤íŒ¨: ${solved.error || "unknown"}`);
        await speak("í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì´¬ì˜ ìƒíƒœë¥¼ ê°œì„ í•´ ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”.");
        throw new Error(`SOLVE ì‹¤íŒ¨: ${solved.error || "unknown"}`);
      }

      const targetPages = mapBadQuestionsToPages(badQs);
      if (targetPages.length === 0) {
        await speak("ì¼ë¶€ ë¬¸í•­ ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”.");
        throw new Error("bad_questions page mapping failed");
      }

      await speak(`ë‹¤ìŒ ë¬¸í•­ì´ ì˜ ì•ˆ ì½í˜”ìŠµë‹ˆë‹¤. ${badQs.slice(0,10).join(", ")}ë²ˆ. í•´ë‹¹ í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
      await recaptureSpecificPages(targetPages);
    }
  }

  function stopAll() {
    running = false;
    btnStart.disabled = false;
    btnStop.disabled = true;
    try { speechSynthesis.cancel(); } catch(_) {}
    log("STOP");
  }

  btnAudio.addEventListener("click", async () => {
    try {
      await unlockAudio();
      pickKoreanVoice();
      await speak("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ.");
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ(ë²„íŠ¼)");
    } catch (e) {
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì‹¤íŒ¨: " + String(e?.message || e));
    }
  });

  btnStart.addEventListener("click", async () => {
    try {
      await runAuto();
    } catch (e) {
      log(`ERROR: ${e && e.message ? e.message : e}`);
      try { await speak("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”."); } catch (_) {}
      stopAll();
    }
  });

  btnStop.addEventListener("click", () => stopAll());

  btnReplay.addEventListener("click", async () => {
    try {
      await unlockAudio();
      pickKoreanVoice();
      if (!lastAnswers) { await speak("ì •ë‹µì´ ì—†ìŠµë‹ˆë‹¤."); return; }
      await speakAnswers(lastAnswers);
    } catch (e) {
      log("ì •ë‹µ ë‹¤ì‹œë“£ê¸° ì‹¤íŒ¨: " + String(e?.message || e));
    }
  });

  speechSynthesis.onvoiceschanged = () => pickKoreanVoice();
})();
</script>
</body>
</html>
