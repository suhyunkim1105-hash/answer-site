<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <meta name="color-scheme" content="dark" />
  <title>Auto OCR → Solve → TTS</title>

  <style>
    :root { --bg:#0b0d12; --card:#111522; --line:rgba(255,255,255,.12); --txt:#e9eefc; --mut:rgba(233,238,252,.72); }
    html,body{background:var(--bg); color:var(--txt); font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,"Apple SD Gothic Neo","Noto Sans KR",sans-serif; margin:0;}
    .wrap{max-width:980px; margin:0 auto; padding:16px;}
    .row{display:flex; gap:10px; flex-wrap:wrap; align-items:center;}
    .btn{
      appearance:none; border:1px solid var(--line); background:rgba(255,255,255,.06);
      color:var(--txt); padding:12px 14px; border-radius:14px; font-weight:800; cursor:pointer;
    }
    .btn:active{transform:translateY(1px);}
    .btn.primary{background:rgba(0,180,255,.18); border-color:rgba(0,180,255,.35);}
    .btn.danger{background:rgba(255,70,70,.14); border-color:rgba(255,70,70,.35);}
    .pill{border:1px solid var(--line); background:rgba(255,255,255,.04); border-radius:999px; padding:8px 12px; font-size:12px; color:var(--mut);}
    .grid{display:grid; grid-template-columns:1fr; gap:12px; margin-top:12px;}
    @media(min-width:900px){ .grid{grid-template-columns:1fr 1fr;} }
    .card{border:1px solid var(--line); background:var(--card); border-radius:18px; padding:12px;}
    .title{font-size:15px; font-weight:900; margin:0 0 8px;}
    .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
    .small{font-size:12px; color:var(--mut); line-height:1.4;}
    textarea{
      width:100%; min-height:190px; resize:vertical; border-radius:14px; padding:12px;
      border:1px solid var(--line); background:rgba(255,255,255,.03); color:var(--txt);
      font-size:13px; line-height:1.55;
    }
    .videoWrap{border-radius:16px; overflow:hidden; border:1px solid var(--line); background:#000;}
    video{width:100%; height:auto; display:block; background:#000;}
    .warn{color:#ffcc66;}
    .ok{color:#7CFFB2;}
    .bad{color:#ff7c7c;}
    .spacer{height:6px;}
    .hr{height:1px; background:var(--line); margin:10px 0;}
  </style>

  <!-- ✅ Tesseract v5 CDN (로컬 0KB 파일 절대 사용 안 함) -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>
</head>

<body>
  <div class="wrap">
    <div class="row">
      <div class="pill mono" id="enginePill">OCR 엔진: 대기</div>
      <div class="pill mono" id="camPill">카메라: 대기</div>
      <div class="pill mono" id="ttsPill">음성: 대기</div>
    </div>

    <div class="spacer"></div>

    <div class="row">
      <button class="btn primary" id="btnCam">카메라 시작(필수 1회 탭)</button>
      <button class="btn" id="btnAudio">음성 연결/테스트(필수 1회 탭)</button>
      <button class="btn" id="btnReload">OCR 재시작(새로고침)</button>
      <button class="btn danger" id="btnForceSolve">지금까지로 풀이</button>
    </div>

    <div class="small" style="margin-top:8px;">
      iOS는 카메라/음성이 “첫 탭(사용자 제스처)”이 필요하다. 위 두 버튼은 반드시 한 번 눌러라.<br/>
      OCR이 처음 뜰 때 <span class="warn">kor.traineddata.gz 다운로드</span>가 나오면 <b>허용</b>해야 한다.
    </div>

    <div class="grid">
      <div class="card">
        <div class="title">카메라</div>
        <div class="videoWrap">
          <video id="video" playsinline autoplay muted></video>
        </div>
        <div class="small mono" id="qualityLine" style="margin-top:10px;">
          밝기: - | 흔들림: - | 선명도: -
        </div>
        <div class="small" id="hintLine" style="margin-top:6px;"></div>
      </div>

      <div class="card">
        <div class="title">자동 OCR(누적) → 자동 풀이</div>
        <div class="small mono" id="autoLine">
          누적 길이(공백제외): 0 | 기준 2400 | 평균 신뢰도(대략): 0.0% | 지문 부족: 0초 | 경과: 0초
        </div>
        <div class="hr"></div>
        <div class="title" style="margin-top:0;">실시간 OCR (누적)</div>
        <textarea id="ocrBox" class="mono" placeholder="OCR 누적 텍스트가 여기에 쌓임" readonly></textarea>
      </div>

      <div class="card">
        <div class="title">답안</div>
        <div class="row" style="justify-content:space-between;">
          <div class="small mono" id="solveLine">solve: 대기</div>
          <button class="btn" id="btnStopTTS">음성 중지</button>
        </div>
        <div class="hr"></div>
        <textarea id="ansBox" placeholder="아직 답안 없음" readonly></textarea>
      </div>

      <div class="card">
        <div class="title">수동 입력(테스트용)</div>
        <div class="small">OCR이 안 될 때도, 여기 텍스트로 solve 테스트 가능</div>
        <textarea id="manualBox" placeholder="여기에 텍스트 붙여넣고 ‘지금까지로 풀이’ 누르면 solve 테스트됨"></textarea>
      </div>
    </div>
  </div>

  <script>
    // =========================
    // 너의 우선순위: 속도 X / 안정성+퀄리티 O
    // =========================
    const CONFIG = {
      OCR_INTERVAL_MS: 3500,        // 느리게(안정성)
      MIN_CHARS_FOR_SOLVE: 2400,
      MIN_AVG_CONF_FOR_SOLVE: 60,   // 대략%
      MAX_WAIT_SEC: 10 * 60,        // 10분
      FORCE_SOLVE_AFTER_SEC: 8 * 60,// 8분 지나면 부족해도 자동 풀이 시도
      STABLE_REQUIRED_TICKS: 3,     // 같은 상태가 3번(연속) 유지되면 더 믿음
      SIMILARITY_REPLACE: 0.70,     // 문장 교체 기준(대충)
      SKIP_IF_TOO_DARK: true,
      SKIP_IF_TOO_BLURRY: true,
      DARK_BRIGHTNESS: 55,          // 0~255
      BLUR_MIN_SHARPNESS: 12,       // 대충(기기별 편차)
    };

    // DOM
    const enginePill = document.getElementById('enginePill');
    const camPill    = document.getElementById('camPill');
    const ttsPill    = document.getElementById('ttsPill');
    const video      = document.getElementById('video');
    const ocrBox     = document.getElementById('ocrBox');
    const ansBox     = document.getElementById('ansBox');
    const manualBox  = document.getElementById('manualBox');
    const autoLine   = document.getElementById('autoLine');
    const solveLine  = document.getElementById('solveLine');
    const qualityLine= document.getElementById('qualityLine');
    const hintLine   = document.getElementById('hintLine');

    const btnCam      = document.getElementById('btnCam');
    const btnAudio    = document.getElementById('btnAudio');
    const btnReload   = document.getElementById('btnReload');
    const btnForceSolve = document.getElementById('btnForceSolve');
    const btnStopTTS  = document.getElementById('btnStopTTS');

    // State
    let stream = null;
    let ocrWorker = null;
    let ocrTimer = null;
    let startedAt = Date.now();
    let lastGoodAt = Date.now();
    let shortageSec = 0;
    let solved = false;
    let solving = false;

    // 누적(세그먼트 방식)
    // segments: [{text, conf}]
    let segments = [];
    let stableTicks = 0;
    let lastFingerprint = '';

    // TTS
    let ttsReady = false;
    let currentUtter = null;

    // 캔버스(프레임 캡처)
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    // ---------- UI helpers ----------
    function setPill(el, label, state) {
      // state: ok | warn | bad | ''
      const cls = state === 'ok' ? 'ok' : state === 'warn' ? 'warn' : state === 'bad' ? 'bad' : '';
      el.innerHTML = `${label}: <span class="${cls}">${stateText(label)}</span>`;
      function stateText(label) {
        if (label.includes('OCR')) return engineStateText;
        if (label.includes('카메라')) return camStateText;
        return ttsStateText;
      }
    }
    let engineStateText = '대기';
    let camStateText = '대기';
    let ttsStateText = '대기';

    function updatePills() {
      enginePill.innerHTML = `OCR 엔진: <span class="${engineCls()}">${engineStateText}</span>`;
      camPill.innerHTML    = `카메라: <span class="${camCls()}">${camStateText}</span>`;
      ttsPill.innerHTML    = `음성: <span class="${ttsCls()}">${ttsStateText}</span>`;
      function engineCls(){ return engineStateText.includes('실패') ? 'bad' : engineStateText.includes('로딩') ? 'warn' : engineStateText.includes('준비') ? 'ok' : ''; }
      function camCls(){ return camStateText.includes('실패') ? 'bad' : camStateText.includes('연결') ? 'ok' : camStateText.includes('요청') ? 'warn' : ''; }
      function ttsCls(){ return ttsStateText.includes('실패') ? 'bad' : ttsStateText.includes('준비') ? 'ok' : ttsStateText.includes('대기') ? 'warn' : ''; }
    }

    function nowSec() { return Math.floor((Date.now() - startedAt) / 1000); }

    function stripSpaces(s) { return (s || '').replace(/\s+/g, ''); }
    function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }

    function normalizeText(s) {
      // 안정성 위해: 너무 공격적으로 삭제하지 말고, 공백 정리만
      return (s || '').replace(/\r/g,'').replace(/[ \t]+/g,' ').replace(/\n{3,}/g, '\n\n').trim();
    }

    function charCountNoSpace(s) { return stripSpaces(s).length; }

    function getAllText() {
      return segments.map(x => x.text).join('\n\n');
    }

    function avgConf() {
      if (!segments.length) return 0;
      const sum = segments.reduce((a,b)=>a+(b.conf||0),0);
      return sum / segments.length;
    }

    function updateAutoLine() {
      const total = getAllText();
      const chars = charCountNoSpace(total);
      const conf = avgConf();
      const elapsed = nowSec();
      autoLine.textContent =
        `누적 길이(공백제외): ${chars} | 기준 ${CONFIG.MIN_CHARS_FOR_SOLVE} | 평균 신뢰도(대략): ${conf.toFixed(1)}% | 지문 부족: ${shortageSec}초 | 경과: ${elapsed}초`;
    }

    function setHint(html) { hintLine.innerHTML = html || ''; }

    // ---------- Similarity (간단/가벼운) ----------
    function similarity(a, b) {
      // 3-gram Jaccard
      a = stripSpaces((a||'').toLowerCase());
      b = stripSpaces((b||'').toLowerCase());
      if (!a || !b) return 0;
      const grams = (s) => {
        const set = new Set();
        for (let i=0;i<s.length-2;i++) set.add(s.slice(i,i+3));
        return set;
      };
      const A = grams(a), B = grams(b);
      let inter = 0;
      for (const g of A) if (B.has(g)) inter++;
      const uni = A.size + B.size - inter;
      return uni ? (inter/uni) : 0;
    }

    function upsertSegment(newText, newConf) {
      newText = normalizeText(newText);
      if (!newText) return;

      // 기존 세그먼트 중 가장 비슷한 것 찾기
      let bestIdx = -1;
      let bestSim = 0;
      for (let i=0;i<segments.length;i++){
        const sim = similarity(segments[i].text, newText);
        if (sim > bestSim) { bestSim = sim; bestIdx = i; }
      }

      if (bestSim >= CONFIG.SIMILARITY_REPLACE && bestIdx >= 0) {
        // “교체”: 더 신뢰도 높은 쪽으로
        if ((newConf||0) >= (segments[bestIdx].conf||0)) {
          segments[bestIdx] = { text: newText, conf: newConf };
        }
      } else {
        // 새 페이지/새 블록으로 추가
        segments.push({ text: newText, conf: newConf });
      }
    }

    function fingerprintState() {
      // 안정성 체크: 전체 텍스트 길이 + 마지막 200자
      const all = getAllText();
      const s = stripSpaces(all);
      return `${s.length}:${s.slice(-200)}`;
    }

    // ---------- Camera ----------
    async function startCamera() {
      camStateText = '요청중...'; updatePills();

      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: { ideal: 'environment' },
            width:  { ideal: 1920 },
            height: { ideal: 1080 }
          },
          audio: false
        });
        video.srcObject = stream;
        await video.play();

        camStateText = '연결됨';
        updatePills();
        setHint('<span class="ok">카메라 연결 완료</span>');
      } catch (e) {
        camStateText = '실패';
        updatePills();
        setHint('<span class="bad">카메라 권한/설정 문제. iOS: 설정 → Safari → 카메라 허용 확인</span>');
        console.error(e);
      }
    }

    function stopCamera() {
      if (stream) {
        stream.getTracks().forEach(t => t.stop());
        stream = null;
      }
      camStateText = '대기';
      updatePills();
    }

    // ---------- Frame Quality (간단) ----------
    function measureFrameQuality() {
      if (!video.videoWidth || !video.videoHeight) return null;

      const w = Math.min(video.videoWidth, 1280);
      const scale = w / video.videoWidth;
      const h = Math.floor(video.videoHeight * scale);

      canvas.width = w;
      canvas.height = h;
      ctx.drawImage(video, 0, 0, w, h);

      const img = ctx.getImageData(0, 0, w, h);
      const data = img.data;

      // 밝기 평균
      let sum = 0;
      for (let i=0;i<data.length;i+=4) {
        sum += (data[i] + data[i+1] + data[i+2]) / 3;
      }
      const brightness = sum / (data.length/4);

      // 선명도(가벼운 edge measure)
      // 인접 픽셀 차이 평균(간단)
      let sharp = 0;
      const step = 8; // 샘플링(가벼움)
      for (let y=0; y<h-step; y+=step) {
        for (let x=0; x<w-step; x+=step) {
          const i1 = (y*w + x)*4;
          const i2 = (y*w + (x+step))*4;
          const i3 = ((y+step)*w + x)*4;
          const g1 = (data[i1]+data[i1+1]+data[i1+2])/3;
          const g2 = (data[i2]+data[i2+1]+data[i2+2])/3;
          const g3 = (data[i3]+data[i3+1]+data[i3+2])/3;
          sharp += Math.abs(g1-g2) + Math.abs(g1-g3);
        }
      }
      // 정규화
      const samples = Math.floor(h/step) * Math.floor(w/step);
      const sharpness = samples ? (sharp / samples) : 0;

      // 흔들림 점수(이전 프레임과 비교) — 여기선 간단히 “선명도 낮으면 흔들림 높다”로 대체
      const shake = Math.max(0, 100 - sharpness*5);

      qualityLine.textContent = `밝기: ${brightness.toFixed(0)} | 흔들림: ${shake.toFixed(0)} | 선명도: ${sharpness.toFixed(1)}`;

      return { brightness, sharpness, shake, w, h };
    }

    // ---------- OCR Worker ----------
    async function getOcrWorker() {
      if (ocrWorker) return ocrWorker;

      engineStateText = '로딩중 (1/4 createWorker...)';
      updatePills();

      // ✅ 타임아웃 절대 없음 (너가 싫어하는 TIMEOUT 제거)
      // ✅ 로컬 0KB 파일 절대 안 씀 (CDN만 사용)
      const worker = await Tesseract.createWorker('kor', 1, {
        workerPath: 'https://unpkg.com/tesseract.js@5/dist/worker.min.js',
        corePath: 'https://unpkg.com/tesseract.js-core@5.0.3/tesseract-core.wasm.js',
        langPath: 'https://tessdata.projectnaptha.com/4.0.0',
        logger: (m) => {
          // m.status: "loading tesseract core" / "initializing api" / ...
          if (m && m.status) {
            engineStateText = `로딩중... (${m.status}${m.progress!=null ? ' ' + Math.round(m.progress*100) + '%' : ''})`;
            updatePills();
          }
        }
      });

      engineStateText = '로딩중 (2/4 setParameters...)';
      updatePills();

      await worker.setParameters({
        tessedit_pageseg_mode: 3,
        preserve_interword_spaces: '1',
      });

      engineStateText = '준비됨';
      updatePills();

      ocrWorker = worker;
      return ocrWorker;
    }

    async function terminateOcrWorker() {
      if (ocrWorker) {
        try { await ocrWorker.terminate(); } catch(e) {}
      }
      ocrWorker = null;
      engineStateText = '대기';
      updatePills();
    }

    // ---------- OCR loop ----------
    async function doOcrOnce() {
      if (!stream || !video.videoWidth) return;

      const q = measureFrameQuality();
      if (!q) return;

      // 너무 어두우면 스킵(퀄리티 우선)
      if (CONFIG.SKIP_IF_TOO_DARK && q.brightness < CONFIG.DARK_BRIGHTNESS) {
        setHint('<span class="warn">너무 어두움 → 조명/각도 조정</span>');
        return;
      }
      // 너무 흐리면 스킵(퀄리티 우선)
      if (CONFIG.SKIP_IF_TOO_BLURRY && q.sharpness < CONFIG.BLUR_MIN_SHARPNESS) {
        setHint('<span class="warn">너무 흔들림/흐림 → 잠깐 멈추고 다시</span>');
        return;
      }

      setHint('');

      let worker;
      try {
        worker = await getOcrWorker();
      } catch (e) {
        engineStateText = '실패';
        updatePills();
        setHint('<span class="bad">OCR 엔진 로딩 실패. (iOS에서 kor.traineddata 다운로드 허용했는지 확인)</span>');
        console.error(e);
        return;
      }

      // 캡처 해상도: 너무 크면 느려지고 실패 가능 → 안정성 위해 적당히
      const capW = 1280;
      const scale = capW / video.videoWidth;
      const capH = Math.floor(video.videoHeight * scale);

      canvas.width = capW;
      canvas.height = capH;
      ctx.drawImage(video, 0, 0, capW, capH);

      engineStateText = '인식중...';
      updatePills();

      try {
        const { data } = await worker.recognize(canvas);

        const text = normalizeText(data?.text || '');
        // 평균 conf: 단어 단위 confidence 평균
        let conf = 0;
        if (data?.words?.length) {
          const s = data.words.reduce((a,w)=>a+(w.confidence||0),0);
          conf = s / data.words.length;
        } else {
          conf = data?.confidence || 0;
        }

        // conf는 0~100
        conf = clamp(conf, 0, 100);

        if (text && charCountNoSpace(text) >= 30) {
          upsertSegment(text, conf);
          ocrBox.value = getAllText();
          lastGoodAt = Date.now();
        }

        engineStateText = '준비됨';
        updatePills();

        // 안정성 체크
        const fp = fingerprintState();
        if (fp === lastFingerprint) stableTicks++;
        else stableTicks = 0;
        lastFingerprint = fp;

        // 지문 부족 시간
        shortageSec = Math.floor((Date.now() - lastGoodAt) / 1000);

        updateAutoLine();

        // 자동 solve 트리거
        const total = getAllText();
        const totalChars = charCountNoSpace(total);
        const confAvg = avgConf();
        const elapsed = nowSec();

        const enough =
          totalChars >= CONFIG.MIN_CHARS_FOR_SOLVE &&
          confAvg >= CONFIG.MIN_AVG_CONF_FOR_SOLVE &&
          stableTicks >= CONFIG.STABLE_REQUIRED_TICKS;

        const forced =
          elapsed >= CONFIG.FORCE_SOLVE_AFTER_SEC && stableTicks >= 1;

        if (!solved && !solving && (enough || forced)) {
          await callSolve(total, enough ? 'AUTO' : 'FORCE_AFTER_TIME');
        }

        // 최대 대기 시간 지나면 그냥 풀이 시도(부족해도)
        if (!solved && !solving && elapsed >= CONFIG.MAX_WAIT_SEC) {
          await callSolve(total, 'MAX_WAIT');
        }

      } catch (e) {
        engineStateText = '실패';
        updatePills();
        setHint('<span class="bad">OCR 실패(일시적). 화면을 더 꽉 차게/흔들림 줄이기</span>');
        console.error(e);
      }
    }

    function startOcrLoop() {
      stopOcrLoop();
      startedAt = Date.now();
      lastGoodAt = Date.now();
      shortageSec = 0;
      solved = false;
      solving = false;
      stableTicks = 0;
      lastFingerprint = '';
      segments = [];
      ocrBox.value = '';
      ansBox.value = '';
      solveLine.textContent = 'solve: 대기';
      updateAutoLine();

      ocrTimer = setInterval(doOcrOnce, CONFIG.OCR_INTERVAL_MS);
      doOcrOnce();
    }

    function stopOcrLoop() {
      if (ocrTimer) clearInterval(ocrTimer);
      ocrTimer = null;
    }

    // ---------- Solve ----------
    async function callSolve(text, reason) {
      const payloadText = normalizeText(text || '');

      // OCR이 비어있으면 수동 입력으로라도
      const fallback = normalizeText(manualBox.value || '');
      const finalText = payloadText.length ? payloadText : fallback;

      if (!finalText || charCountNoSpace(finalText) < 80) {
        solveLine.textContent = 'solve: 텍스트가 너무 짧음';
        return;
      }

      solving = true;
      solveLine.textContent = `solve: 요청중... (${reason})`;

      try {
        const res = await fetch('/.netlify/functions/solve', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text: finalText, reason })
        });

        const data = await res.json().catch(()=> ({}));

        if (!res.ok) {
          solveLine.textContent = `solve: 실패 (${res.status})`;
          ansBox.value = (data && data.error) ? String(data.error) : 'solve 실패';
          solving = false;
          return;
        }

        const answer = (data && data.answer) ? String(data.answer) : '';
        ansBox.value = answer || '답안이 비어있음';
        solveLine.textContent = 'solve: 완료';
        solved = true;
        solving = false;

        // 자동 TTS: 답안 뜨면 읽기
        speakAnswer(answer);

      } catch (e) {
        solveLine.textContent = 'solve: 네트워크 오류';
        ansBox.value = String(e);
        solving = false;
      }
    }

    // ---------- TTS ----------
    function initTTS() {
      try {
        if (!('speechSynthesis' in window)) {
          ttsReady = false;
          ttsStateText = '실패(미지원)';
          updatePills();
          return;
        }

        // iOS는 첫 탭에서 음성 한 번 재생해야 “잠금 해제”가 되는 경우가 많음
        const u = new SpeechSynthesisUtterance('음성 준비 완료');
        u.lang = 'ko-KR';
        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);

        ttsReady = true;
        ttsStateText = '준비됨';
        updatePills();

      } catch (e) {
        ttsReady = false;
        ttsStateText = '실패';
        updatePills();
      }
    }

    function stopTTS() {
      try { window.speechSynthesis.cancel(); } catch(e) {}
      currentUtter = null;
    }

    function speakAnswer(text) {
      if (!ttsReady) return;
      const t = (text || '').trim();
      if (!t) return;

      stopTTS();
      const u = new SpeechSynthesisUtterance(t);
      u.lang = 'ko-KR';
      // 속도/톤은 “정돈된 낭독” 느낌으로 무리 없이
      u.rate = 1.0;
      u.pitch = 1.0;

      currentUtter = u;
      window.speechSynthesis.speak(u);
    }

    // ---------- Buttons ----------
    btnCam.addEventListener('click', async () => {
      await startCamera();
      // 카메라가 켜진 다음 OCR 시작
      if (camStateText === '연결됨') startOcrLoop();
    });

    btnAudio.addEventListener('click', () => initTTS());

    btnReload.addEventListener('click', async () => {
      stopOcrLoop();
      await terminateOcrWorker();
      startOcrLoop();
    });

    btnForceSolve.addEventListener('click', async () => {
      const text = getAllText();
      await callSolve(text, 'MANUAL_FORCE');
    });

    btnStopTTS.addEventListener('click', () => stopTTS());

    // ---------- Init ----------
    engineStateText = '대기';
    camStateText = '대기';
    ttsStateText = '대기';
    updatePills();
    updateAutoLine();
  </script>
</body>
</html>
