<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 16px; }
    #status { white-space: pre-wrap; padding: 10px; border: 1px solid #ddd; border-radius: 8px; min-height: 110px; }
    button { padding: 12px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; font-size: 16px; }
    button:disabled { opacity: 0.5; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; margin: 12px 0; }
    textarea { width: 100%; min-height: 140px; margin-top: 10px; }
    .small { font-size: 12px; color: #666; line-height: 1.45; }
    .camWrap { width: 100%; max-width: 560px; }
    video { width: 100%; border-radius: 12px; background: #000; display:block; }
  </style>
</head>
<body>
  <h2>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</h2>

  <div id="status">ëŒ€ê¸° ì¤‘</div>

  <div class="row">
    <button id="btnAudio">ğŸ”Š ì˜¤ë””ì˜¤ ì¤€ë¹„(í•œ ë²ˆë§Œ)</button>
    <button id="btnStart">ğŸ“¸ ìë™ ì‹œì‘</button>
    <button id="btnStop" disabled>â›” ì¤‘ì§€</button>
    <button id="btnReplay" disabled>ğŸ” ì •ë‹µ ë‹¤ì‹œë“£ê¸°</button>
  </div>

  <div class="small">
    - ë§ˆì§€ë§‰ í˜ì´ì§€ì— <b>XVRTH</b> ë˜ëŠ” <b>XURTH</b> ë¥¼ êµµê³  í¬ê²Œ ì ìœ¼ë©´ ìë™ìœ¼ë¡œ OCR ì¢…ë£Œ í›„ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤(ì˜ì–´ OCRë¡œ ì•ˆì •).<br/>
    - iOS ë¬´ìŒëª¨ë“œ(ì‚¬ì¼ëŸ°íŠ¸)ë©´ TTSê°€ ì•ˆ ë“¤ë¦´ ìˆ˜ ìˆë‹¤. ë¬´ìŒ í•´ì œ + ë³¼ë¥¨ ì˜¬ë ¤ë¼.<br/>
    - ë°•ìŠ¤/ê°€ì´ë“œ ì—†ìŒ: í™”ë©´ ì–´ë””ì— ìˆì–´ë„ ì¢…ì´(ë°ì€ ì˜ì—­)ë¥¼ ìë™ìœ¼ë¡œ ì°¾ì•„ í¬ë¡­â†’OCR í•œë‹¤.
  </div>

  <div class="camWrap" style="margin-top:12px;">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <h3 style="margin-top:16px;">OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸)</h3>
  <textarea id="ocrBox" placeholder="ìë™ OCR ê²°ê³¼ê°€ ëˆ„ì ëœë‹¤(ìˆ˜ë™ ìˆ˜ì • ê¸ˆì§€)."></textarea>

  <h3 style="margin-top:16px;">ì •ë‹µ(ë””ë²„ê·¸)</h3>
  <textarea id="ansBox" placeholder="ìë™ í’€ì´ ê²°ê³¼ê°€ ì—¬ê¸°ì— ì¶œë ¥ëœë‹¤."></textarea>

<script>
(() => {
  const OCR_URL   = "/.netlify/functions/ocr";
  const SOLVE_URL = "/.netlify/functions/solve";

  // === ì´¬ì˜/ì¸ì‹ ===
  const SHOTS_PER_PAGE = 3;
  const SHOT_GAP_MS = 120;             // í˜ì´ì§€ë‹¹ 3ìƒ· ì‚¬ì´ ëŒ€ê¸°(5ì´ˆ ì—†ìŒ)
  const MAX_PAGES = 40;
  const MAX_RETRY_PER_PAGE = 4;

  // í˜ì´ì§€ ë„˜ê¹€ ìŒì„± í›„ ë‹¤ìŒ í˜ì´ì§€ ì´¬ì˜ê¹Œì§€
  const TURN_PAGE_WAIT_MS = 650;

  // OCR í’ˆì§ˆ ê¸°ì¤€(í˜ì´ì§€ ì „ì²´ í…ìŠ¤íŠ¸ê°€ ì¶©ë¶„í•´ì•¼)
  const MIN_TEXT_LEN = 650;
  const PASSAGE_LEN_OK = 1250;
  const MIN_QNUM_HITS = 2;

  // ì¢…ì´(ë°ì€ ì˜ì—­) ë©´ì ì´ ë„ˆë¬´ ì‘ìœ¼ë©´ â€œê°€ê¹Œì´â€
  const MIN_PAPER_AREA_RATIO = 0.22;  // A4 ì—°ìŠµ ê¸°ì¤€

  // ì¢…ë£Œ í† í°(ì˜ì–´ë¡œ ì“°ëŠ” ê²Œ ì•ˆì •)
  const STOP_TOKENS = ["XVRTH", "XURTH"];

  // === TTS ===
  const ANSWER_ROUNDS = 4;             // ì •ë‹µ 4íšŒ
  const BETWEEN_ANS_MS = 2000;         // 1ë²ˆ~2ë²ˆ ì‚¬ì´ 2ì´ˆ
  const BETWEEN_ROUND_MS = 600;

  // === ì´ë¯¸ì§€ ì „ì†¡ ìš©ëŸ‰/ì†ë„ ì¡°ì ˆ ===
  const JPEG_QUALITY = 0.85;
  const OCR_MAX_SIDE = 1600;           // í¬ë¡­ í›„ ìµœëŒ€ ë³€ ê¸¸ì´

  // === ìƒíƒœ ===
  let running = false;
  let stream = null;
  let currentPage = 1;

  // pages: {page, text, conf, qnums:Set}
  let pages = [];
  let allText = "";

  let audioReady = false;
  let koVoice = null;
  let lastAnswers = null;

  // === DOM ===
  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnAudio = document.getElementById("btnAudio");
  const btnStart = document.getElementById("btnStart");
  const btnStop = document.getElementById("btnStop");
  const btnReplay = document.getElementById("btnReplay");
  const ocrBox = document.getElementById("ocrBox");
  const ansBox = document.getElementById("ansBox");

  function log(msg) {
    const t = new Date().toLocaleTimeString("ko-KR", { hour12:false });
    statusEl.textContent = `[${t}] ${msg}\n` + statusEl.textContent;
    console.log(msg);
  }
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // ===================== iOS ì˜¤ë””ì˜¤ ì–¸ë½ =====================
  async function beep() {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      const ctx = new AC();
      await ctx.resume().catch(()=>{});
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = 880;
      gain.gain.value = 0.08;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.08);
    } catch (_) {}
  }

  function pickKoreanVoice() {
    const voices = speechSynthesis.getVoices() || [];
    const ko = voices.filter(v => (v.lang || "").toLowerCase().startsWith("ko"));
    const preferred = ko.find(v => /yuna|ìœ ë‚˜|ì„œí˜„|ì§€ì€|ì•„ë¦¬/i.test(v.name));
    koVoice = preferred || ko[0] || null;
    if (koVoice) log(`TTS voice: ${koVoice.name} (${koVoice.lang})`);
    else log("TTS voice ì„ íƒ ì‹¤íŒ¨");
  }

  function speak(text) {
    return new Promise(resolve => {
      try {
        const u = new SpeechSynthesisUtterance(String(text));
        u.lang = "ko-KR";
        u.rate = 1.0;
        if (koVoice) u.voice = koVoice;
        u.onend = resolve;
        u.onerror = resolve;
        speechSynthesis.speak(u);
      } catch (_) { resolve(); }
    });
  }

  async function unlockAudio() {
    if (audioReady) return true;
    await beep();
    audioReady = true;
    log("AudioContext ì–¸ë½ ì™„ë£Œ");
    try { speechSynthesis.cancel(); } catch(_) {}
    pickKoreanVoice();
    return true;
  }

  async function speakTurnPage(page) {
    await speak(`í˜ì´ì§€ ${page} ì¸ì‹ ì™„ë£Œ. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë„˜ê²¨ ì£¼ì„¸ìš”.`);
    await sleep(TURN_PAGE_WAIT_MS);
  }

  function toLetter(n){ return ["A","B","C","D","E"][Number(n)-1] || ""; }

  async function speakAnswers(answerMap) {
    const keys = Object.keys(answerMap||{}).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);
    try { speechSynthesis.cancel(); } catch(_) {}

    for (let r=1; r<=ANSWER_ROUNDS; r++) {
      for (const q of keys) {
        const a = toLetter(answerMap[String(q)]);
        if (!a) continue;
        await speak(`${q}ë²ˆ ${a}`);
        await sleep(BETWEEN_ANS_MS);
      }
      await sleep(BETWEEN_ROUND_MS);
    }
  }

  // ===================== Camera (ì¤Œ ê°•ì œ X, 1.0 ê³ ì •) =====================
  async function getStreamWithFallback() {
    const tries = [
      { video: { facingMode: { ideal: "environment" }, width:{ ideal:1920 }, height:{ ideal:1080 } }, audio:false },
      { video: { facingMode: "environment" }, audio:false },
      { video: true, audio:false }
    ];
    let lastErr = null;
    for (const c of tries) {
      try { return await navigator.mediaDevices.getUserMedia(c); }
      catch (e) { lastErr = e; }
    }
    throw lastErr || new Error("getUserMedia failed");
  }

  async function applyBestCameraSettings() {
    try {
      const track = stream?.getVideoTracks?.()[0];
      if (!track || !track.getCapabilities || !track.applyConstraints) return;

      const caps = track.getCapabilities();
      const adv = [];

      // âœ… "ì¤Œ ì•ˆ í•¨" = 1.0ìœ¼ë¡œ ê³ ì •(ê°€ëŠ¥í•˜ë©´)
      if (caps.zoom) {
        const z = Math.min(caps.zoom.max, Math.max(caps.zoom.min, 1.0));
        adv.push({ zoom: z });
        log(`ì¤Œ ì„¤ì •: ${z}`);
      }
      if (caps.focusMode && Array.isArray(caps.focusMode) && caps.focusMode.includes("continuous")) {
        adv.push({ focusMode: "continuous" });
      }
      if (caps.exposureMode && Array.isArray(caps.exposureMode) && caps.exposureMode.includes("continuous")) {
        adv.push({ exposureMode: "continuous" });
      }
      if (caps.whiteBalanceMode && Array.isArray(caps.whiteBalanceMode) && caps.whiteBalanceMode.includes("continuous")) {
        adv.push({ whiteBalanceMode: "continuous" });
      }

      if (adv.length > 0) await track.applyConstraints({ advanced: adv }).catch(()=>{});
    } catch (_) {}
  }

  async function startCamera() {
    if (stream) return;
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error("ì´ ë¸Œë¼ìš°ì €ëŠ” ì¹´ë©”ë¼ APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŒ");
    }

    stream = await getStreamWithFallback();
    video.srcObject = stream;

    try { await video.play(); } catch (_) {}

    const t0 = Date.now();
    while (video.readyState < 2 && Date.now() - t0 < 2000) {
      await sleep(60);
    }

    await applyBestCameraSettings();
    await sleep(200);

    log(`ì¹´ë©”ë¼ OK (${video.videoWidth}x${video.videoHeight})`);
  }

  // ===================== Paper detect + crop + resize =====================
  function detectPaperBoxOnFrame(srcCanvas) {
    const w = srcCanvas.width, h = srcCanvas.height;

    const targetW = 320;
    const scale = targetW / w;
    const dw = targetW;
    const dh = Math.max(1, Math.round(h * scale));

    const dcv = document.createElement("canvas");
    dcv.width = dw; dcv.height = dh;
    const dctx = dcv.getContext("2d", { willReadFrequently:true });
    dctx.drawImage(srcCanvas, 0, 0, w, h, 0, 0, dw, dh);

    const img = dctx.getImageData(0, 0, dw, dh);
    const data = img.data;

    let sum = 0;
    const n = dw * dh;
    for (let i=0; i<data.length; i+=4) {
      const r = data[i], g = data[i+1], b = data[i+2];
      const y = (r*0.2126 + g*0.7152 + b*0.0722);
      sum += y;
    }
    const mean = sum / n;
    let thr = Math.max(195, Math.min(240, mean + 28));

    let minX = dw, minY = dh, maxX = -1, maxY = -1;
    let hit = 0;

    for (let y=0; y<dh; y++) {
      for (let x=0; x<dw; x++) {
        const idx = (y*dw + x) * 4;
        const r = data[idx], g = data[idx+1], b = data[idx+2];
        const lum = (r*0.2126 + g*0.7152 + b*0.0722);
        const maxc = Math.max(r,g,b), minc = Math.min(r,g,b);
        const chroma = maxc - minc;

        if (lum >= thr && chroma < 42) {
          hit++;
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
      }
    }

    if (hit < n * 0.01 || maxX < 0) return null;

    const bw = (maxX - minX + 1);
    const bh = (maxY - minY + 1);
    const areaRatio = (bw*bh)/(dw*dh);

    if (bw < dw * 0.25 || bh < dh * 0.25) {
      return { box: null, areaRatio };
    }

    const mx = Math.round(bw * 0.06);
    const my = Math.round(bh * 0.06);

    let x0 = Math.max(0, minX - mx);
    let y0 = Math.max(0, minY - my);
    let x1 = Math.min(dw-1, maxX + mx);
    let y1 = Math.min(dh-1, maxY + my);

    const rx = Math.floor(x0 / scale);
    const ry = Math.floor(y0 / scale);
    const rw = Math.floor((x1 - x0 + 1) / scale);
    const rh = Math.floor((y1 - y0 + 1) / scale);

    return { box: { x: rx, y: ry, w: rw, h: rh }, areaRatio };
  }

  function resizeCanvasIfNeeded(srcCanvas, maxSide) {
    const w = srcCanvas.width, h = srcCanvas.height;
    const m = Math.max(w, h);
    if (m <= maxSide) return srcCanvas;

    const scale = maxSide / m;
    const nw = Math.max(1, Math.round(w * scale));
    const nh = Math.max(1, Math.round(h * scale));
    const out = document.createElement("canvas");
    out.width = nw; out.height = nh;
    const ctx = out.getContext("2d");
    ctx.drawImage(srcCanvas, 0, 0, w, h, 0, 0, nw, nh);
    return out;
  }

  function captureAutoPaperCropBase64Jpeg(quality=0.85) {
    const w = video.videoWidth, h = video.videoHeight;
    if (!w || !h) throw new Error("ì¹´ë©”ë¼ í”„ë ˆì„ í¬ê¸° 0(ìŠ¤íŠ¸ë¦¼ ì¤€ë¹„ ì•ˆ ë¨)");

    const src = document.createElement("canvas");
    src.width = w; src.height = h;
    const sctx = src.getContext("2d");
    sctx.drawImage(video, 0, 0, w, h);

    const det = detectPaperBoxOnFrame(src);

    // í´ë°±: ì¢…ì´ ëª»ì°¾ìœ¼ë©´ ì „ì²´
    let cropCanvas = src;
    let areaRatio = det?.areaRatio ?? 0;

    if (det && det.box) {
      const { x, y, w:rw, h:rh } = det.box;

      const cx = Math.max(0, Math.min(w-1, x));
      const cy = Math.max(0, Math.min(h-1, y));
      const cw = Math.max(1, Math.min(w - cx, rw));
      const ch = Math.max(1, Math.min(h - cy, rh));

      const crop = document.createElement("canvas");
      crop.width = cw; crop.height = ch;
      const cctx = crop.getContext("2d");
      cctx.drawImage(src, cx, cy, cw, ch, 0, 0, cw, ch);
      cropCanvas = crop;
    }

    cropCanvas = resizeCanvasIfNeeded(cropCanvas, OCR_MAX_SIDE);
    return { dataUrl: cropCanvas.toDataURL("image/jpeg", quality), areaRatio };
  }

  // ===================== OCR call (HTTP ìƒíƒœ/ì—ëŸ¬ ë¡œê·¸ í¬í•¨) =====================
  async function callOcr(dataUrl, pageIndex) {
    try {
      const payload = { image: dataUrl, pageIndex, mode: "dual" };

      const res = await fetch(OCR_URL, {
        method: "POST",
        headers: { "Content-Type":"application/json" },
        body: JSON.stringify(payload)
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();

      if (!ct.includes("application/json")) {
        const raw = await res.text().catch(()=> "");
        log(`OCR HTTP ${res.status} non-JSON: ${raw.slice(0,120).replace(/\s+/g," ")}`);
        return { ok:false, text:"", conf:0 };
      }

      const j = await res.json().catch(()=>null);

      if (!res.ok) {
        log(`OCR HTTP ${res.status} JSON: ${JSON.stringify(j).slice(0,160)}`);
        return { ok:false, text:"", conf:0 };
      }

      if (!j || !j.ok) {
        log(`OCR JSON ok=false: ${JSON.stringify(j).slice(0,180)}`);
        return { ok:false, text:"", conf:0 };
      }

      return { ok:true, text:String(j.text||""), conf:Number(j.conf||0) };
    } catch (e) {
      log(`OCR fetch exception: ${String(e?.message || e)}`);
      return { ok:false, text:"", conf:0 };
    }
  }

  // ===================== í…ìŠ¤íŠ¸ ìœ í‹¸ =====================
  const normalizeNoSpace = (s)=>String(s||"").replace(/\s+/g,"").trim();

  function detectStop(text) {
    const t = normalizeNoSpace(text);
    for (const tok of STOP_TOKENS) {
      if (t.includes(normalizeNoSpace(tok))) return tok;
    }
    return null;
  }

  function qnumHits(text) {
    const m = String(text||"").match(/(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g);
    return m ? m.length : 0;
  }

  function extractQnumsFromPage(text) {
    const out = new Set();
    const re = /(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g;
    let m;
    const t = String(text||"");
    while ((m = re.exec(t)) !== null) out.add(parseInt(m[1],10));
    return out;
  }

  function qualityOk(text) {
    const len = String(text||"").length;
    const hits = qnumHits(text);
    if (len >= PASSAGE_LEN_OK) return true;
    if (len >= MIN_TEXT_LEN && hits >= MIN_QNUM_HITS) return true;
    return false;
  }

  function rebuildAllText() {
    allText = "";
    for (const p of pages) {
      allText += `[PAGE ${p.page}] (conf=${(p.conf||0).toFixed(1)})\n${p.text}\n\n`;
    }
    ocrBox.value = allText;
  }

  // ===================== í˜ì´ì§€ OCR(3ìƒ· ì¤‘ ìµœê³  ì„ íƒ) =====================
  async function ocrOnePage(pageIndex) {
    let best = null;

    for (let shot=1; shot<=SHOTS_PER_PAGE; shot++) {
      if (!running) return null;
      await sleep(SHOT_GAP_MS);

      const cap = captureAutoPaperCropBase64Jpeg(JPEG_QUALITY);
      const r = await callOcr(cap.dataUrl, pageIndex);

      const text = r.ok ? r.text : "";
      const conf = r.ok ? r.conf : 0;
      const hits = qnumHits(text);

      const area = cap.areaRatio || 0;
      const areaPenalty = (area > 0 && area < MIN_PAPER_AREA_RATIO) ? -80 : 0;

      const score = (text.length/50) + (hits*30) + (conf*2) + areaPenalty;
      const stopTok = detectStop(text);

      log(`OCR ${r.ok?"OK":"FAIL"} page=${pageIndex} shot=${shot} len=${text.length} conf=${conf} hits=${hits} paperArea=${(area*100).toFixed(1)}% score=${score.toFixed(1)}`);

      const cand = { shot, text, conf, score, stopTok, areaRatio: area };
      if (!best || cand.score > best.score) best = cand;

      if (cand.stopTok) return cand;
    }

    if (!best) return null;
    best.stopTok = detectStop(best.text);
    return best;
  }

  async function recapturePages(targetPages) {
    for (const p of targetPages) {
      if (!running) return;
      await speak(`ì¸ì‹ì´ ì•½í•œ í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤. í˜ì´ì§€ ${p}ë¥¼ ë” ê°€ê¹Œì´ ë³´ì—¬ ì£¼ì„¸ìš”.`);
      await sleep(200);

      let ok = false;
      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) return;

        log(`ì¬ì´¬ì˜: í˜ì´ì§€ ${p} ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        const r = await ocrOnePage(p);
        if (!r) break;

        if (r.areaRatio > 0 && r.areaRatio < MIN_PAPER_AREA_RATIO) {
          await speak(`í˜ì´ì§€ ${p}ê°€ ë„ˆë¬´ ì‘ê²Œ ë³´ì…ë‹ˆë‹¤. íœ´ëŒ€í°ì„ ë” ê°€ê¹Œì´ ê°€ì ¸ì˜¤ì„¸ìš”.`);
          continue;
        }

        if (r.stopTok || qualityOk(r.text)) {
          const idx = pages.findIndex(x => x.page === p);
          const qnums = extractQnumsFromPage(r.text);
          const entry = { page:p, text:r.text, conf:r.conf, qnums };
          if (idx >= 0) pages[idx] = entry; else pages.push(entry);
          pages.sort((a,b)=>a.page-b.page);
          rebuildAllText();
          ok = true;
          break;
        }

        await speak(`í˜ì´ì§€ ${p} ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ì¡°ê¸ˆ ë” ê°€ê¹Œì´ ë³´ì—¬ ì£¼ì„¸ìš”.`);
      }

      if (!ok) {
        await speak(`í˜ì´ì§€ ${p}ê°€ ê³„ì† ì•ˆ ì½í™ë‹ˆë‹¤. ì¡°ëª… ë°˜ì‚¬ë¥¼ ì—†ì• ê³  ê°ë„ë¥¼ ë°”ê¿” ì£¼ì„¸ìš”.`);
        throw new Error(`ì¬ì´¬ì˜ ì‹¤íŒ¨(page=${p})`);
      }
    }
  }

  // ===================== ë¬¸ì œ ì„¸ê·¸ë¨¼íŠ¸ ì¶”ì¶œ(ì™„ì „ ìë™) =====================
  function stripPageHeaders(t) {
    return String(t||"").replace(/\[PAGE\s+\d+\][^\n]*\n/g, "");
  }

  function extractQuestionSegmentsFromAllText(allTextRaw) {
    const t = stripPageHeaders(allTextRaw);

    const re = /(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g;
    const hits = [];
    let m;
    while ((m = re.exec(t)) !== null) {
      hits.push({ idx: m.index + (m[0].startsWith("\n") ? 1 : 0), num: parseInt(m[1],10) });
    }
    if (hits.length === 0) return [];

    const segs = [];
    for (let i=0; i<hits.length; i++) {
      const start = hits[i].idx;
      const end = (i+1 < hits.length) ? hits[i+1].idx : t.length;
      const num = hits[i].num;
      let seg = t.slice(start, end).trim();

      // ë„ˆë¬´ ê¸¸ë©´ ì˜ë¼ì„œ í† í°/ì‹œê°„ ì ˆì•½(ëŒ€ê°œ ë¬¸ì œ í•˜ë‚˜ê°€ 1000ì ë‚´)
      if (seg.length > 2200) seg = seg.slice(0, 2200);

      segs.push({ number: num, text: seg });
    }
    // ì¤‘ë³µ ë²ˆí˜¸ ì œê±°(ì²«ë²ˆì§¸ë§Œ)
    const seen = new Set();
    return segs.filter(s => !seen.has(s.number) && seen.add(s.number));
  }

  function weakQuestionNums(segs) {
    // ë„ˆë¬´ ì§§ìœ¼ë©´ OCRì´ ê¹¨ì¡Œì„ ê°€ëŠ¥ì„± ë†’ìŒ
    return segs.filter(s => (s.text||"").length < 90).map(s => s.number);
  }

  function mapQuestionsToPages(qNums) {
    const pagesSet = new Set();
    for (const q of qNums) {
      for (const p of pages) {
        if (p.qnums && p.qnums.has(q)) pagesSet.add(p.page);
      }
    }
    return Array.from(pagesSet).sort((a,b)=>a-b);
  }

  // ===================== Solve (ë°°ì¹˜ë¡œ ìª¼ê°œì„œ ì‹œê°„ì´ˆê³¼ ë°©ì§€) =====================
  async function callSolveBatch(items) {
    const res = await fetch(SOLVE_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ items })
    });

    const ct = (res.headers.get("content-type") || "").toLowerCase();
    if (!ct.includes("application/json")) {
      const raw = await res.text().catch(()=> "");
      return { ok:false, error:`Solve non-JSON HTTP ${res.status}`, detail: raw.slice(0,180) };
    }

    const j = await res.json().catch(()=>null);
    if (!j) return { ok:false, error:"Solve JSON parse failed" };
    return j;
  }

  function answersToText(ansNumMap) {
    const keys = Object.keys(ansNumMap||{}).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);
    return keys.map(k => `${k}ë²ˆ: ${toLetter(ansNumMap[String(k)])}`).join("\n");
  }

  function chunkArray(arr, size) {
    const out = [];
    for (let i=0; i<arr.length; i+=size) out.push(arr.slice(i, i+size));
    return out;
  }

  async function solveAllFromSegments(segs) {
    const batches = chunkArray(segs, 8);  // 8ë¬¸í•­ì”©(ë¹ ë¥´ê²Œ)
    const out = {};
    for (let i=0; i<batches.length; i++) {
      if (!running) throw new Error("stopped");
      log(`ì •ë‹µ ê³„ì‚°: ë°°ì¹˜ ${i+1}/${batches.length} (${batches[i][0].number}~${batches[i][batches[i].length-1].number})`);

      // ë°°ì¹˜ 1íšŒ ì‹¤íŒ¨í•˜ë©´ ìë™ 1íšŒ ì¬ì‹œë„
      let r = await callSolveBatch(batches[i]);
      if (!r.ok) {
        log(`SOLVE ë°°ì¹˜ ì‹¤íŒ¨(1): ${r.error || "unknown"} ${String(r.detail||"").slice(0,120)}`);
        await sleep(300);
        r = await callSolveBatch(batches[i]);
      }

      if (!r.ok || !r.answers) {
        throw new Error(`SOLVE ë°°ì¹˜ ì‹¤íŒ¨: ${r.error || "unknown"}`);
      }

      for (const [k,v] of Object.entries(r.answers)) out[String(parseInt(k,10))] = parseInt(v,10);
    }
    return out;
  }

  // ===================== Main =====================
  async function runAuto() {
    running = true;
    btnStart.disabled = true;
    btnStop.disabled = false;
    btnReplay.disabled = true;

    pages = [];
    allText = "";
    currentPage = 1;
    ocrBox.value = "";
    ansBox.value = "";
    lastAnswers = null;

    await unlockAudio();
    pickKoreanVoice();

    await startCamera();
    await speak("ìë™ ì´¬ì˜ì„ ì‹œì‘í•©ë‹ˆë‹¤.");

    while (running && currentPage <= MAX_PAGES) {
      let okPage = false;
      let last = null;

      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) break;

        log(`í˜ì´ì§€ ${currentPage} OCR ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        last = await ocrOnePage(currentPage);
        if (!last) break;

        if (last.areaRatio > 0 && last.areaRatio < MIN_PAPER_AREA_RATIO) {
          await speak(`í˜ì´ì§€ ${currentPage}ê°€ ë„ˆë¬´ ì‘ê²Œ ë³´ì…ë‹ˆë‹¤. íœ´ëŒ€í°ì„ ë” ê°€ê¹Œì´ ê°€ì ¸ì˜¤ì„¸ìš”.`);
          continue;
        }

        const ok = !!last.stopTok || qualityOk(last.text);
        if (ok) {
          const qnums = extractQnumsFromPage(last.text);
          pages.push({ page: currentPage, text: last.text, conf: last.conf, qnums });
          rebuildAllText();
          okPage = true;
          break;
        } else {
          await speak(`ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. í˜ì´ì§€ ${currentPage}ë¥¼ ë” ê°€ê¹Œì´ ë³´ì—¬ ì£¼ì„¸ìš”.`);
        }
      }

      if (!okPage) {
        await speak(`í˜ì´ì§€ ${currentPage}ë¥¼ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë°˜ì‚¬ë¥¼ ì—†ì• ê³  ë” ê°€ê¹Œì´ ì´¬ì˜í•´ ì£¼ì„¸ìš”.`);
        throw new Error(`OCR ì‹¤íŒ¨(page=${currentPage})`);
      }

      if (last && last.stopTok) {
        log(`STOP TOKEN ê°ì§€ (${last.stopTok}) â†’ OCR ì¢…ë£Œ`);
        break;
      }

      await speakTurnPage(currentPage);
      currentPage++;
    }

    // ===== í’€ì´ ì „: ì•½í•œ ë¬¸í•­ ìˆìœ¼ë©´ í•´ë‹¹ í˜ì´ì§€ ìë™ ì¬ì´¬ì˜ =====
    let segs = extractQuestionSegmentsFromAllText(allText);
    const weakQs = weakQuestionNums(segs);

    if (weakQs.length > 0) {
      const targetPages = mapQuestionsToPages(weakQs.slice(0, 12));
      if (targetPages.length > 0) {
        await speak(`ì¼ë¶€ ë¬¸í•­ì´ ì˜ ì•ˆ ì½í˜”ìŠµë‹ˆë‹¤. í•´ë‹¹ í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
        await recapturePages(targetPages);
        segs = extractQuestionSegmentsFromAllText(allText);
      }
    }

    if (segs.length === 0) {
      await speak("ë¬¸í•­ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì²« í˜ì´ì§€ë¥¼ ë” ê°€ê¹Œì´ ì´¬ì˜í•´ ì£¼ì„¸ìš”.");
      throw new Error("no question segments");
    }

    await speak("ì´ì œ ë¬¸ì œë¥¼ í’‰ë‹ˆë‹¤.");

    const answers = await solveAllFromSegments(segs);
    lastAnswers = answers;

    ansBox.value = answersToText(answers);
    btnReplay.disabled = false;

    await speak("ì •ë‹µì„ ì½ê² ìŠµë‹ˆë‹¤.");
    await speakAnswers(answers);

    log("ì™„ë£Œ");
  }

  function stopAll() {
    running = false;
    btnStart.disabled = false;
    btnStop.disabled = true;
    try { speechSynthesis.cancel(); } catch(_) {}
    log("STOP");
  }

  // ===================== Events =====================
  btnAudio.addEventListener("click", async () => {
    try {
      await unlockAudio();
      pickKoreanVoice();
      await speak("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ.");
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ(ë²„íŠ¼)");
    } catch (e) {
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì‹¤íŒ¨: " + String(e?.message || e));
    }
  });

  btnStart.addEventListener("click", async () => {
    try {
      // ì‹œì‘ ë²„íŠ¼ì—ë„ ì˜¤ë””ì˜¤ ì–¸ë½ í¬í•¨(ë„¤ê°€ ì›í•œ â€œë²„íŠ¼ ëˆ„ë¥´ëŠ” ê²ƒë„ í¬í•¨â€)
      await unlockAudio();
      pickKoreanVoice();
      await runAuto();
    } catch (e) {
      log(`ERROR: ${e && e.message ? e.message : e}`);
      try { await speak("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”."); } catch (_) {}
      stopAll();
    }
  });

  btnStop.addEventListener("click", () => stopAll());

  btnReplay.addEventListener("click", async () => {
    try {
      await unlockAudio();
      pickKoreanVoice();
      if (!lastAnswers) { await speak("ì •ë‹µì´ ì—†ìŠµë‹ˆë‹¤."); return; }
      await speakAnswers(lastAnswers);
    } catch (e) {
      log("ì •ë‹µ ë‹¤ì‹œë“£ê¸° ì‹¤íŒ¨: " + String(e?.message || e));
    }
  });

  speechSynthesis.onvoiceschanged = () => pickKoreanVoice();
})();
</script>
</body>
</html>
