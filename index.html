<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>autononsul | phone</title>

  <!-- ✅ Tesseract.js v5 (버전 고정) -->
  <script src="https://unpkg.com/tesseract.js@5.0.4/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0; padding: 10px;
      background: #000; color: #fff;
      font-family: system-ui, -apple-system, "Apple SD Gothic Neo", sans-serif;
    }
    .top { display:flex; gap:8px; align-items:center; justify-content:space-between; }
    .btn {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #444;
      background: #111;
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      user-select: none;
    }
    .btn:active { transform: scale(0.98); }
    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid #333;
      background: #090909;
      font-size: 12px;
      color: #bfe8ff;
      white-space: nowrap;
    }

    #videoWrap {
      margin-top: 10px;
      position: relative;
      width: 100%;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      border: 1px solid #222;
    }

    video {
      width: 100%;
      height: auto;
      display:block;
      transform: scale(0.8);           /* ✅ 표시용 0.8배 */
      transform-origin: center center;
    }

    #hud {
      position:absolute;
      left: 0; right: 0; bottom: 0;
      padding: 8px 10px;
      background: linear-gradient(to top, rgba(0,0,0,0.75), rgba(0,0,0,0));
      font-size: 12px;
      line-height: 1.4;
      color: #e7f7ff;
    }

    #warn {
      margin-top: 8px;
      padding: 10px;
      border-radius: 12px;
      border: 1px solid #333;
      background: #0a0a0a;
      font-size: 13px;
      color: #ffd0d0;
      min-height: 44px;
      white-space: pre-wrap;
    }

    .box {
      margin-top: 10px;
      border: 1px solid #222;
      border-radius: 12px;
      overflow: hidden;
      background: #070707;
    }
    .boxHeader {
      padding: 10px;
      border-bottom: 1px solid #222;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 8px;
    }
    .boxHeader .title { font-size: 13px; color:#cfefff; }
    .boxBody { padding: 10px; }

    textarea {
      width: 100%;
      min-height: 140px;
      resize: vertical;
      border-radius: 10px;
      border: 1px solid #333;
      background:#000;
      color:#fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
      line-height: 1.35;
      padding: 10px;
    }

    pre {
      margin: 0;
      white-space: pre-wrap;
      word-break: break-word;
      border-radius: 10px;
      border: 1px solid #333;
      background:#000;
      color:#fff;
      font-size: 13px;
      line-height: 1.5;
      padding: 12px;
      min-height: 160px;
    }

    .tiny { font-size: 12px; color:#aaa; }
  </style>
</head>
<body>

  <div class="top">
    <div class="pill" id="enginePill">OCR 엔진: 로딩 중...</div>
    <button class="btn" id="ttsBtn">음성 연결/테스트</button>
  </div>

  <div id="videoWrap">
    <video id="video" autoplay playsinline muted></video>
    <div id="hud">
      <div id="hudLine1">카메라 준비 중...</div>
      <div id="hudLine2" class="tiny"></div>
    </div>
  </div>

  <div id="warn"></div>

  <div class="box">
    <div class="boxHeader">
      <div class="title">실시간 OCR (누적)</div>
      <button class="btn" id="forceSolveBtn">지금까지로 풀이</button>
    </div>
    <div class="boxBody">
      <textarea id="ocrPreview" placeholder="OCR 누적 텍스트가 여기에 쌓임"></textarea>
    </div>
  </div>

  <div class="box">
    <div class="boxHeader">
      <div class="title">답안</div>
      <button class="btn" id="stopTtsBtn">음성 중지</button>
    </div>
    <div class="boxBody">
      <pre id="answerBox">아직 답안 없음</pre>
    </div>
  </div>

<script>
(() => {
  // ====== 설정 ======
  const SOLVE_URL = "/.netlify/functions/solve";  // 같은 사이트면 이게 제일 안정적
  const OCR_LANG = "kor";                         // ✅ 한국어만
  const OCR_INTERVAL_MS = 3000;                   // ✅ 자동 OCR 주기(안정성 우선)
  const MIN_LEN_NO_SPACE = 2400;                  // ✅ 이 이상이면 “충분”
  const INSUFF_WARN_AFTER_MS = 60 * 1000;         // ✅ 1분 부족이면 경고
  const FORCE_SOLVE_AFTER_MS = 8 * 60 * 1000;     // ✅ 8분 부족이면 자동풀이
  const MAX_WAIT_MS = 10 * 60 * 1000;             // 안전장치
  const SIM_REPLACE = 0.72;                       // ✅ 비슷하면 교체
  const MAX_PREVIEW_CHARS = 12000;                // 프리뷰 너무 길어지는 것 방지
  const CAPTURE_MAX_W = 1600;                     // 캡처 스케일(너무 크면 느려짐)
  const CROP_RATIO = 0.92;                        // 중앙 크롭(여백 줄여 OCR 도움)

  // ====== DOM ======
  const video = document.getElementById("video");
  const enginePill = document.getElementById("enginePill");
  const ttsBtn = document.getElementById("ttsBtn");
  const stopTtsBtn = document.getElementById("stopTtsBtn");
  const forceSolveBtn = document.getElementById("forceSolveBtn");
  const warnBox = document.getElementById("warn");
  const hudLine1 = document.getElementById("hudLine1");
  const hudLine2 = document.getElementById("hudLine2");
  const ocrPreview = document.getElementById("ocrPreview");
  const answerBox = document.getElementById("answerBox");

  // ====== 상태 ======
  let worker = null;
  let workerReady = false;

  let camReady = false;
  let ocrRunning = false;
  let solving = false;
  let solvedOnce = false;

  let startAt = Date.now();
  let insuffStartAt = null;

  let lastThumb = null;
  let lastStableAt = 0;

  // 누적 블록(페이지 추정 느낌)
  let blocks = []; // [{text, conf, ts}]
  let avgConf = 0;

  // TTS
  let ttsEnabled = false;

  // ====== 유틸 ======
  function now() { return Date.now(); }

  function noSpaceLen(s) {
    return String(s || "").replace(/\s/g, "").length;
  }

  function normalizeForSim(s) {
    s = String(s || "");
    s = s.replace(/\s+/g, "");
    s = s.replace(/[^\uAC00-\uD7A30-9]/g, ""); // 한글+숫자만(유사도용)
    return s;
  }

  function similarity(a, b) {
    a = normalizeForSim(a);
    b = normalizeForSim(b);
    if (!a || !b) return 0;
    const alen = a.length, blen = b.length;
    const minLen = Math.min(alen, blen);
    const maxLen = Math.max(alen, blen);
    if (maxLen === 0) return 0;

    // 간단한 “부분 일치율” (가벼운 방식)
    let hit = 0;
    const step = Math.max(1, Math.floor(minLen / 64));
    for (let i = 0; i < minLen; i += step) {
      if (a[i] === b[i]) hit++;
    }
    return hit / Math.max(1, Math.floor(minLen / step));
  }

  // ✅ 숫자 유지 + 노이즈만 제거
  function cleanOcrTextKeepNumbers(s) {
    s = String(s || "");

    s = s.replace(/\r/g, "\n");
    s = s.replace(/[ \t]+/g, " ");
    s = s.replace(/[ \t]*\n[ \t]*/g, "\n");
    s = s.replace(/\n{3,}/g, "\n\n");

    // 영문 제거(원하면 지워도 됨)
    s = s.replace(/[A-Za-z]/g, " ");

    // 허용 문자만 남김: 한글, 숫자, 공백/줄바꿈, 기본 문장부호, 괄호/대괄호, ①②…
    s = s.replace(/[^가-힣0-9\s\n\.\,\?\!\:\;\(\)\[\]「」‘’“”\-①②③④⑤⑥⑦⑧⑨⑩]/g, " ");

    s = s.replace(/[ ]{2,}/g, " ");
    s = s.replace(/ *\n */g, "\n");
    s = s.trim();

    return s;
  }

  function setWarn(msg) {
    warnBox.textContent = msg || "";
  }

  function setHud() {
    const accText = blocks.map(b => b.text).join("\n\n").trim();
    const accLen = noSpaceLen(accText);

    const elapsed = Math.floor((now() - startAt) / 1000);
    const insuffSec = insuffStartAt ? Math.floor((now() - insuffStartAt) / 1000) : 0;

    hudLine1.textContent =
      `자동 OCR(누적) → 자동 풀이`;

    hudLine2.textContent =
      `누적 길이(공백제외): ${accLen} / 기준 ${MIN_LEN_NO_SPACE} | 평균 신뢰도(대략): ${avgConf.toFixed(1)}% | 지문 부족: ${insuffSec}초 | 경과: ${elapsed}초`;
  }

  // ====== 카메라 ======
  async function startCamera() {
    try {
      hudLine1.textContent = "카메라 요청 중...";
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 },
          frameRate: { ideal: 30 }
        },
        audio: false
      });

      video.srcObject = stream;
      await video.play().catch(() => {}); // iOS에서 실패해도 진행

      camReady = true;
      hudLine1.textContent = "카메라 준비됨. 자동 OCR 대기...";
      setWarn("");

      // 영상 설정 정보 표시
      const track = stream.getVideoTracks()[0];
      const s = track && track.getSettings ? track.getSettings() : {};
      const info = (s.width && s.height) ? `${s.width}x${s.height}` : "알 수 없음";
      enginePill.textContent = `OCR 엔진: ${workerReady ? "준비됨" : "로딩"} | 카메라: ${info}`;

    } catch (e) {
      camReady = false;
      setWarn("카메라 접근 실패: " + (e.message || String(e)));
      hudLine1.textContent = "카메라 실패";
    }
  }

  // ====== OCR 엔진 ======
  async function initWorker() {
    try {
      enginePill.textContent = "OCR 엔진: 로딩 중...";
      workerReady = false;

      worker = await Tesseract.createWorker({
        logger: m => {
          // recognizing 텍스트 진행률 표시(너무 시끄러우면 주석)
          if (m && m.status === "recognizing text") {
            enginePill.textContent = `OCR 엔진: 인식 중 ${Math.round((m.progress || 0) * 100)}%`;
          }
        }
      });

      await worker.loadLanguage(OCR_LANG);
      await worker.initialize(OCR_LANG);

      // ✅ 안정성 위주 파라미터(과하지 않게)
      await worker.setParameters({
        tessedit_pageseg_mode: "6",          // 한 덩어리 텍스트 가정
        preserve_interword_spaces: "1"
      });

      workerReady = true;
      enginePill.textContent = "OCR 엔진: 준비됨";
      setWarn("");
    } catch (e) {
      workerReady = false;
      enginePill.textContent = "OCR 엔진: 로딩 실패";
      setWarn("OCR 엔진 로딩 실패(네트워크 확인): " + (e.message || String(e)));
    }
  }

  // ====== 프레임 분석(가려짐/흔들림) ======
  const TH_W = 96, TH_H = 54;
  const thCanvas = document.createElement("canvas");
  thCanvas.width = TH_W;
  thCanvas.height = TH_H;
  const thCtx = thCanvas.getContext("2d", { willReadFrequently: true });

  function analyzeFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      return { blocked:false, stable:false, bright:0, motion:999 };
    }

    thCtx.drawImage(video, 0, 0, TH_W, TH_H);
    const img = thCtx.getImageData(0, 0, TH_W, TH_H);
    const d = img.data;
    const n = TH_W * TH_H;

    let sum = 0;
    let motionSum = 0;

    const curr = new Uint8Array(n);
    for (let i=0, p=0; i<d.length; i+=4, p++) {
      const gray = (d[i] + d[i+1] + d[i+2]) / 3;
      curr[p] = gray;
      sum += gray;
      if (lastThumb) motionSum += Math.abs(gray - lastThumb[p]);
    }

    const bright = sum / n;
    const motion = lastThumb ? (motionSum / n) : 999;

    const blocked = bright < 18;          // 너무 어두우면 가려짐/빛 부족
    const moving = motion > 9;           // 흔들림
    const stable = !blocked && !moving;

    lastThumb = curr;

    if (stable) {
      if (!lastStableAt) lastStableAt = now();
    } else {
      lastStableAt = 0;
    }

    return { blocked, stable, bright, motion };
  }

  // ====== 캡처 ======
  const capCanvas = document.createElement("canvas");
  const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

  function captureToCanvas() {
    const vw = video.videoWidth;
    const vh = video.videoHeight;

    if (!vw || !vh) {
      capCanvas.width = 640;
      capCanvas.height = 360;
      capCtx.fillStyle = "black";
      capCtx.fillRect(0,0,640,360);
      return capCanvas;
    }

    const cropW = Math.floor(vw * CROP_RATIO);
    const cropH = Math.floor(vh * CROP_RATIO);
    const cropX = Math.floor((vw - cropW) / 2);
    const cropY = Math.floor((vh - cropH) / 2);

    const scale = Math.min(1, CAPTURE_MAX_W / cropW);
    const outW = Math.floor(cropW * scale);
    const outH = Math.floor(cropH * scale);

    capCanvas.width = outW;
    capCanvas.height = outH;
    capCtx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, outW, outH);

    return capCanvas;
  }

  // ====== 누적 업데이트 ======
  function updateBlocks(newText, conf) {
    if (!newText) return;

    const cleaned = cleanOcrTextKeepNumbers(newText);
    const effective = noSpaceLen(cleaned);
    if (effective < 60) return; // 너무 짧으면 쓰레기 가능성↑

    const item = { text: cleaned, conf: Math.max(0, Math.min(100, conf || 0)), ts: now() };

    if (blocks.length === 0) {
      blocks.push(item);
    } else {
      const last = blocks[blocks.length - 1];
      const sim = similarity(last.text, item.text);

      // 비슷하면 교체(더 “긴”/더 “신뢰도 높은” 쪽으로)
      if (sim >= SIM_REPLACE) {
        const lastLen = noSpaceLen(last.text);
        const itemLen = noSpaceLen(item.text);

        const chooseItem =
          (item.conf > last.conf + 3) ||
          (itemLen > lastLen + 120) ||
          (itemLen >= lastLen && item.conf >= last.conf);

        if (chooseItem) blocks[blocks.length - 1] = item;
      } else {
        blocks.push(item);
      }
    }

    // 평균 신뢰도 업데이트(단순평균)
    avgConf = blocks.reduce((a,b)=>a + (b.conf||0), 0) / Math.max(1, blocks.length);

    // 프리뷰 갱신(너무 길면 뒤를 자름)
    let acc = blocks.map(b => b.text).join("\n\n").trim();
    if (acc.length > MAX_PREVIEW_CHARS) {
      acc = acc.slice(acc.length - MAX_PREVIEW_CHARS);
    }
    ocrPreview.value = acc;
    setHud();
  }

  // ====== 자동 OCR 루프 ======
  async function runOcrOnce() {
    if (!camReady || !workerReady) return;
    if (ocrRunning) return;
    if (solving) return;

    const a = analyzeFrame();

    if (a.blocked) {
      setWarn("카메라가 어둡거나 가려졌습니다. 밝은 곳으로 이동하거나 렌즈를 확인하세요.");
      setHud();
      return;
    }

    // 흔들리면 OCR 스킵(안정성 최우선)
    if (!a.stable || !lastStableAt || (now() - lastStableAt < 700)) {
      setWarn("흔들림/초점 불안정. 잠깐 멈춰서 화면이 고정되면 자동 OCR 됩니다.");
      setHud();
      return;
    }

    setWarn("");
    ocrRunning = true;
    enginePill.textContent = "OCR 엔진: 인식 중...";

    try {
      const canvas = captureToCanvas();
      const res = await worker.recognize(canvas);

      const raw = (res && res.data && res.data.text) ? res.data.text : "";
      const conf = (res && res.data && typeof res.data.confidence === "number") ? res.data.confidence : 0;

      const cleaned = cleanOcrTextKeepNumbers(raw);
      const eff = noSpaceLen(cleaned);

      if (eff < 60 || conf < 10) {
        // 부족 판단 타이머
        if (!insuffStartAt) insuffStartAt = now();
        const insuffMs = now() - insuffStartAt;

        if (insuffMs >= INSUFF_WARN_AFTER_MS) {
          setWarn("지문이 부족합니다.\n- 종이가 화면을 더 꽉 차게 들어오게 하세요.\n- 너무 가까우면 한 글자씩 뭉개질 수 있습니다.\n- 흔들리지 않게 1초 고정하세요.");
        } else {
          setWarn("지문 인식이 아직 부족합니다. 잠깐 더 고정해 주세요.");
        }

        // 8분이면 부족해도 자동 풀이
        maybeAutoSolve(true);
      } else {
        insuffStartAt = null;
        updateBlocks(raw, conf);
        maybeAutoSolve(false);
      }

    } catch (e) {
      setWarn("OCR 에러: " + (e.message || String(e)) + "\n네트워크/엔진 로딩 상태를 확인하세요.");
    } finally {
      ocrRunning = false;
      enginePill.textContent = "OCR 엔진: 준비됨";
      setHud();
    }
  }

  function getAccumText() {
    return blocks.map(b => b.text).join("\n\n").trim();
  }

  function maybeAutoSolve(forceByTimeout) {
    if (solving || solvedOnce) return;

    const acc = getAccumText();
    const accLen = noSpaceLen(acc);
    const elapsed = now() - startAt;

    // 충분하면 자동 풀이
    if (accLen >= MIN_LEN_NO_SPACE) {
      startSolve(false);
      return;
    }

    // 부족해도 8분이면 자동 풀이
    if (elapsed >= FORCE_SOLVE_AFTER_MS && elapsed <= MAX_WAIT_MS) {
      startSolve(true);
      return;
    }
  }

  // ====== Solve 호출 + TTS ======
  async function startSolve(forced) {
    if (solving) return;
    solving = true;

    const acc = getAccumText();
    if (!acc) {
      solving = false;
      return;
    }

    let prefix = "";
    if (forced) {
      prefix = "지문 부족으로 자동 풀이합니다.\n\n";
      answerBox.textContent = prefix + "답안 생성 중...";
    } else {
      answerBox.textContent = "충분한 지문 인식으로 자동 풀이합니다.\n\n답안 생성 중...";
    }

    try {
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          ocrText: acc,
          forced: !!forced
        })
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();

      // JSON이면 정상 파싱
      if (ct.includes("application/json")) {
        const data = await res.json().catch(() => null);

        if (!res.ok) {
          answerBox.textContent = prefix + "서버 에러:\n" + (data ? JSON.stringify(data, null, 2) : ("status=" + res.status));
          solvedOnce = false;
          return;
        }

        const ans = data && typeof data.answer === "string" ? data.answer.trim() : "";
        if (!ans) {
          answerBox.textContent = prefix + "No answer (모델 응답 비어있음). 입력을 더 줄여서 다시 시도";
          solvedOnce = false;
          return;
        }

        answerBox.textContent = prefix + ans;
        solvedOnce = true;

        // 자동 TTS
        if (ttsEnabled) speakText(prefix + ans);

        return;
      }

      // JSON 아니면 텍스트/HTML 그대로 출력(터지지 않게)
      const text = await res.text();
      answerBox.textContent = prefix + "서버가 JSON이 아닌 응답을 반환했습니다.\n\n" + String(text).slice(0, 4000);
      solvedOnce = false;

    } catch (e) {
      answerBox.textContent = prefix + "요청 실패: " + (e.message || String(e));
      solvedOnce = false;
    } finally {
      solving = false;
    }
  }

  function speakText(text) {
    try {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(String(text || ""));
      u.lang = "ko-KR";
      u.rate = 1.0;
      u.pitch = 1.0;
      u.volume = 1.0;
      window.speechSynthesis.speak(u);
    } catch (e) {
      setWarn("음성 재생 실패: " + (e.message || String(e)));
    }
  }

  // ====== 버튼 ======
  ttsBtn.addEventListener("click", () => {
    ttsEnabled = true;
    speakText("음성 연결 완료");
  });

  stopTtsBtn.addEventListener("click", () => {
    try { window.speechSynthesis.cancel(); } catch {}
  });

  forceSolveBtn.addEventListener("click", () => {
    startSolve(true);
  });

  // ====== 시작 ======
  async function boot() {
    setWarn("");
    setHud();

    await initWorker();
    await startCamera();

    // 엔진/카메라 둘 다 되면 자동 OCR 루프 시작
    const tick = async () => {
      setHud();
      if (camReady && workerReady && !solving) {
        await runOcrOnce();
      }
      setTimeout(tick, OCR_INTERVAL_MS);
    };
    setTimeout(tick, 800);
  }

  boot();
})();
</script>

</body>
</html>
