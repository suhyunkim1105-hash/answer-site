<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>answer-site OCR</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 12px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    input[type="number"]{ width:110px; }
    textarea { width:100%; height:180px; }
    pre { white-space: pre-wrap; word-break: break-word; background:#111; color:#ddd; padding:10px; border-radius:10px; }
    .warn { color:#b00020; font-weight:700; }
    .ok { color:#0a7; font-weight:700; }
    button { padding:10px 12px; border-radius:10px; border:1px solid #ccc; background:#fff; }
    button:disabled { opacity:0.5; }
    .card { border:1px solid #ddd; border-radius:12px; padding:10px; margin-top:10px; }
    video { width: 100%; max-width: 520px; border-radius: 12px; border: 1px solid #ddd; }
  </style>
</head>
<body>

<h2>OCR → /solve (자동 촬영)</h2>

<div class="card">
  <div class="row">
    <label>최대 가로(px)
      <input id="maxWidth" type="number" value="2000" min="800" max="4000" />
    </label>
    <label>JPEG 품질(0~1)
      <input id="jpegQuality" type="number" value="0.9" min="0.1" max="1" step="0.05" />
    </label>
    <label>샷/페이지
      <input id="shotsPerPage" type="number" value="3" min="1" max="5" />
    </label>
    <label>카운트다운(초)
      <input id="countdownSec" type="number" value="5" min="1" max="20" />
    </label>
    <label>STOP 토큰
      <input id="stopToken" type="text" value="ABCDEFGH" />
    </label>
  </div>

  <div class="row" style="margin-top:10px;">
    <button id="btnStart">AUTO START</button>
    <button id="btnStop">STOP</button>
    <button id="btnAudio">오디오(음성) 활성화</button>
    <button id="btnSpeak" disabled>정답 읽기(4회)</button>
  </div>

  <div id="status" style="margin-top:10px;"></div>
</div>

<div class="card">
  <h3>카메라 프리뷰</h3>
  <video id="video" playsinline autoplay muted></video>
</div>

<div class="card">
  <h3>누적 OCR</h3>
  <textarea id="ocrOut" placeholder="여기에 누적 OCR이 쌓임"></textarea>
</div>

<div class="card">
  <h3>정답(/solve 결과) + 채점</h3>
  <pre id="ansOut">-</pre>
</div>

<div class="card">
  <h3>로그</h3>
  <pre id="logOut"></pre>
</div>

<script>
/** =========================
 *  설정 / 상태
 *  ========================= */
const video = document.getElementById('video');
const statusEl = document.getElementById('status');
const logOut = document.getElementById('logOut');
const ocrOut = document.getElementById('ocrOut');
const ansOut = document.getElementById('ansOut');

const btnStart = document.getElementById('btnStart');
const btnStop  = document.getElementById('btnStop');
const btnAudio = document.getElementById('btnAudio');
const btnSpeak = document.getElementById('btnSpeak');

let stream = null;
let running = false;
let page = 1;
let audioUnlocked = false;

let lastAnswers = null;     // { "1":"A", ... }
let lastScoreReport = null; // 채점 문자열

// 정답표(성균관대 2022 영어) — 이미지에서 읽은 값 (1~50)
// 숫자 1~5를 A~E로 변환한 결과
const OFFICIAL = {
  1:"B",2:"B",3:"C",4:"D",5:"E",6:"E",7:"A",8:"C",9:"B",10:"D",
  11:"A",12:"B",13:"E",14:"A",15:"D",16:"B",17:"E",18:"B",19:"E",20:"D",
  21:"B",22:"D",23:"C",24:"E",25:"C",26:"E",27:"A",28:"C",29:"B",30:"C",
  31:"E",32:"A",33:"C",34:"A",35:"D",36:"A",37:"B",38:"C",39:"A",40:"C",
  41:"E",42:"C",43:"B",44:"B",45:"D",46:"A",47:"E",48:"D",49:"C",50:"D"
};

function now() {
  const d = new Date();
  const hh = String(d.getHours()).padStart(2,'0');
  const mm = String(d.getMinutes()).padStart(2,'0');
  const ss = String(d.getSeconds()).padStart(2,'0');
  return `[${hh}:${mm}:${ss}]`;
}

function log(msg) {
  logOut.textContent += `${now()} ${msg}\n`;
  logOut.scrollTop = logOut.scrollHeight;
}

function setStatus(html) {
  statusEl.innerHTML = html;
}

/** =========================
 *  카메라: 가능한 최고 해상도 요청
 *  ========================= */
async function initCamera() {
  if (stream) return;

  // 1) 최대치로 요청 (iOS는 완전한 고해상도 비디오가 제한될 수 있음)
  const constraints = {
    audio: false,
    video: {
      facingMode: { ideal: "environment" },
      width:  { ideal: 3840 },
      height: { ideal: 2160 }
    }
  };

  stream = await navigator.mediaDevices.getUserMedia(constraints);
  video.srcObject = stream;

  // 2) 실제 적용된 해상도 확인
  const track = stream.getVideoTracks()[0];
  const settings = track.getSettings();
  log(`카메라 OK (track settings: ${JSON.stringify(settings)})`);

  // 3) 낮은 프리뷰 해상도 경고
  // (너 로그에 나온 1080x1920 같은 경우)
  if (settings.width && settings.height) {
    const w = settings.width, h = settings.height;
    if (Math.max(w,h) <= 1920) {
      log(`경고: 프리뷰 해상도가 낮다(${w}x${h}). OCR 정확도가 떨어질 수 있다.`);
      log(`대응: (1) 밝은 조명 (2) 폰-종이 거리 늘리고 꽉 채우기 (3) 사파리/크롬 모두 테스트`);
      setStatus(`<div class="warn">프리뷰 해상도 낮음: ${w}x${h} (그래도 아래에서 캡처 이미지는 보정해서 보냄)</div>`);
    } else {
      setStatus(`<div class="ok">카메라 해상도 OK: ${w}x${h}</div>`);
    }
  }
}

/** =========================
 *  캡처: 프리뷰가 흐려도 캔버스를 크게 + 샤프닝
 *  ========================= */
function makeCanvasFromVideo(maxWidth) {
  const vw = video.videoWidth || 0;
  const vh = video.videoHeight || 0;
  if (!vw || !vh) throw new Error("video ready not yet");

  // 비율 유지
  const scale = Math.min(1, maxWidth / vw);
  const cw = Math.round(vw * scale);
  const ch = Math.round(vh * scale);

  const canvas = document.createElement('canvas');
  canvas.width = cw;
  canvas.height = ch;

  const ctx = canvas.getContext('2d', { willReadFrequently: true });
  ctx.drawImage(video, 0, 0, cw, ch);

  // 간단 보정: 대비/샤프닝(가벼운 언샵)
  // iOS에서도 안전하게 동작하도록 “가벼운” 처리만
  const img = ctx.getImageData(0,0,cw,ch);
  const data = img.data;

  // grayscale + contrast up
  for (let i=0;i<data.length;i+=4){
    const r=data[i], g=data[i+1], b=data[i+2];
    let y = (0.299*r + 0.587*g + 0.114*b);
    // contrast
    y = (y - 128) * 1.25 + 128;
    y = Math.max(0, Math.min(255, y));
    data[i]=data[i+1]=data[i+2]=y;
  }
  ctx.putImageData(img,0,0);

  return canvas;
}

function canvasToBlob(canvas, quality) {
  return new Promise((resolve) => {
    canvas.toBlob((blob) => resolve(blob), "image/jpeg", quality);
  });
}

/** =========================
 *  OCR 호출 (/ocr)
 *  ========================= */
async function callOcr(blob, page, shot) {
  const form = new FormData();
  form.append("page", String(page));
  form.append("shot", String(shot));
  form.append("image", blob, `p${page}_s${shot}.jpg`);

  const res = await fetch("/.netlify/functions/ocr", { method: "POST", body: form });
  const json = await res.json();
  if (!res.ok) throw new Error(json?.error || "OCR failed");
  return json; // { text, q, raw? }
}

/** =========================
 *  STOP 토큰 감지(오탐 방지)
 *  ========================= */
function shouldStopByToken(text, token) {
  if (!token) return false;
  const t = String(text || "");
  const has = t.includes(token);

  // 토큰이 섞여 나오는 오탐 방지:
  // “토큰만 거의 단독”일 때만 STOP 인정
  const compact = t.replace(/\s+/g,'').trim();
  const compactToken = token.replace(/\s+/g,'').trim();

  // 1) 토큰 포함 + 전체 길이가 짧다
  if (has && t.trim().length <= 40) return true;

  // 2) 토큰만 있는 페이지(정확히)
  if (compact === compactToken) return true;

  return false;
}

/** =========================
 *  /solve 호출 + 채점(%)
 *  ========================= */
function normalizeAnswers(obj) {
  // obj = {"answers":{...}} or direct
  const answers = obj?.answers || obj || {};
  const out = {};
  for (const [k,v] of Object.entries(answers)) {
    const q = String(k).trim();
    const a = String(v).trim().toUpperCase();
    if (!q || !a) continue;
    out[q] = a;
  }
  return out;
}

function grade(answers) {
  // answers: {"1":"A", ...}
  const keys = Object.keys(answers).map(n => parseInt(n,10)).filter(n => !Number.isNaN(n));
  keys.sort((a,b)=>a-b);

  let total=0, correct=0;
  const wrong = [];
  for (const n of keys) {
    const mine = answers[String(n)];
    const off = OFFICIAL[n];
    if (!off) continue; // 공식표 없는 번호는 스킵
    total++;
    if (mine === off) correct++;
    else wrong.push({n, mine, off});
  }
  const pct = total ? (correct/total*100) : 0;

  let report = `채점: ${correct}/${total} = ${pct.toFixed(2)}%\n`;
  if (wrong.length) {
    report += `틀린 것(번호: 내답/정답)\n`;
    report += wrong.map(x => `${x.n}: ${x.mine}/${x.off}`).join(", ");
    report += `\n`;
  }
  return {pct, total, correct, report};
}

async function callSolve(fullText) {
  const text = String(fullText || "").trim();
  if (!text) throw new Error("text required (누적 OCR이 비어있음)");

  const res = await fetch("/.netlify/functions/solve", {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ text })
  });

  const json = await res.json();
  if (!res.ok) throw new Error(json?.error || "solve failed");
  return json;
}

/** =========================
 *  TTS: 사용자 1회 클릭 필요(iOS 정책)
 *  ========================= */
function speakOnce(text) {
  const u = new SpeechSynthesisUtterance(text);
  u.lang = "ko-KR";
  u.rate = 1.0;
  window.speechSynthesis.cancel();
  window.speechSynthesis.speak(u);
}

async function speakAnswers4x() {
  if (!audioUnlocked) {
    log("TTS 차단: 먼저 '오디오(음성) 활성화' 또는 '정답 읽기' 버튼을 눌러야 함(iOS 정책).");
    return;
  }
  if (!lastAnswers) return;

  const keys = Object.keys(lastAnswers).map(n => parseInt(n,10)).filter(n => !Number.isNaN(n)).sort((a,b)=>a-b);
  const line = keys.map(n => `${n}번 ${lastAnswers[String(n)]}`).join(", ");

  // 4회 반복
  const text = `정답입니다. ${line}`;
  log("정답 TTS 4회 재생 시작");
  // speechSynthesis는 await가 없어서, 간단히 큐 방식으로 4개 넣음
  window.speechSynthesis.cancel();
  for (let i=0;i<4;i++){
    const u = new SpeechSynthesisUtterance(text);
    u.lang = "ko-KR";
    u.rate = 1.0;
    window.speechSynthesis.speak(u);
  }
}

/** =========================
 *  메인 루프: 페이지별 3샷 OCR → 베스트 선택
 *  ========================= */
async function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

async function countdown(sec, label) {
  for (let s=sec; s>0; s--){
    setStatus(`<div>${label} ${s}s</div>`);
    await sleep(1000);
    if (!running) return;
  }
}

async function runLoop() {
  running = true;
  page = 1;
  ocrOut.value = "";
  ansOut.textContent = "-";
  lastAnswers = null;
  btnSpeak.disabled = true;

  const maxWidth = parseInt(document.getElementById('maxWidth').value,10) || 2000;
  const jpegQuality = parseFloat(document.getElementById('jpegQuality').value) || 0.9;
  const shotsPerPage = parseInt(document.getElementById('shotsPerPage').value,10) || 3;
  const countdownSec = parseInt(document.getElementById('countdownSec').value,10) || 5;
  const stopToken = (document.getElementById('stopToken').value || "").trim();

  log("AUTO START");

  while (running) {
    let best = null;

    for (let shot=1; shot<=shotsPerPage; shot++){
      log(`페이지 ${page} / 샷 ${shot} 카운트다운 시작 (${countdownSec}s)`);
      await countdown(countdownSec, `페이지 ${page} / 샷 ${shot} 촬영까지`);
      if (!running) break;

      const canvas = makeCanvasFromVideo(maxWidth);
      const blob = await canvasToBlob(canvas, jpegQuality);

      const r = await callOcr(blob, page, shot); // {text, q}
      const text = r.text || "";
      const q = (typeof r.q === "number") ? r.q : text.length;

      log(`OCR OK page=${page} shot=${shot} len=${text.length} q=${q}`);

      if (!best || q > best.q) best = { text, q, shot };
    }

    if (!running) break;
    if (!best) throw new Error("best shot missing");

    log(`페이지 ${page} 완료 (best shot=${best.shot}, best q=${best.q})`);

    // 누적
    const chunk = `[PAGE ${page}]\n${best.text}\n\n`;
    ocrOut.value += chunk;

    // STOP 토큰 검사 (오탐 방지 포함)
    if (shouldStopByToken(best.text, stopToken)) {
      log(`STOP TOKEN 감지 (${stopToken}) → 종료`);
      running = false;
      break;
    }

    page++;
  }

  setStatus(`<div>OCR END</div>`);

  // solve
  const fullText = ocrOut.value;
  log("정답 계산 시작 (/solve 호출)");
  const solve = await callSolve(fullText);

  const answers = normalizeAnswers(solve.answers ? solve : solve); // solve가 {answers:{}} 형태든 그대로든 대응
  lastAnswers = answers;

  const g = grade(answers);
  lastScoreReport = g.report;

  ansOut.textContent =
`/solve raw:
${JSON.stringify(solve, null, 2)}

-------------------------
${g.report}`;

  btnSpeak.disabled = false;

  // 자동 TTS는 iOS에서 막힐 수 있음 → 사용자가 버튼으로 실행하도록 기본 설계
  if (audioUnlocked) {
    await speakAnswers4x();
  } else {
    log("TTS 대기: '정답 읽기(4회)' 버튼을 누르면 재생됨");
  }
}

/** =========================
 *  이벤트
 *  ========================= */
btnStart.addEventListener('click', async () => {
  try {
    await initCamera();
    await sleep(300); // video ready
    await runLoop();
  } catch (e) {
    log(`ERROR: ${e.message || e}`);
    setStatus(`<div class="warn">ERROR: ${e.message || e}</div>`);
  }
});

btnStop.addEventListener('click', () => {
  log("STOP 요청");
  running = false;
});

btnAudio.addEventListener('click', () => {
  audioUnlocked = true;
  log("오디오 안내 활성화(사용자 클릭으로 언락)");
  speakOnce("오디오 안내를 시작합니다.");
});

btnSpeak.addEventListener('click', async () => {
  audioUnlocked = true; // 이 버튼 클릭도 언락 처리
  await speakAnswers4x();
});

</script>
</body>
</html>
