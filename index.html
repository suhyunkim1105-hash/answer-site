<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>autononsul - OCR/solve</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <style>
    * { box-sizing: border-box; }
    body {
      margin:0; padding:12px;
      font-family: system-ui,-apple-system,BlinkMacSystemFont,sans-serif;
      background:#0b0b0b; color:#fff;
    }
    h1 { font-size:16px; margin:0 0 10px; }
    #status {
      font-size:12px; color:#c4f1ff;
      white-space:pre-wrap;
      padding:8px; border:1px solid #333;
      border-radius:10px; background:#070707;
    }
    #videoBox {
      margin-top:10px; border:1px solid #333;
      border-radius:10px; overflow:hidden; background:#000;
    }
    video { width:100%; height:auto; display:block; }

    .row { display:flex; gap:8px; margin-top:10px; }
    button {
      flex:1; padding:10px 12px;
      font-size:14px;
      border-radius:10px;
      border:1px solid #555;
      background:#151515; color:#fff;
    }
    button:active { transform: scale(0.98); }
    button:disabled { opacity:0.5; }

    textarea {
      width:100%; min-height:140px;
      margin-top:8px; padding:10px;
      border-radius:10px; border:1px solid #333;
      background:#060606; color:#fff;
      font-size:12px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }
    .hint { font-size:11px; color:#aaa; margin-top:6px; }

    #errOverlay {
      position:fixed; inset:0;
      background:rgba(0,0,0,0.92); color:#fff;
      padding:14px;
      display:none; z-index:9999; overflow:auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space:pre-wrap;
    }
    #errOverlay button { margin-top:10px; width:auto; }

    .smallRow {
      display:flex; gap:8px;
      margin-top:8px; align-items:center;
    }
    .badge {
      font-size:11px; padding:4px 8px;
      border-radius:999px;
      border:1px solid #444;
      background:#111; color:#ddd;
    }
    #pageDisplay {
      font-weight:bold;
      margin-left:4px;
    }
  </style>
</head>

<body>
  <div id="errOverlay"></div>

  <h1>ì—°ì„¸ëŒ€ ë…¼ìˆ  ìë™ OCR/í’€ì´</h1>
  <div id="status">í˜ì´ì§€ ë¡œë”©ë¨. ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘...</div>

  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <div class="smallRow">
    <div class="badge">OCR: í•œê¸€ + ì˜ì–´ + ìˆ«ì/ê¸°í˜¸</div>
    <div style="margin-left:auto; font-size:12px; color:#ccc;">
      í˜„ì¬ í˜ì´ì§€: <span id="pageDisplay">1</span>
    </div>
  </div>

  <div class="row">
    <button id="btnShutter">ğŸ“¸ ì…”í„°(5íšŒ ìë™ ì´¬ì˜)</button>
    <button id="btnSolve">ğŸ“ í’€ê¸°(ìˆ˜ë™ ì¬ì‹œì‘ìš©)</button>
  </div>

  <div class="hint">
    - ì…”í„°ë¥¼ í•œ ë²ˆ ëˆ„ë¥´ë©´, ê°™ì€ í˜ì´ì§€ë¥¼ 5ì´ˆ ê°„ê²©ìœ¼ë¡œ 5ë²ˆ ì´¬ì˜/OCRí•˜ê³ , ê·¸ ì¤‘ ì‹ ë¢°ë„(conf)ê°€ ê°€ì¥ ë†’ì€ ê²°ê³¼ë§Œ ì €ì¥í•œë‹¤.<br/>
    - OCR ëˆ„ì  í…ìŠ¤íŠ¸ ì•ˆì— â€œì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤â€ê°€ ë“¤ì–´ì˜¤ë©´ ìë™ìœ¼ë¡œ í’€ì´ë¥¼ ì‹œì‘í•œë‹¤.<br/>
    - ì•ˆë‚´ ìŒì„±ì€ ì§§ê²Œ, ë‹µì•ˆì€ ì›ê³ ì§€ ëª¨ë“œë¡œ ëŠë¦¬ê²Œ ë°˜ë³µ ë‚­ë…ëœë‹¤.
  </div>

  <textarea id="ocrBox" placeholder="OCR ëˆ„ì  í…ìŠ¤íŠ¸"></textarea>
  <textarea id="answerBox" placeholder="AI ë‹µì•ˆ"></textarea>

<script>
(function() {
  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnShutter = document.getElementById("btnShutter");
  const btnSolve = document.getElementById("btnSolve");
  const ocrBox = document.getElementById("ocrBox");
  const answerBox = document.getElementById("answerBox");
  const errOverlay = document.getElementById("errOverlay");
  const pageDisplay = document.getElementById("pageDisplay");

  const OCR_URL = "/.netlify/functions/ocr";
  const SOLVE_URL = "/.netlify/functions/solve";

  const MULTI_SHOTS = 5;
  const SHOT_INTERVAL_MS = 5000;

  let currentPageIndex = 1;      // ë‹¤ìŒì— ì´¬ì˜í•  í˜ì´ì§€ ë²ˆí˜¸
  let isShooting = false;        // í•œ í˜ì´ì§€ì—ì„œ 5íšŒ OCR ì¤‘ì¸ì§€ ì—¬ë¶€
  let autoSolveTriggered = false; // "ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤" ê°ì§€ í›„ ìë™ í’€ì´ í•œ ë²ˆë§Œ

  // ----- ê³µí†µ ìœ í‹¸ -----
  function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }

  function showErrorOverlay(title, detail) {
    try {
      errOverlay.innerHTML = "";
      errOverlay.style.display = "block";
      const pre = document.createElement("div");
      pre.textContent = "[ERROR]\n" + (title || "") + "\n\n" + (detail || "") + "\n\n(ì•„ë˜ ë²„íŠ¼ ëˆ„ë¥´ë©´ ë‹«í˜)";
      errOverlay.appendChild(pre);

      const btn = document.createElement("button");
      btn.textContent = "ë‹«ê¸°";
      btn.onclick = () => {
        errOverlay.style.display = "none";
        errOverlay.innerHTML = "";
      };
      errOverlay.appendChild(btn);
    } catch (e) {}
  }

  window.addEventListener("error", (e) => {
    const msg = e.message || "Unknown JS error";
    const stack = e.error && e.error.stack ? e.error.stack : "";
    showErrorOverlay(msg, stack);
  });

  window.addEventListener("unhandledrejection", (e) => {
    const msg = (e && e.reason) ? (e.reason.message || String(e.reason)) : "Unhandled rejection";
    const stack = (e && e.reason && e.reason.stack) ? e.reason.stack : "";
    showErrorOverlay(msg, stack);
  });

  // ----- TTS (ì•ˆë‚´ vs ì›ê³ ì§€ ëª¨ë“œ ë¶„ë¦¬) -----
  let ttsPrimed = false;
  let speaking = false;
  let pending = null; // { text, kind }

  function primeTTS() {
    if (ttsPrimed) return;
    ttsPrimed = true;
    if (!window.speechSynthesis) return;
    try {
      const u = new SpeechSynthesisUtterance("ìŒì„± ì—°ê²° í…ŒìŠ¤íŠ¸");
      u.lang = "ko-KR";
      u.rate = 1.0;
      u.onend = () => {
        window.speechSynthesis.cancel();
      };
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  function toWongojiSpeech(text) {
    let t = String(text || "");
    t = t.replace(/\r/g, "");
    t = t.replace(/\n+/g, " ì¤„ë°”ê¿ˆ ");
    t = t.replace(/ /g, " ë„ìš°ê³  ");
    t = t.replace(/\./g, " ë§ˆì¹¨í‘œ ");
    t = t.replace(/,/g, " ì‰¼í‘œ ");
    t = t.replace(/!/g, " ëŠë‚Œí‘œ ");
    t = t.replace(/\?/g, " ë¬¼ìŒí‘œ ");
    return t;
  }

  function speak(text, kind) {
    if (!text) return;
    if (!window.speechSynthesis) return;

    const isAnswer = kind === "answer";

    if (speaking) {
      pending = { text, kind };
      return;
    }

    speaking = true;
    const utterText = isAnswer ? toWongojiSpeech(text) : text;
    const rate = isAnswer ? 0.72 : 1.0;
    const repeat = isAnswer;

    const u = new SpeechSynthesisUtterance(utterText);
    u.lang = "ko-KR";
    u.rate = rate;
    u.pitch = 1.0;

    u.onend = () => {
      speaking = false;

      if (pending) {
        const next = pending;
        pending = null;
        speak(next.text, next.kind);
        return;
      }

      if (repeat) {
        setTimeout(() => {
          speak(text, kind);
        }, 900);
      }
    };

    u.onerror = () => {
      speaking = false;
    };

    try {
      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  function speakStatus(text) {
    speak(text, "status");
  }

  function speakAnswer(text) {
    speak(text, "answer");
  }

  // ----- ì¹´ë©”ë¼ -----
  let stream = null;

  async function startCamera() {
    try {
      statusEl.textContent = "ì¹´ë©”ë¼ ê¶Œí•œ ìš”ì²­ ì¤‘...";
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        statusEl.textContent = "ì´ ë¸Œë¼ìš°ì €ì—ì„œëŠ” ì¹´ë©”ë¼ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
        return;
      }
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        },
        audio: false
      });
      video.srcObject = stream;
      statusEl.textContent = "ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œ. í˜ì´ì§€ 1ë¶€í„° ì´¬ì˜í•˜ì„¸ìš”.";
    } catch (e) {
      statusEl.textContent = "ì¹´ë©”ë¼ ì‹¤íŒ¨: " + (e.message || String(e));
      showErrorOverlay("ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨", String(e && e.message ? e.message : e));
    }
  }

  function captureDataUrl() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) return null;
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);
    return canvas.toDataURL("image/jpeg", 0.9);
  }

  // ----- ìë™ í’€ì´ íŠ¸ë¦¬ê±° -----
  function shouldAutoSolve(allText) {
    const s = String(allText || "").replace(/\s/g, "");
    // "ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤" ë¬¸êµ¬ í¬í•¨ ì—¬ë¶€ë§Œ ë³¸ë‹¤.
    return s.includes("ì´ì œí’€ì´ë¥¼ì‹œì‘í•˜ì‹œì˜¤");
  }

  // ----- OCR: ì…”í„° 1ë²ˆ â†’ 5ì´ˆ ê°„ê²© 5íšŒ ì‹œë„ -----
  async function multiShotOCR() {
    primeTTS();

    if (isShooting) {
      statusEl.textContent = "ì´ë¯¸ ì´ í˜ì´ì§€ OCR ì¤‘ì…ë‹ˆë‹¤. ì ì‹œë§Œ ê¸°ë‹¤ë¦¬ì„¸ìš”.";
      speakStatus("ì´ë¯¸ ì´¬ì˜ ì¤‘ì…ë‹ˆë‹¤.");
      return;
    }

    const pageIndex = currentPageIndex;
    isShooting = true;
    btnShutter.disabled = true;
    btnSolve.disabled = true;

    statusEl.textContent = `í˜ì´ì§€ ${pageIndex} OCR: 5íšŒ ì´¬ì˜ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì‹œí—˜ì§€ë¥¼ í•œ ë©´ ê½‰ ì°¨ê²Œ ë§ì¶°ì£¼ì„¸ìš”.`;

    let best = null; // { text, conf }

    for (let i = 1; i <= MULTI_SHOTS; i++) {
      statusEl.textContent = `í˜ì´ì§€ ${pageIndex} OCR: ${i}/${MULTI_SHOTS}íšŒ ì´¬ì˜ ì¤‘...`;

      const dataUrl = captureDataUrl();
      if (!dataUrl) {
        statusEl.textContent = "ì˜ìƒ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤. 1~2ì´ˆ í›„ ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.";
        await sleep(1200);
      } else {
        try {
          const res = await fetch(OCR_URL, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              imageBase64: dataUrl,
              pageIndex,
              mode: "dual" // í•­ìƒ í•œê¸€+ì˜ì–´
            })
          });

          const json = await res.json().catch(() => null);

          if (json && json.ok && json.text && json.text.trim()) {
            const conf = typeof json.conf === "number" ? json.conf : 0;
            if (!best || conf > best.conf) {
              best = { text: json.text, conf };
            }
          }
        } catch (e) {
          // ë§ˆì§€ë§‰ ì‹œë„ê¹Œì§€ ì „ë¶€ ì‹¤íŒ¨í•œ ê²½ìš°ì—ë§Œ ì—ëŸ¬ ì˜¤ë²„ë ˆì´
          if (i === MULTI_SHOTS && !best) {
            showErrorOverlay("OCR ìš”ì²­ ì‹¤íŒ¨", String(e && e.stack ? e.stack : e));
          }
        }
      }

      if (i < MULTI_SHOTS) {
        await sleep(SHOT_INTERVAL_MS);
      }
    }

    isShooting = false;
    btnShutter.disabled = false;
    btnSolve.disabled = false;

    if (!best) {
      statusEl.textContent = `í˜ì´ì§€ ${pageIndex} OCR 5íšŒ ëª¨ë‘ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì…”í„°ë¥¼ ëˆŒëŸ¬ì£¼ì„¸ìš”.`;
      speakStatus("ì˜¤ì”¨ì•Œ ë‹¤ì„¯ ë²ˆ ëª¨ë‘ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ì£¼ì„¸ìš”.");
      return;
    }

    const block = `\n\n[í˜ì´ì§€ ${pageIndex}]-------------------\n${best.text}`;
    ocrBox.value = (ocrBox.value || "") + block;

    statusEl.textContent = `OCR ì™„ë£Œ: í˜ì´ì§€ ${pageIndex} (ìµœê³  ì‹ ë¢°ë„ ì•½ ${(best.conf || 0).toFixed(1)}%)`;
    speakStatus("ì˜¤ì”¨ì•Œ ì™„ë£Œ");

    currentPageIndex += 1;
    pageDisplay.textContent = String(currentPageIndex);

    // ìë™ í’€ì´ íŠ¸ë¦¬ê±°
    if (!autoSolveTriggered && shouldAutoSolve(ocrBox.value)) {
      autoSolveTriggered = true;
      statusEl.textContent += "\n\n'ì´ì œ í’€ì´ë¥¼ ì‹œì‘í•˜ì‹œì˜¤' ë¬¸êµ¬ë¥¼ ê°ì§€í–ˆìŠµë‹ˆë‹¤. ìë™ìœ¼ë¡œ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.";
      doSolve();
    }
  }

  // ----- Solve (AI í’€ì´) -----
  async function doSolve() {
    primeTTS();

    const text = (ocrBox.value || "").trim();
    if (!text) {
      statusEl.textContent = "ë¨¼ì € ì…”í„°ë¡œ OCRì„ ìŒ“ì•„ì£¼ì„¸ìš”.";
      speakStatus("ë¨¼ì € ì˜¤ì”¨ì•Œì„ ì§„í–‰í•˜ì„¸ìš”.");
      return;
    }

    statusEl.textContent = "AI í’€ì´ ìš”ì²­ ì¤‘... (ìµœëŒ€ ìˆ˜ì‹­ ì´ˆ ê±¸ë¦´ ìˆ˜ ìˆìŒ)";
    try {
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          text,
          targetChars: 1000,
          tolerance: 120
        })
      });

      const json = await res.json().catch(() => null);
      if (!json || !json.ok) {
        const msg = (json && (json.message || json.error)) || "solve ì‹¤íŒ¨";
        statusEl.textContent = `í’€ì´ ì‹¤íŒ¨: ${msg}`;
        speakStatus("í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.");
        return;
      }

      const answer = (json.answer || "").trim();
      answerBox.value = answer || "(ë¹ˆ ì‘ë‹µ)";
      statusEl.textContent = "í’€ì´ ì™„ë£Œ. (ì›ê³ ì§€ ëª¨ë“œë¡œ ëŠë¦¬ê²Œ ë°˜ë³µ ë‚­ë…)";

      speakAnswer(answer);
    } catch (e) {
      statusEl.textContent = "í’€ì´ ìš”ì²­ ì‹¤íŒ¨: " + (e.message || String(e));
      showErrorOverlay("solve ìš”ì²­ ì‹¤íŒ¨", String(e && e.stack ? e.stack : e));
    }
  }

  // ----- ë²„íŠ¼ ì´ë²¤íŠ¸ -----
  btnShutter.addEventListener("click", () => {
    primeTTS();
    multiShotOCR();
  });

  // ìˆ˜ë™ìœ¼ë¡œ ë‹¤ì‹œ í’€ê³  ì‹¶ì„ ë•Œë§Œ ì‚¬ìš©
  btnSolve.addEventListener("click", () => {
    primeTTS();
    autoSolveTriggered = true; // ìˆ˜ë™ í’€ì´ë„ 'ì´ë¯¸ í•œ ë²ˆ í’€ì—ˆë‹¤'ë¡œ ë³¸ë‹¤
    doSolve();
  });

  // ----- ì‹œì‘ -----
  startCamera();
})();
</script>
</body>
</html>
