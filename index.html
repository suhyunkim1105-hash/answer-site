<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ì„±ê· ê´€ëŒ€/í™ìµëŒ€ ì˜ì–´ ê¸°ì¶œ ìë™í’€ì´</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 12px;
      background: #fafafa;
      color: #111;
    }
    h1 {
      font-size: 20px;
      margin-bottom: 8px;
    }
    .log-box {
      border: 1px solid #ccc;
      border-radius: 8px;
      padding: 8px;
      height: 120px;
      overflow-y: auto;
      background: #fff;
      white-space: pre-line;
      font-size: 12px;
    }
    .btn-row {
      display: flex;
      gap: 12px;
      margin: 12px 0;
      flex-wrap: wrap;
    }
    button {
      flex: 1 1 45%;
      padding: 10px 8px;
      border-radius: 10px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
    }
    #btnAudio {
      background: #f0f4ff;
    }
    #btnStart {
      background: #ffe9b3;
    }
    #btnStop {
      background: #ffd4d4;
    }
    #btnReplay {
      background: #e6f5ff;
    }
    video {
      width: 100%;
      max-height: 420px;
      background: #000;
      border-radius: 12px;
      margin-top: 8px;
      object-fit: contain;
    }
    .hint {
      font-size: 12px;
      color: #555;
      margin-top: 8px;
      line-height: 1.5;
    }
    textarea {
      width: 100%;
      box-sizing: border-box;
      margin-top: 8px;
      border-radius: 8px;
      padding: 6px;
      font-size: 11px;
    }
  </style>
</head>
<body>
  <h1>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</h1>

  <div id="log" class="log-box"></div>

  <div class="btn-row">
    <button id="btnAudio">ğŸ”ˆ ì˜¤ë””ì˜¤ ì¤€ë¹„(í•œ ë²ˆë§Œ)</button>
    <button id="btnStart">ğŸ“· ìë™ ì‹œì‘</button>
  </div>
  <div class="btn-row">
    <button id="btnStop">â›” ì¤‘ì§€</button>
    <button id="btnReplay">ğŸ” ì •ë‹µ ë‹¤ì‹œ ë“£ê¸°</button>
  </div>

  <div class="hint">
    - ë§ˆì§€ë§‰ í˜ì´ì§€ ì–´ë”˜ê°€ì— <b>XVRTH</b> ë˜ëŠ” <b>XURTH</b>ë¥¼ êµµê³  í¬ê²Œ ì“°ë©´, ê·¸ í˜ì´ì§€ OCR í›„ ìë™ìœ¼ë¡œ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br />
    - iOS ë¬´ìŒ ëª¨ë“œë©´ TTSê°€ ì•ˆ ë“¤ë¦´ ìˆ˜ ìˆë‹¤. ë¬´ìŒ í•´ì œ + ë³¼ë¥¨ ì˜¬ë ¤ë¼.<br />
    - ì¢…ì´ëŠ” í™”ë©´ì—ì„œ í¬ê²Œ(ê±°ì˜ ê½‰ ì°¨ê²Œ) ì¡ê³ , ê¸€ìê°€ ë˜ë ·í•˜ê²Œ ë‚˜ì˜¤ë„ë¡ ì •ë©´ì—ì„œ ì°ì–´ë¼.<br />
  </div>

  <video id="camera" playsinline autoplay muted></video>

  <h3 style="margin-top:12px; font-size:14px;">OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸ìš©)</h3>
  <textarea id="ocrDebug" rows="10" readonly>ìë™ OCR ê²°ê³¼ê°€ ì—¬ê¸° ëˆ„ì ëœë‹¤(ìˆ˜ë™ ìˆ˜ì • ê¸ˆì§€).</textarea>

  <script>
    let video, canvas, ctx;
    let stream = null;
    let running = false;
    let pageIndex = 0;
    const MAX_PAGES = 6;          // ì•ˆì „ ìƒí•œ
    const SHOTS_PER_PAGE = 3;     // í˜ì´ì§€ë‹¹ ìƒ· ìˆ˜
    const MIN_LEN = 800;          // ì´ë³´ë‹¤ ì§§ìœ¼ë©´ í’ˆì§ˆ ë‚®ë‹¤ê³  íŒë‹¨
    const MIN_HITS = 8;           // "1) 2) ..." íŒ¨í„´ ëª‡ ê°œ ì´ìƒ ìˆì–´ì•¼ í•¨

    let fullTexts = [];
    let lastAnswers = null;
    let speakingAnswers = false;

    let audioReady = false;
    let audioCtx = null;
    let koVoice = null;

    function pad2(n) {
      return String(n).padStart(2, "0");
    }

    function nowLabel() {
      const d = new Date();
      return "[" + pad2(d.getHours()) + "ì‹œ " + pad2(d.getMinutes()) + "ë¶„ " + pad2(d.getSeconds()) + "ì´ˆ]";
    }

    function log(msg) {
      const el = document.getElementById("log");
      const line = nowLabel() + " " + msg;
      el.textContent = line + "\n" + el.textContent;
    }

    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function initCamera() {
      if (stream) return;
      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        log("ì¹´ë©”ë¼ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.");
        return;
      }
      try {
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: "environment" } },
          audio: false
        });
        video.srcObject = stream;
        await video.play();
        log("ì¹´ë©”ë¼ OK (" + video.videoWidth + "x" + video.videoHeight + ")");
      } catch (e) {
        log("ì¹´ë©”ë¼ ì˜¤ë¥˜: " + (e.message || e));
      }
    }

    function chooseKoVoice() {
      if (typeof speechSynthesis === "undefined") return;
      const voices = speechSynthesis.getVoices();
      if (!voices || !voices.length) return;
      koVoice =
        voices.find(v => /ko-KR/i.test(v.lang) && /Yuna|ìœ ë‚˜|ìœ¤ì•„/i.test(v.name)) ||
        voices.find(v => /ko-KR/i.test(v.lang)) ||
        voices[0];
      if (koVoice) {
        log("TTS voice: " + koVoice.name + " (" + koVoice.lang + ")");
      }
    }

    function setupVoices() {
      if (typeof speechSynthesis === "undefined") return;
      chooseKoVoice();
      if (speechSynthesis.onvoiceschanged === null) {
        speechSynthesis.onvoiceschanged = function() {
          chooseKoVoice();
        };
      }
    }

    function onAudio() {
      if (audioReady) {
        log("ì˜¤ë””ì˜¤ ì´ë¯¸ ì¤€ë¹„ë¨");
        return;
      }
      try {
        const AC = window.AudioContext || window.webkitAudioContext;
        if (AC) {
          audioCtx = new AC();
          if (audioCtx.state === "suspended") {
            const resume = function() {
              audioCtx.resume();
              document.removeEventListener("touchend", resume);
              document.removeEventListener("click", resume);
            };
            document.addEventListener("touchend", resume, { once: true });
            document.addEventListener("click", resume, { once: true });
          }
        }
        setupVoices();
        audioReady = true;
        log("AudioContext ì–¸ë½ ì™„ë£Œ ëŒ€ê¸° ì¤‘");
        speak("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ");
      } catch (e) {
        log("ì˜¤ë””ì˜¤ ì´ˆê¸°í™” ì˜¤ë¥˜: " + (e.message || e));
      }
    }

    function speak(text) {
      if (!audioReady || typeof speechSynthesis === "undefined") return;
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "ko-KR";
      if (koVoice) u.voice = koVoice;
      speechSynthesis.speak(u);
    }

    function speakAsync(text) {
      return new Promise(resolve => {
        if (!audioReady || typeof speechSynthesis === "undefined") return resolve();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "ko-KR";
        if (koVoice) u.voice = koVoice;
        u.onend = function() { resolve(); };
        u.onerror = function() { resolve(); };
        speechSynthesis.speak(u);
      });
    }

    function captureImage() {
      if (!video || !video.videoWidth) {
        log("ë¹„ë””ì˜¤ í”„ë ˆì„ì´ ì—†ë‹¤.");
        return null;
      }
      if (!canvas) {
        canvas = document.createElement("canvas");
        ctx = canvas.getContext("2d");
      }
      const w = video.videoWidth;
      const h = video.videoHeight;
      canvas.width = w;
      canvas.height = h;
      ctx.drawImage(video, 0, 0, w, h);
      try {
        return canvas.toDataURL("image/jpeg", 0.8);
      } catch (e) {
        log("ìº¡ì²˜ ì˜¤ë¥˜: " + (e.message || e));
        return null;
      }
    }

    function countHits(text) {
      if (!text) return 0;
      const m = text.match(/\b(0?[1-9]|[1-4][0-9])\s*[\)\.]/g) || [];
      return m.length;
    }

    async function callOcr(image, page, shot) {
      if (!image) return { ok: false, error: "no image" };
      try {
        const resp = await fetch("/.netlify/functions/ocr", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ image: image, pageIndex: page, shot: shot })
        });
        const data = await resp.json();
        return data;
      } catch (e) {
        return { ok: false, error: e.message || String(e) };
      }
    }

    async function ocrPage(page) {
      await speakAsync("í˜ì´ì§€ " + page + "ì„ ì´¬ì˜í•œë‹¤.");
      let best = null;
      for (let shot = 1; shot <= SHOTS_PER_PAGE && running; shot++) {
        log("í˜ì´ì§€ " + page + " / ìƒ· " + shot + " ì´¬ì˜");
        const img = captureImage();
        const res = await callOcr(img, page, shot);
        if (!running) break;
        if (!res || !res.ok) {
          log("OCR FAIL page=" + page + " shot=" + shot + ": " + (res && res.error));
          continue;
        }
        const text = res.text || "";
        const len = text.length;
        const hits = typeof res.hits === "number" ? res.hits : countHits(text);
        const conf = typeof res.conf === "number" ? res.conf : 0;
        const score = len + hits * 100;
        log("OCR OK page=" + page + " shot=" + shot + " len=" + len + " conf=" + conf);
        if (!best || score > best.score) {
          best = { text: text, len: len, hits: hits, score: score };
        }
        await sleep(500); // ìƒ· ê°„ ì§§ì€ ê°„ê²©
      }

      if (!best) {
        return { ok: false, reason: "no shot succeeded" };
      }

      if (/X[UV]RTH/i.test(best.text)) {
        return { ok: true, stop: true, text: best.text, len: best.len, hits: best.hits };
      }

      if (best.len < MIN_LEN || best.hits < MIN_HITS) {
        return { ok: false, reason: "too weak (len=" + best.len + ", hits=" + best.hits + ")" };
      }

      const dbg = document.getElementById("ocrDebug");
      dbg.value += "\n\n[PAGE " + page + "]\n" + best.text;

      return { ok: true, stop: false, text: best.text, len: best.len, hits: best.hits };
    }

    async function runAllPages() {
      let stopSeen = false;
      while (running && pageIndex <= MAX_PAGES) {
        const res = await ocrPage(pageIndex);
        if (!running) break;
        if (!res.ok) {
          log("í˜ì´ì§€ " + pageIndex + " OCR ì‹¤íŒ¨: " + (res.reason || res.error));
          await speakAsync("í˜ì´ì§€ " + pageIndex + " ê¸€ìê°€ ì˜ ì¸ì‹ë˜ì§€ ì•ŠëŠ”ë‹¤. ë” ê°€ê¹ê²Œ, ë˜ë ·í•˜ê²Œ ë‹¤ì‹œ ì°ì–´ë¼.");
          return; // ì—¬ê¸°ì„œ ë°”ë¡œ ë. ë‹¤ìŒ í˜ì´ì§€ë¡œ ì•ˆ ë„˜ì–´ê°.
        }
        if (res.stop) {
          log("STOP TOKEN ê°ì§€ (page=" + pageIndex + ")");
          await speakAsync("ë§ˆì§€ë§‰ í˜ì´ì§€ë¥¼ í™•ì¸í–ˆë‹¤. ì´¬ì˜ì„ ëë‚´ê³  ì •ë‹µì„ ê³„ì‚°í•œë‹¤.");
          stopSeen = true;
          break;
        }
        fullTexts[pageIndex] = res.text;
        log("í˜ì´ì§€ " + pageIndex + " ì™„ë£Œ (len=" + res.len + ", hits=" + res.hits + ")");
        pageIndex++;
        if (pageIndex <= MAX_PAGES) {
          await speakAsync("ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ê²¨ë¼. í˜ì´ì§€ " + pageIndex + "ì„ ì¤€ë¹„í•´ë¼.");
        }
      }
      if (!stopSeen && !fullTexts.some(Boolean)) {
        log("ìœ íš¨í•œ í˜ì´ì§€ê°€ ì—†ë‹¤.");
        return;
      }
      await solveAndSpeak();
    }

    async function solveAndSpeak() {
      try {
        const allText = fullTexts.filter(Boolean).join("\n\n");
        if (allText) {
          document.getElementById("ocrDebug").value = allText;
        }

        log("ë¬¸í•­ íŒŒì‹± ì‹œì‘ (/parse-questions í˜¸ì¶œ)");
        const resp = await fetch("/.netlify/functions/parse-questions", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ ocrText: allText })
        });
        const data = await resp.json().catch(function() { return {}; });
        if (!data || !data.ok) {
          log("ë¬¸í•­ íŒŒì‹± ì‹¤íŒ¨: " + (data && data.error));
          await speakAsync("ë¬¸ì œ ì¸ì‹ì— ì‹¤íŒ¨í–ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ì•¼ í•œë‹¤.");
          return;
        }
        const questions = data.questions || [];
        log("ë¬¸í•­ íŒŒì‹± ì™„ë£Œ: " + questions.length + "ë¬¸í•­");
        if (!questions.length) {
          await speakAsync("ë¬¸ì œ ì¸ì‹ì— ì‹¤íŒ¨í–ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ì•¼ í•œë‹¤.");
          return;
        }

        log("ì •ë‹µ ê³„ì‚° ì‹œì‘ (/solve í˜¸ì¶œ)");
        const sResp = await fetch("/.netlify/functions/solve", {
          method: "POST",
          headers: { "content-type": "application/json" },
          body: JSON.stringify({ questions: questions })
        });
        const sData = await sResp.json().catch(function() { return {}; });
        if (!sData || !sData.ok || !sData.answers) {
          log("ì •ë‹µ ê³„ì‚° ì‹¤íŒ¨: " + (sData && sData.error));
          await speakAsync("ì •ë‹µ ê³„ì‚°ì— ì‹¤íŒ¨í–ˆë‹¤.");
          return;
        }
        lastAnswers = sData.answers;
        log("ì •ë‹µ ìˆ˜ì‹  OK: " + JSON.stringify(lastAnswers));
        await speakAnswers(lastAnswers);
      } catch (e) {
        log("solveAndSpeak ì—ëŸ¬: " + (e.message || e));
      }
    }

    async function speakAnswers(answers) {
      if (!answers) return;
      if (speakingAnswers) {
        log("ì´ë¯¸ ì •ë‹µì„ ì½ëŠ” ì¤‘ì´ë‹¤.");
        return;
      }
      speakingAnswers = true;
      try {
        const entries = Object.entries(answers)
          .map(function(pair) { return [Number(pair[0]), Number(pair[1])]; })
          .filter(function(pair) { return Number.isFinite(pair[0]) && Number.isFinite(pair[1]); })
          .sort(function(a, b) { return a[0] - b[0]; });

        const choiceMap = ["A", "B", "C", "D", "E"];

        for (let round = 1; round <= 4; round++) {
          await speakAsync("ì •ë‹µì„ " + round + "ë²ˆì§¸ë¡œ ì½ëŠ”ë‹¤.");
          for (let i = 0; i < entries.length; i++) {
            const q = entries[i][0];
            const c = entries[i][1];
            const letter = choiceMap[c - 1] || "";
            await speakAsync(q + "ë²ˆ, " + letter);
            await sleep(2000); // ë¬¸í•­ ì‚¬ì´ 2ì´ˆ
          }
          await sleep(3000); // íšŒì°¨ ì‚¬ì´ 3ì´ˆ
        }
      } finally {
        speakingAnswers = false;
      }
    }

    function onReplay() {
      if (!lastAnswers) {
        log("ì •ë‹µ ë‹¤ì‹œ ë“£ê¸°: ì´ì „ ì •ë‹µì´ ì—†ë‹¤.");
        return;
      }
      speakAnswers(lastAnswers);
    }

    async function onStart() {
      if (running) return;
      await initCamera();
      if (!audioReady) onAudio();
      running = true;
      pageIndex = 1;
      fullTexts = [];
      lastAnswers = null;
      log("AUTO START");
      await speakAsync("ìë™ ì´¬ì˜ì„ ì‹œì‘í•œë‹¤. 1í˜ì´ì§€ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë§ì¶°ë¼.");
      await runAllPages();
      running = false;
    }

    function onStop() {
      if (!running) {
        log("ì´ë¯¸ ì¤‘ì§€ ìƒíƒœì´ë‹¤.");
      }
      running = false;
      log("STOP");
    }

    document.addEventListener("DOMContentLoaded", function() {
      video = document.getElementById("camera");
      canvas = document.createElement("canvas");
      ctx = canvas.getContext("2d");

      document.getElementById("btnAudio").addEventListener("click", onAudio);
      document.getElementById("btnStart").addEventListener("click", function() {
        onStart().catch(function(e) {
          log("ìë™ ì‹œì‘ ì˜¤ë¥˜: " + (e.message || e));
          running = false;
        });
      });
      document.getElementById("btnStop").addEventListener("click", onStop);
      document.getElementById("btnReplay").addEventListener("click", onReplay);

      setupVoices();
      log("ëŒ€ê¸° ì¤‘");
    });
  </script>
</body>
</html>

