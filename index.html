<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì—°ì„¸ëŒ€ ë…¼ìˆ  OCR â†’ ë³µë¶™ â†’ TTS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      color-scheme: dark;
    }
    * {
      box-sizing: border-box;
      -webkit-tap-highlight-color: transparent;
    }
    body {
      margin: 0;
      padding: 12px;
      background: #000;
      color: #fff;
      font-family: -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
    }
    .container {
      max-width: 520px;
      margin: 0 auto;
    }
    h1 {
      font-size: 20px;
      margin: 8px 0 4px;
      font-weight: 700;
    }
    .sub {
      font-size: 12px;
      color: #bbbbbb;
      line-height: 1.5;
      margin-bottom: 8px;
    }
    .warn {
      color: #ffb347;
      font-size: 11px;
    }
    button {
      width: 100%;
      padding: 12px 14px;
      margin-bottom: 8px;
      border-radius: 14px;
      border: none;
      background: #202020;
      color: #fff;
      font-size: 16px;
      font-weight: 500;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }
    button:active {
      opacity: 0.7;
      transform: scale(0.98);
    }
    #ttsBox {
      width: 100%;
      min-height: 140px;
      margin-top: 4px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid #333;
      background: #050505;
      color: #f5f5f5;
      font-size: 14px;
      resize: vertical;
      white-space: pre-wrap;
    }
    #status, #shareStatus {
      font-size: 11px;
      margin-top: 4px;
      color: #d0d0d0;
    }
    #cameraWrapper {
      margin-top: 10px;
    }
    #camera {
      width: 100%;
      border-radius: 16px;
      background: #111;
    }
    #ocrAccumulated {
      width: 100%;
      min-height: 170px;
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid #333;
      background: #050505;
      color: #f5f5f5;
      font-size: 11px;
      white-space: pre-wrap;
    }
    #chartShots {
      margin-top: 8px;
      display: flex;
      flex-wrap: nowrap;
      overflow-x: auto;
      gap: 6px;
    }
    #chartShots img.chart-thumb {
      flex: 0 0 auto;
      width: 90px;
      height: auto;
      border-radius: 8px;
      border: 1px solid #333;
    }
    .section-title {
      margin-top: 10px;
      font-size: 13px;
      font-weight: 600;
    }
    canvas {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ì—°ì„¸ëŒ€ ë…¼ìˆ  OCR â†’ ë³µë¶™ â†’ TTS</h1>
    <div class="sub">
      ì¹´ë©”ë¼ì— ì‹œí—˜ì§€ í•œ ì¥ì´ ê½‰ ì°¨ê²Œ ë³´ì´ë„ë¡ ë§ì¶˜ ë’¤<br />
      <strong>ğŸ“¸ ìë™ OCR ì‹œì‘/ì •ì§€</strong>ë¥¼ ëˆ„ë¥´ë©´, í˜ì´ì§€ë‹¹ ìë™ ì´¬ì˜ + OCR 3íšŒ ì§„í–‰ëœë‹¤.<br />
      <span class="warn">â€» TTS ì¶œë ¥ì´ ì „í˜€ ì•ˆ ë‚˜ì˜¤ëŠ” ê²ƒ ê°™ìœ¼ë©´ ìƒˆë¡œê³ ì¹¨í•˜ë¼.</span>
    </div>

    <!-- ìƒë‹¨: ë²„íŠ¼ 2ê°œ + ë‹µì•ˆ TTS ë°•ìŠ¤ -->
    <button id="ocrToggleBtn">ğŸ“¸ ìë™ OCR ì‹œì‘/ì •ì§€</button>
    <button id="shareBtn">ğŸ”— ChatGPTë¡œ ê³µìœ (í…ìŠ¤íŠ¸+ë„í‘œ ì´ë¯¸ì§€)</button>

    <textarea id="ttsBox" placeholder="ì—¬ê¸°ì— ChatGPT ìµœì¢… ë‹µì•ˆì„ ë¶™ì—¬ ë„£ìœ¼ë©´ 0.9ë°°ì†ìœ¼ë¡œ, ë‹¨ì–´ ì‚¬ì´ 7ì´ˆ ì‰¬ë©´ì„œ ê³„ì† ë°˜ë³µ ì¬ìƒëœë‹¤."></textarea>
    <div id="status" class="status"></div>
    <div id="shareStatus" class="status"></div>

    <!-- ì¹´ë©”ë¼ & OCR ê²°ê³¼ -->
    <div id="cameraWrapper">
      <video id="camera" autoplay playsinline></video>
      <canvas id="captureCanvas"></canvas>
    </div>

    <div class="section-title">ëˆ„ì  OCR ê²°ê³¼(í…ìŠ¤íŠ¸)</div>
    <textarea id="ocrAccumulated" readonly></textarea>

    <div class="section-title">ë„í‘œ í˜ì´ì§€ ìƒ·(ìë™ ì €ì¥)</div>
    <div id="chartShots"></div>
  </div>

  <script>
    // ================= ê³µí†µ ìœ í‹¸ =================
    const sleep = (ms) => new Promise((res) => setTimeout(res, ms));

    // DOM ì°¸ì¡°
    const videoEl = document.getElementById("camera");
    const canvasEl = document.getElementById("captureCanvas");
    const ctx = canvasEl.getContext("2d");
    const ocrAccumulated = document.getElementById("ocrAccumulated");
    const statusEl = document.getElementById("status");
    const shareStatusEl = document.getElementById("shareStatus");
    const chartShotsContainer = document.getElementById("chartShots");
    const ocrToggleBtn = document.getElementById("ocrToggleBtn");
    const shareBtn = document.getElementById("shareBtn");
    const ttsBox = document.getElementById("ttsBox");

    // OCR ì„¤ì •
    const SHOTS_PER_PAGE = 3;
    const DELAY_BETWEEN_SHOTS_MS = 3500;
    const DELAY_BETWEEN_PAGES_MS = 5000;
    const MAX_PAGES = 10;

    let isOcrRunning = false;
    let streamStarted = false;
    let currentPage = 1;
    let finalShots = [];       // {page, text, confidence}
    let chartImages = [];      // {page, blob}
    let ttsWarmupDone = false;

    // ================ ì¹´ë©”ë¼ =================
    async function setupCamera() {
      if (streamStarted) return;
      try {
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio: false,
        });
        videoEl.srcObject = stream;
        streamStarted = true;
      } catch (err) {
        statusEl.textContent = "ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: " + err.message;
      }
    }

    async function captureFrameToBlob() {
      if (!videoEl.videoWidth || !videoEl.videoHeight) {
        throw new Error("ì¹´ë©”ë¼ê°€ ì•„ì§ ì¤€ë¹„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
      }
      const maxSide = Math.max(videoEl.videoWidth, videoEl.videoHeight);
      const scale = 1024 / maxSide;
      const w = Math.round(videoEl.videoWidth * scale);
      const h = Math.round(videoEl.videoHeight * scale);
      canvasEl.width = w;
      canvasEl.height = h;
      ctx.drawImage(videoEl, 0, 0, w, h);
      return new Promise((resolve) =>
        canvasEl.toBlob(resolve, "image/jpeg", 0.9)
      );
    }

    // ================ OCR í˜¸ì¶œ (Netlify í•¨ìˆ˜ ê²½ë¡œ í™•ì¸í•´ì„œ í•„ìš”í•˜ë©´ ìˆ˜ì •) ================
    async function callOcrServer(imageBlob) {
      const form = new FormData();
      form.append("file", imageBlob, "capture.jpg");
      form.append("language", "kor+eng");
      form.append("isOverlayRequired", "true");

      const res = await fetch("/.netlify/functions/ocr", {
        method: "POST",
        body: form,
      });

      if (!res.ok) {
        throw new Error("OCR ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜");
      }
      const data = await res.json();

      let text = "";
      let confidence = 0;

      if (data && data.ParsedResults && data.ParsedResults.length > 0) {
        const pr = data.ParsedResults[0];
        text = (pr.ParsedText || "").trim();

        if (pr.TextOverlay && Array.isArray(pr.TextOverlay.Lines)) {
          let sum = 0;
          let cnt = 0;
          for (const line of pr.TextOverlay.Lines) {
            if (!line.Words) continue;
            for (const w of line.Words) {
              if (typeof w.WordConfidence === "number") {
                sum += w.WordConfidence;
                cnt++;
              }
            }
          }
          if (cnt > 0) confidence = sum / cnt;
        }
      }

      // ì‹ ë¢°ë„ ì •ë³´ê°€ ë¹„ì–´ ìˆìœ¼ë©´, ëŒ€ëµì ì¸ ê¸¸ì´ ê¸°ë°˜ ê°€ì§œ ì ìˆ˜
      if (!confidence && text) {
        const len = text.replace(/\s+/g, "").length;
        confidence = Math.min(99, 40 + len / 10);
      }

      return { text, confidence };
    }

    // ================ íŒ¨í„´ íƒì§€ =================
    function looksLikeChartPage(text) {
      return (text || "").includes("ë„í‘œì…ë‹ˆë‹¤");
    }

    function looksLikeSolveStart(text) {
      if (!text) return false;
      const t = text.replace(/\s+/g, "");
      return (
        t.includes("í’€ì´ì‹œì‘") ||
        t.includes("í’€ì´ë¥¼ì‹œì‘í•˜ì‹œì˜¤") ||
        t.includes("í’€ì´ë“¤ì‹œì‘í•˜ì‹œì˜¤")
      );
    }

    // ================ ì•ˆë‚´ìš© TTS (ì§§ì€ ìŒì„±) ================
    function speakGuideOnce(text) {
      if (!window.speechSynthesis) return;
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "ko-KR";
      u.rate = 1.0;
      u.pitch = 1.0;
      window.speechSynthesis.speak(u);
    }

    // ================ ë©”ì¸ OCR ë£¨í”„ =================
    async function captureAndOcrOnce() {
      const blob = await captureFrameToBlob();
      const result = await callOcrServer(blob);
      return { blob, text: result.text, confidence: result.confidence };
    }

    function rebuildAccumulatedText() {
      let buf = "[ì—°ì„¸ëŒ€ ì‚¬íšŒ í¸ì… ë…¼ìˆ  OCR TEXT]\n\n[OCR TEXT START]\n";
      for (const shot of finalShots) {
        const c = isFinite(shot.confidence)
          ? shot.confidence.toFixed(1)
          : "0.0";
        buf += `[ìƒ· ${shot.page}] ---------------------- (í˜ì´ì§€ ${shot.page}, ì‹ ë¢°ë„ ëŒ€ëµ ${c}%)\n`;
        buf += (shot.text || "").trim() + "\n\n";
      }
      buf += "[OCR TEXT END]";
      ocrAccumulated.value = buf;
    }

    async function ocrLoop() {
      isOcrRunning = true;
      currentPage = 1;
      finalShots = [];
      chartImages = [];
      chartShotsContainer.innerHTML = "";
      ocrAccumulated.value = "";
      statusEl.textContent = "ìë™ OCR ì§„í–‰ ì¤‘...";

      while (isOcrRunning && currentPage <= MAX_PAGES) {
        let pageCandidates = [];
        let chartCandidateBlob = null;
        let chartDetected = false;
        let solveDetected = false;

        for (let i = 0; i < SHOTS_PER_PAGE; i++) {
          if (!isOcrRunning) break;

          statusEl.textContent = `í˜ì´ì§€ ${currentPage} - OCR ${i + 1}/${SHOTS_PER_PAGE} ì´¬ì˜ ì¤‘...`;

          try {
            const shot = await captureAndOcrOnce();
            pageCandidates.push(shot);

            const t = shot.text || "";
            if (!chartDetected && looksLikeChartPage(t)) {
              chartDetected = true;
              chartCandidateBlob = shot.blob;
            }
            if (!solveDetected && looksLikeSolveStart(t)) {
              solveDetected = true;
            }
          } catch (err) {
            statusEl.textContent = "ìº¡ì²˜/ì¸ì‹ ì˜¤ë¥˜: " + err.message;
          }

          await sleep(DELAY_BETWEEN_SHOTS_MS);
        }

        if (pageCandidates.length === 0) break;

        // ì´ í˜ì´ì§€ì—ì„œ ì œì¼ ì¢‹ì€ ê²°ê³¼ ì„ íƒ
        pageCandidates.sort(
          (a, b) =>
            b.confidence - a.confidence ||
            (b.text || "").length - (a.text || "").length
        );
        const best = pageCandidates[0];
        finalShots.push({
          page: currentPage,
          text: best.text,
          confidence: best.confidence,
        });
        rebuildAccumulatedText();

        // ë„í‘œ í˜ì´ì§€ë©´ ì´ë¯¸ì§€ ì €ì¥ + ì¸ë„¤ì¼
        if (chartDetected && chartCandidateBlob) {
          chartImages.push({ page: currentPage, blob: chartCandidateBlob });
          const url = URL.createObjectURL(chartCandidateBlob);
          const img = document.createElement("img");
          img.src = url;
          img.alt = `ë„í‘œ í˜ì´ì§€ ${currentPage}`;
          img.className = "chart-thumb";
          chartShotsContainer.appendChild(img);
        }

        if (solveDetected) {
          statusEl.textContent =
            "í’€ì´ ì‹œì‘ ë¬¸êµ¬ ê°ì§€: ì´ í˜ì´ì§€ê¹Œì§€ ì¸ì‹ í›„ ìë™ OCR ì¢…ë£Œ.";
          speakGuideOnce(
            "ì´ í˜ì´ì§€ ì¸ì‹ ì™„ë£Œ. ì´ì œ ë§ˆì§€ë§‰ í˜ì´ì§€ì…ë‹ˆë‹¤. ìë™ O C R ì„ ì¢…ë£Œí•©ë‹ˆë‹¤."
          );
          break;
        } else {
          currentPage++;
          if (currentPage > MAX_PAGES) {
            statusEl.textContent = "ìµœëŒ€ í˜ì´ì§€ ìˆ˜ì— ë„ë‹¬í•˜ì—¬ ìë™ OCRì„ ì¢…ë£Œí•©ë‹ˆë‹¤.";
            break;
          }
          speakGuideOnce("ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”. 5, 4, 3, 2, 1.");
          await sleep(DELAY_BETWEEN_PAGES_MS);
        }
      }

      isOcrRunning = false;
      ocrToggleBtn.textContent = "ğŸ“¸ ìë™ OCR ì‹œì‘/ì •ì§€";
    }

    // ================ ë²„íŠ¼ ì´ë²¤íŠ¸ =================
    ocrToggleBtn.addEventListener("click", async () => {
      // iOS TTS ì›Œë°ì—… í•œ ë²ˆ
      if (!ttsWarmupDone && window.speechSynthesis) {
        try {
          const t = new SpeechSynthesisUtterance("TTS í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤.");
          t.lang = "ko-KR";
          t.rate = 1.0;
          window.speechSynthesis.speak(t);
        } catch (e) {
          // ë¬´ì‹œ
        }
        ttsWarmupDone = true;
      }

      if (isOcrRunning) {
        isOcrRunning = false;
        statusEl.textContent = "ì‚¬ìš©ìì— ì˜í•´ ìë™ OCR ì¤‘ì§€.";
        ocrToggleBtn.textContent = "ğŸ“¸ ìë™ OCR ì‹œì‘/ì •ì§€";
        return;
      }

      await setupCamera();
      if (!streamStarted) return;

      ocrToggleBtn.textContent = "â¹ ìë™ OCR ì •ì§€";
      ocrLoop();
    });

    shareBtn.addEventListener("click", async () => {
      const text = (ocrAccumulated.value || "").trim();
      if (!text) {
        shareStatusEl.textContent = "ê³µìœ í•  OCR í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.";
        return;
      }
      shareStatusEl.textContent = "";

      let files = [];
      if (chartImages.length > 0 && window.File && navigator.canShare) {
        try {
          const lastChart = chartImages[chartImages.length - 1];
          const file = new File(
            [lastChart.blob],
            "chart-page.jpg",
            { type: "image/jpeg" }
          );
          if (navigator.canShare({ files: [file] })) {
            files = [file];
          }
        } catch (e) {
          // ì´ë¯¸ì§€ ê³µìœ  ì‹¤íŒ¨í•´ë„ í…ìŠ¤íŠ¸ëŠ” ê³µìœ 
        }
      }

      if (navigator.share) {
        try {
          if (files.length > 0) {
            await navigator.share({ text, files });
          } else {
            await navigator.share({ text });
          }
          shareStatusEl.textContent =
            "ê³µìœ  ì‹œíŠ¸ê°€ ì—´ë ¸ë‹¤ë©´ ChatGPT ì•±ì„ ì„ íƒí•˜ê±°ë‚˜, ë³µì‚¬ë¥¼ ëˆŒëŸ¬ ì§ì ‘ ë¶™ì—¬ ë„£ìœ¼ë©´ ëœë‹¤.";
        } catch (err) {
          shareStatusEl.textContent =
            "ê³µìœ  ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: " + (err.message || err.toString());
        }
      } else if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(text);
          shareStatusEl.textContent =
            "ì´ ë¸Œë¼ìš°ì €ëŠ” ê³µìœ ë¥¼ ì§€ì›í•˜ì§€ ì•Šì•„ í…ìŠ¤íŠ¸ë§Œ í´ë¦½ë³´ë“œì— ë³µì‚¬í–ˆë‹¤. ChatGPT ì•±ì— ë¶™ì—¬ ë„£ì–´ë¼.";
        } catch (err) {
          shareStatusEl.textContent =
            "í´ë¦½ë³´ë“œ ë³µì‚¬ ì‹¤íŒ¨: " + (err.message || err.toString());
        }
      } else {
        shareStatusEl.textContent =
          "ê³µìœ ì™€ í´ë¦½ë³´ë“œë¥¼ ëª¨ë‘ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” í™˜ê²½ì´ë‹¤.";
      }
    });

    // ================ ë‹µì•ˆ TTS (ë‹¨ì–´ ì‚¬ì´ 7ì´ˆ, ê¸°í˜¸ ì½ê¸°) =================
    let answerTtsStop = false;

    function preprocessAnswerForTTS(raw) {
      let t = String(raw || "");

      // ì¤„ë°”ê¿ˆ -> "ì¤„ë°”ê¿ˆ"
      t = t.replace(/\r/g, "");
      t = t.replace(/\n+/g, " ì¤„ë°”ê¿ˆ ");

      // ë§ˆì¹¨í‘œ, ì‰¼í‘œ
      t = t.replace(/\./g, " ë§ˆì¹¨í‘œ ");
      t = t.replace(/,/g, " ì‰¼í‘œ ");

      // ê´„í˜¸ë¥˜
      t = t.replace(/\(/g, " ì†Œê´„í˜¸ ì—¬ëŠ” ê´„í˜¸ ");
      t = t.replace(/\)/g, " ì†Œê´„í˜¸ ë‹«ëŠ” ê´„í˜¸ ");
      t = t.replace(/\[/g, " ëŒ€ê´„í˜¸ ì—¬ëŠ” ê´„í˜¸ ");
      t = t.replace(/\]/g, " ëŒ€ê´„í˜¸ ë‹«ëŠ” ê´„í˜¸ ");
      t = t.replace(/</g, " êº¾ì‡  ì—¬ëŠ” ê´„í˜¸ ");
      t = t.replace(/>/g, " êº¾ì‡  ë‹«ëŠ” ê´„í˜¸ ");

      // ë”°ì˜´í‘œ
      t = t.replace(/"/g, " í°ë”°ì˜´í‘œ ");
      t = t.replace(/'/g, " ì‘ì€ë”°ì˜´í‘œ ");

      // ê¸°íƒ€ ê¸°í˜¸
      t = t.replace(/%/g, " í¼ì„¼íŠ¸ ");
      t = t.replace(/\*/g, " ë³„í‘œ ");
      t = t.replace(/-/g, " ë¹¼ê¸° ê¸°í˜¸ ");
      t = t.replace(/_/g, " ë°‘ì¤„ ");

      // ê³µë°± ì •ë¦¬
      t = t.replace(/\s+/g, " ").trim();
      return t;
    }

    function speakAnswerWithLongGaps(text) {
      if (!window.speechSynthesis) return;

      const processed = preprocessAnswerForTTS(text);
      const tokens = processed.split(" ").filter(Boolean);
      if (!tokens.length) return;

      // ì´ì „ ì½ê¸° ì¤‘ë‹¨
      answerTtsStop = false;
      window.speechSynthesis.cancel();

      let idx = 0;

      function speakNext() {
        if (answerTtsStop) return;

        // ë‹¤ ì½ì—ˆìœ¼ë©´ ì²˜ìŒë¶€í„° ë°˜ë³µ
        if (idx >= tokens.length) {
          idx = 0;
          setTimeout(speakNext, 1500);
          return;
        }

        const word = tokens[idx++];
        const u = new SpeechSynthesisUtterance(word);
        u.lang = "ko-KR";
        u.rate = 0.9; // 0.9ë°°ì†
        u.pitch = 1.0;

        u.onend = () => {
          if (answerTtsStop) return;
          // ë‹¨ì–´ ì‚¬ì´ 7ì´ˆ ì¹¨ë¬µ
          setTimeout(speakNext, 7000);
        };
        u.onerror = () => {
          if (answerTtsStop) return;
          setTimeout(speakNext, 7000);
        };

        window.speechSynthesis.speak(u);
      }

      speakNext();
    }

    if (ttsBox) {
      ttsBox.addEventListener("input", () => {
        const txt = (ttsBox.value || "").trim();

        if (!txt) {
          answerTtsStop = true;
          if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
          }
          return;
        }

        speakAnswerWithLongGaps(txt);
      });
    }

    function stopAnswerTTS() {
      answerTtsStop = true;
      if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
      }
    }
  </script>
</body>
</html>
