<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Answer Site</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { max-width: 820px; margin: 32px auto; padding: 0 16px; }
    textarea { width: 100%; min-height: 120px; padding: 12px; font-size: 16px; }
    button { padding: 10px 16px; font-size: 16px; cursor: pointer; }
    .row { display: flex; gap: 10px; align-items: center; margin: 12px 0; flex-wrap: wrap; }
    .out { white-space: pre-wrap; background: #f6f7f8; padding: 12px; border-radius: 8px; min-height: 48px; }
    .muted { color: #666; font-size: 14px; }
    .error { color: #b00020; }
    .cam-wrap { position: relative; display: inline-block; max-width: 100%; }
    #preview { max-width: 100%; border-radius: 8px; display: none; }
    #roiCanvas {
      position: absolute; inset: 0; display: none;
      touch-action: none;
    }
    .hint { font-size: 13px; color:#555; }
    .panel label { display:block; font-size:13px; margin-bottom:4px; }
    .panel input[type=range]{ width:220px; }
  </style>
</head>
<body>
  <h1>정답 풀이 테스트</h1>
  <p class="muted">질문을 적고 <b>보내기</b>를 누르면 <code>/.netlify/functions/solve</code>로 POST합니다.</p>

  <textarea id="q" placeholder="여기에 질문/문제 텍스트를 입력하거나 OCR로 채워보세요."></textarea>
  <div class="row">
    <button id="send">보내기</button>
    <span id="status" class="muted"></span>
  </div>

  <h3>결과</h3>
  <div id="out" class="out"></div>

  <hr>
  <h3>카메라 · OCR · 음성</h3>

  <div class="row">
    <button id="camStart">카메라 켜기</button>
    <button id="camShot" disabled>캡처 → OCR</button>
    <button id="camStop" disabled>카메라 끄기</button>
    <button id="speak" disabled>정답만 읽어주기(TTS)</button>
    <span id="ocrStatus" class="muted"></span>
  </div>

  <div class="row" style="align-items:center">
    <label style="display:flex; gap:8px; align-items:center">
      <input type="checkbox" id="autoMode">
      <span>자동 모드(안정 시 자동 풀이)</span>
    </label>
    <span id="autoStatus" class="muted"></span>
    <span id="autoDebug" class="muted"></span> <!-- 변화율/남은 안정 디버그 -->
  </div>

  <!-- 자동 모드 파라미터 조절 패널 -->
  <div id="autoPanel" class="row panel" style="gap:18px; align-items:flex-end">
    <div>
      <label>민감도(변화 허용 비율)
        <input id="inpThreshold" type="range" min="0.03" max="0.40" step="0.01" value="0.30">
      </label>
      <div class="muted">현재: <span id="lblThreshold">0.30</span></div>
    </div>
    <div>
      <label>체크 주기(ms)
        <input id="inpInterval" type="range" min="200" max="1500" step="50" value="900">
      </label>
      <div class="muted">현재: <span id="lblInterval">900</span> ms</div>
    </div>
    <div>
      <label>안정 시간(s)
        <input id="inpStable" type="range" min="1" max="8" step="1" value="2">
      </label>
      <div class="muted">현재: <span id="lblStable">2</span> s</div>
    </div>
    <div>
      <label>쿨다운(s)
        <input id="inpCooldown" type="range" min="5" max="30" step="1" value="6">
      </label>
      <div class="muted">현재: <span id="lblCooldown">6</span> s</div>
    </div>
  </div>

  <div class="hint">TIP: 비디오 위를 <b>드래그</b>하면 파란 박스로 <b>영역 지정</b>이 됩니다. ROI가 없을 땐 화면 가장자리 10%는 자동으로 무시해 배경/손 영향이 줄어듭니다.</div>

  <div class="cam-wrap">
    <video id="preview" autoplay playsinline></video>
    <canvas id="roiCanvas"></canvas>
  </div>
  <canvas id="frame" style="display:none"></canvas>

  <!-- Tesseract.js (OCR) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <script>
    /* ===== 질문 전송 ===== */
    const $q = document.getElementById('q');
    const $btn = document.getElementById('send');
    const $out = document.getElementById('out');
    const $status = document.getElementById('status');

    async function ask() {
      const question = ($q.value || '').trim();
      if (!question) { $out.textContent = ''; $status.textContent = '질문을 입력하세요.'; return; }
      $status.textContent = '요청 중...'; $btn.disabled = true; $out.textContent = '';
      try {
        const res = await fetch('/.netlify/functions/solve', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ question })
        });
        const ct = res.headers.get('content-type') || '';
        let answerText = '';
        if (ct.includes('application/json')) {
          const data = await res.json(); answerText = data.answer ?? JSON.stringify(data, null, 2);
        } else {
          const text = await res.text();
          try { const maybe = JSON.parse(text); answerText = maybe.answer ?? text; }
          catch { answerText = text; }
        }
        $out.textContent = answerText;
        $status.textContent = res.ok ? '완료' : `에러: ${res.status}`;
      } catch (err) {
        console.error(err);
        $status.innerHTML = `<span class="error">요청 실패: ${String(err)}</span>`;
      } finally {
        $btn.disabled = false;
      }
    }
    $btn.addEventListener('click', ask);
    $q.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && (e.metaKey || e.ctrlKey)) ask();
    });

    /* ===== 카메라 + ROI + OCR + TTS ===== */
    const $video = document.getElementById('preview');
    const $canvas = document.getElementById('frame');
    const $roiCanvas = document.getElementById('roiCanvas');
    const $camStart = document.getElementById('camStart');
    const $camShot  = document.getElementById('camShot');
    const $camStop  = document.getElementById('camStop');
    const $speak    = document.getElementById('speak');
    const $ocrStatus = document.getElementById('ocrStatus');

    let stream;

    // ▶ 캔버스 오버레이를 실제 video 렌더 크기에 맞춤
    function resizeOverlay() {
      const rect = $video.getBoundingClientRect();
      $roiCanvas.width = rect.width;
      $roiCanvas.height = rect.height;
      $roiCanvas.style.width = rect.width + 'px';
      $roiCanvas.style.height = rect.height + 'px';
      $roiCanvas.style.left = $video.offsetLeft + 'px';
      $roiCanvas.style.top  = $video.offsetTop  + 'px';
      drawROI();
    }
    window.addEventListener('resize', () => {
      if ($video.style.display !== 'none') resizeOverlay();
    });

    // ▶ 카메라 켜기 (play() 보장 + overlay 사이즈 셋업)
    async function startCamera() {
      try {
        $ocrStatus.textContent = '카메라 권한 요청 중...';
        const constraints = { video: { facingMode: 'environment' }, audio: false };
        stream = await navigator.mediaDevices.getUserMedia(constraints);

        $video.srcObject = stream;
        $video.style.display = 'block';
        $roiCanvas.style.display = 'block';

        const ensureReady = new Promise(resolve => {
          const onReady = async () => {
            try { await $video.play(); } catch (_) {}
            resizeOverlay();
            resolve();
          };
          if ($video.readyState >= 1) onReady();
          else $video.addEventListener('loadedmetadata', onReady, { once: true });
        });
        await ensureReady;

        $camShot.disabled = false;
        $camStop.disabled = false;
        $ocrStatus.textContent = '카메라 ON';

        if ($auto.checked) startAuto();
      } catch (e) {
        console.error(e);
        $ocrStatus.textContent = '카메라 접근 실패: ' + (e && e.message ? e.message : e);
      }
    }

    function stopCamera() {
      if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
      $video.pause();
      $video.srcObject = null;
      $video.style.display = 'none';
      $roiCanvas.style.display = 'none';
      $camShot.disabled = true;
      $camStop.disabled = true;
      $ocrStatus.textContent = '카메라 OFF';
      stopAuto();
    }

    // ROI 드래그
    let dragging = false, roi = null;
    function drawROI() {
      const ctx = $roiCanvas.getContext('2d'); ctx.clearRect(0,0,$roiCanvas.width,$roiCanvas.height);
      if (!roi) return;
      ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(0,0,$roiCanvas.width,$roiCanvas.height);
      ctx.clearRect(roi.x, roi.y, roi.w, roi.h);
      ctx.strokeStyle='#3b82f6'; ctx.lineWidth=2; ctx.strokeRect(roi.x, roi.y, roi.w, roi.h);
    }
    function pointerPos(e){ const r=$roiCanvas.getBoundingClientRect();
      const x=e.touches?e.touches[0].clientX:e.clientX, y=e.touches?e.touches[0].clientY:e.clientY;
      return {x:Math.max(0,Math.min(r.width,x-r.left)), y:Math.max(0,Math.min(r.height,y-r.top))}; }
    function startDrag(e){ dragging=true; const p=pointerPos(e); roi={x:p.x,y:p.y,w:0,h:0}; drawROI(); }
    function moveDrag(e){ if(!dragging) return; const p=pointerPos(e);
      roi.w=p.x-roi.x; roi.h=p.y-roi.y;
      const nx=Math.min(roi.x,roi.x+roi.w), ny=Math.min(roi.y,roi.y+roi.h);
      const nw=Math.abs(roi.w), nh=Math.abs(roi.h); roi={x:nx,y:ny,w:nw,h:nh}; drawROI();
    }
    function endDrag(){ dragging=false; }
    $roiCanvas.addEventListener('mousedown', startDrag);
    $roiCanvas.addEventListener('mousemove', moveDrag);
    window.addEventListener('mouseup', endDrag);
    $roiCanvas.addEventListener('touchstart', e=>{e.preventDefault();startDrag(e);},{passive:false});
    $roiCanvas.addEventListener('touchmove',  e=>{e.preventDefault();moveDrag(e); },{passive:false});
    $roiCanvas.addEventListener('touchend',   e=>{e.preventDefault();endDrag();   },{passive:false});

    // OCR
    async function captureAndOCR() {
      if (!$video.srcObject) return;
      $ocrStatus.textContent = '캡처 중...';

      const vw=$video.videoWidth||1280, vh=$video.videoHeight||720;
      $canvas.width=vw; $canvas.height=vh; const ctx=$canvas.getContext('2d');
      ctx.drawImage($video,0,0,vw,vh);

      let sourceCanvas=$canvas;
      if (roi && roi.w>8 && roi.h>8) {
        const vis=$video.getBoundingClientRect();
        const sx=Math.round(roi.x*(vw/vis.width)),  sy=Math.round(roi.y*(vh/vis.height));
        const sw=Math.round(roi.w*(vw/vis.width)),  sh=Math.round(roi.h*(vh/vis.height));
        const crop=document.createElement('canvas'); crop.width=sw; crop.height=sh;
        crop.getContext('2d').drawImage($canvas,sx,sy,sw,sh,0,0,sw,sh);
        sourceCanvas=crop;
      }

      $ocrStatus.textContent='OCR 인식 중...';
      try {
        const { data } = await Tesseract.recognize(sourceCanvas, 'kor+eng', {
          langPath: 'https://tessdata.projectnaptha.com/4.0.0'
        });
        const text=(data?.text||'').trim();
        if (text){ $q.value=text; $ocrStatus.textContent='OCR 완료 ✅'; }
        else { $ocrStatus.textContent='문자 인식 실패'; }
      } catch(e){ console.error(e); $ocrStatus.textContent='OCR 오류: '+e.message; }
    }

    function extractAnswerOnly(fullText){
      if (!fullText) return '';
      const m1 = fullText.match(/(?:정답|answer)\s*[:：]\s*([^\n]+)/i);
      if (m1) return m1[1].trim();
      const line = fullText.split(/\r?\n/).find(l=>/정답|answer/i.test(l));
      if (line) return line.replace(/.*?(정답|answer)\s*[:：]?\s*/i,'').trim();
      return fullText.split(/\r?\n/)[0].trim();
    }
    function speakResult(){
      const full=$out.textContent.trim(); if(!full){ $ocrStatus.textContent='읽을 결과가 없습니다.'; return; }
      const key=extractAnswerOnly(full); const u=new SpeechSynthesisUtterance(key||full);
      u.lang='ko-KR'; window.speechSynthesis.cancel(); window.speechSynthesis.speak(u);
    }
    $camStart.addEventListener('click', startCamera);
    $camStop .addEventListener('click', stopCamera);
    $camShot .addEventListener('click', captureAndOCR);
    $speak  .addEventListener('click', speakResult);

    const outObserver=new MutationObserver(()=>{ $speak.disabled=!($out.textContent||'').trim().length; });
    outObserver.observe($out,{childList:true,subtree:true,characterData:true});

    /* ===== 자동 모드 (느슨한 안정 판정 → 자동 캡처→OCR→ask→TTS) ===== */
    const $auto = document.getElementById('autoMode');
    const $autoStatus = document.getElementById('autoStatus');
    const $autoDebug = document.getElementById('autoDebug');

    // 기본값(느슨하게): 주변/가벼운 흔들림을 무시
    let DIFF_THRESHOLD = 0.30, CHECK_INTERVAL = 900, STABLE_MS = 2000, COOLDOWN_MS = 6000;

    // 비교용 저해상도 캔버스
    const diffCanvas = document.createElement('canvas');
    const diffCtx = diffCanvas.getContext('2d');

    // 슬라이더 DOM
    const $inpThreshold=document.getElementById('inpThreshold');
    const $inpInterval =document.getElementById('inpInterval');
    const $inpStable   =document.getElementById('inpStable');
    const $inpCooldown =document.getElementById('inpCooldown');
    const $lblThreshold=document.getElementById('lblThreshold');
    const $lblInterval =document.getElementById('lblInterval');
    const $lblStable   =document.getElementById('lblStable');
    const $lblCooldown =document.getElementById('lblCooldown');

    function applyPanelValues(){
      DIFF_THRESHOLD=parseFloat($inpThreshold.value);
      CHECK_INTERVAL=parseInt($inpInterval.value,10);
      STABLE_MS     =parseInt($inpStable.value,10)*1000;
      COOLDOWN_MS   =parseInt($inpCooldown.value,10)*1000;
      $lblThreshold.textContent=DIFF_THRESHOLD.toFixed(2);
      $lblInterval.textContent =CHECK_INTERVAL;
      $lblStable.textContent   =(STABLE_MS/1000).toFixed(0);
      $lblCooldown.textContent =(COOLDOWN_MS/1000).toFixed(0);
      if ($auto.checked) { stopAuto(); startAuto(); }
    }
    [$inpThreshold,$inpInterval,$inpStable,$inpCooldown].forEach(el=>el.addEventListener('input',applyPanelValues));
    applyPanelValues();

    let autoLoopId=null, lastImageData=null, stableSince=0, cooldownUntil=0;

    // ===== 더 무던한 변화율 계산 (EMA 스무딩 + 밝기 비교 + 가장자리 무시) =====
    let ratioEMA = 1;
    const SMOOTH_ALPHA = 0.25; // 0.2~0.35 권장
    const EDGE_IGNORE  = 0.10; // ROI 없을 때 가장자리 10% 무시

    function frameDiffRatio() {
      if (!$video.srcObject || !$video.videoWidth) return 1;

      const w = 480;
      const h = Math.round(w * ($video.videoHeight / $video.videoWidth));
      diffCanvas.width = w; diffCanvas.height = h;
      diffCtx.drawImage($video, 0, 0, w, h);
      const cur = diffCtx.getImageData(0, 0, w, h).data;

      // ROI 없으면 화면 가장자리 일부 무시
      let x0 = 0, y0 = 0, x1 = w, y1 = h;
      if (!roi || roi.w < 8 || roi.h < 8) {
        const m = Math.floor(EDGE_IGNORE * w);
        const n = Math.floor(EDGE_IGNORE * h);
        x0 = m; y0 = n; x1 = w - m; y1 = h - n;
      }

      let diff = 0, total = 0;
      if (!lastImageData) { lastImageData = cur; return 1; }

      // 밝기(Y)만 비교: 색/노이즈 영향 감소
      for (let y = y0; y < y1; y++) {
        for (let x = x0; x < x1; x++) {
          const i  = (y * w + x) * 4;
          const Yr = 0.299 * cur[i]   + 0.587 * cur[i+1] + 0.114 * cur[i+2];
          const Yo = 0.299 * lastImageData[i] + 0.587 * lastImageData[i+1] + 0.114 * lastImageData[i+2];
          const d  = Math.abs(Yr - Yo);
          if (d > 80) diff++; // 작은 흔들림/깜빡임 무시
          total++;
        }
      }
      lastImageData = cur;

      const ratio = (total ? diff / total : 1);
      ratioEMA = SMOOTH_ALPHA * ratio + (1 - SMOOTH_ALPHA) * ratioEMA;
      return ratioEMA; // 스무딩된 변화율
    }

    async function captureOCRAndAsk(){
      await captureAndOCR();
      const q=($q.value||'').trim();
      if (q.length>0){ await ask(); speakResult(); }
    }

    function startAuto(){
      if (!$video.srcObject){ $ocrStatus.textContent='먼저 카메라를 켜주세요.'; $auto.checked=false; return; }
      stableSince=0; lastImageData=null; ratioEMA=1; $autoStatus.textContent='자동 모드 ON';
      if (autoLoopId) clearInterval(autoLoopId);
      autoLoopId=setInterval(async ()=>{
        const now=Date.now();
        const ratio=frameDiffRatio();

        const remainSec = Math.max(0, STABLE_MS-(stableSince?(now-stableSince):0))/1000;
        $autoDebug.textContent = `(EMA) 변화율: ${ratio.toFixed(3)} / 임계: ${DIFF_THRESHOLD.toFixed(2)} · 남은 안정: ${remainSec.toFixed(1)}s`;

        if (now<cooldownUntil){
          $ocrStatus.textContent=`자동 대기 중… ${Math.ceil((cooldownUntil-now)/1000)}s`; return;
        }

        if (ratio < DIFF_THRESHOLD){
          if (!stableSince) stableSince = now;
          const remain = Math.max(0, STABLE_MS - (now - stableSince));
          $ocrStatus.textContent = `안정 감지 중… ${Math.ceil(remain/1000)}s`;
          if (now - stableSince >= STABLE_MS){
            $ocrStatus.textContent='자동 캡처 → OCR 실행!';
            cooldownUntil = now + COOLDOWN_MS;
            stableSince = 0;
            try { await captureOCRAndAsk(); } catch(e){ console.error(e); }
          }
        } else {
          stableSince = 0;
          $ocrStatus.textContent='움직임 감지됨(대기)…';
        }
      }, CHECK_INTERVAL);
    }
    function stopAuto(){ if (autoLoopId) clearInterval(autoLoopId); autoLoopId=null; $autoStatus.textContent='자동 모드 OFF'; }

    $auto.addEventListener('change', ()=>{ if($auto.checked) startAuto(); else stopAuto(); });
  </script>
</body>
</html>
