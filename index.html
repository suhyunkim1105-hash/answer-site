<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>í¸ì…ì˜ì–´ ìë™ OCR â†’ ìë™ í’€ì´ â†’ TTS</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; margin: 0; padding: 16px; background: #0b0d12; color: #e9eef8; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button { padding: 12px 14px; border-radius: 10px; border: 0; background: #2b6cff; color: white; font-weight: 800; }
    button.secondary { background: #2a2f3b; }
    button.danger { background: #ff3b3b; }
    #status { padding: 12px; border-radius: 12px; background: #121622; line-height: 1.5; white-space: pre-wrap; }
    video { width: 100%; max-height: 52vh; border-radius: 14px; background: #000; }
    .small { opacity: 0.85; font-size: 13px; line-height: 1.5; }
    textarea { width: 100%; min-height: 200px; border-radius: 12px; border: 1px solid #2a2f3b; background: #0f1320; color: #dfe7ff; padding: 10px; box-sizing: border-box; }
    .grid { display: grid; grid-template-columns: 1fr; gap: 10px; margin-top: 10px; }
    .pill { display: inline-block; padding: 4px 10px; border-radius: 999px; background: #1b2234; font-size: 12px; font-weight: 700; }
  </style>
</head>
<body>
  <div class="row">
    <button id="btnAuto">ğŸ“¸ ìë™ OCR ì‹œì‘</button>
    <button id="btnStop" class="danger" disabled>â›” ì •ì§€</button>
    <button id="btnTestVoice" class="secondary">ğŸ”Š ìŒì„± í…ŒìŠ¤íŠ¸</button>
  </div>

  <div style="margin-top:12px" id="status">ëŒ€ê¸° ì¤‘ì´ë‹¤. â€˜ìë™ OCR ì‹œì‘â€™ì„ ëˆ„ë¥´ë©´ ì¹´ë©”ë¼ë¥¼ ì—°ë‹¤.</div>

  <div class="small" style="margin-top:8px">
    - ë§ˆì§€ë§‰ í˜ì´ì§€ ì—¬ë°±ì— <b>ì´¬ì˜ì™„ë£Œ</b>ë¥¼ í¬ê²Œ ì“°ë©´(ê¶Œì¥: â€œì´¬ì˜ì™„ë£Œ DONEâ€) ì¦‰ì‹œ OCR ì¢…ë£Œ í›„ ìë™ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br/>
    - OCR í’ˆì§ˆì´ ë‚®ìœ¼ë©´ â€œë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”â€ë¼ê³  ë§í•˜ê³  ê°™ì€ í˜ì´ì§€ë¥¼ ìë™ìœ¼ë¡œ ë°˜ë³µ ì´¬ì˜í•œë‹¤(ìˆ˜ë™ í¸ì§‘ ì—†ìŒ).<br/>
    - iOS ì‚¬íŒŒë¦¬ TTSëŠ” ìµœì´ˆ 1íšŒ ì‚¬ìš©ì í„°ì¹˜ ì´í›„ ì•ˆì •ì ì´ë¯€ë¡œ â€œìŒì„± í…ŒìŠ¤íŠ¸â€ë¥¼ í•œ ë²ˆ ëˆ„ë¥´ëŠ” í¸ì´ ì¢‹ë‹¤.
  </div>

  <div class="grid">
    <video id="video" autoplay playsinline muted></video>

    <div class="small">
      í˜ì´ì§€: <span class="pill" id="pagePill">-</span>
      &nbsp;|&nbsp; ë‹¨ê³„: <span class="pill" id="phasePill">IDLE</span>
      &nbsp;|&nbsp; ë©€í‹°ìƒ·: <span class="pill" id="shotPill">-</span>
    </div>

    <textarea id="ocrAll" placeholder="OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸ìš©). ìë™ìœ¼ë¡œ ì±„ì›Œì§„ë‹¤." spellcheck="false"></textarea>
  </div>

<script>
(() => {
  "use strict";

  // ===== ì„¤ì •(í•„ìš” ì‹œ ì—¬ê¸°ë§Œ ì¡°ì •) =====
  const SHOTS_PER_PAGE_BASE = 3;          // ê¸°ë³¸ ë©€í‹°ìƒ·
  const SHOTS_PER_PAGE_MAX  = 5;          // ì‹¤íŒ¨ê°€ ë°˜ë³µë˜ë©´ ìë™ìœ¼ë¡œ 5ìƒ·ê¹Œì§€ ëŠ˜ë¦¼
  const BETWEEN_PAGES_SECONDS = 10;       // ë‹¤ìŒ í˜ì´ì§€ ë„˜ê¸¸ ì‹œê°„(ì¹´ìš´íŠ¸ë‹¤ìš´)
  const RETRY_SECONDS = 5;                // ë¶ˆí•©ê²© í˜ì´ì§€ ì¬ì´¬ì˜ê¹Œì§€ ì‹œê°„
  const MIN_TEXT_LEN = 120;               // ë„ˆë¬´ ì§§ìœ¼ë©´ ë¶ˆí•©ê²©(ì§€ë¬¸ í˜ì´ì§€ ê³ ë ¤í•´ ë‚®ì¶¤)
  const SOLVE_CHUNK_SIZE = 10;            // 10ë¬¸í•­ ë‹¨ìœ„ ìë™ í’€ì´ í˜¸ì¶œ

  // â€œì™„ì „ ìë™â€ì„ ìœ„í•´ ì¬ì‹œë„í•˜ë©´ ê¸°ì¤€ ìë™ ì™„í™”(0.03ì”© ì™„í™”, ìµœëŒ€ 0.18 ì™„í™”)
  const RELAX_PER_RETRY = 0.03;
  const RELAX_MAX = 0.18;

  // TTS
  const TTS_LANG = "ko-KR";
  const TTS_RATE = 0.95;

  // ===== ìƒíƒœ =====
  let stream = null;
  let running = false;
  let phase = "IDLE";
  let currentPageIndex = 1;
  let retryCountSamePage = 0;

  // pages[pageIndex] = { pageIndex, bestText, bestConf, bestScore, shotsCount }
  const pages = [];

  // ===== DOM =====
  const video = document.getElementById("video");
  const statusEl = document.getElementById("status");
  const pagePill = document.getElementById("pagePill");
  const phasePill = document.getElementById("phasePill");
  const shotPill = document.getElementById("shotPill");
  const ocrAll = document.getElementById("ocrAll");

  const btnAuto = document.getElementById("btnAuto");
  const btnStop = document.getElementById("btnStop");
  const btnTestVoice = document.getElementById("btnTestVoice");

  // ===== ìœ í‹¸ =====
  function setPhase(p) {
    phase = p;
    phasePill.textContent = p;
  }
  function setStatus(msg) {
    statusEl.textContent = msg;
  }
  function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

  async function speak(text) {
    try { window.speechSynthesis.cancel(); } catch {}
    return new Promise((resolve) => {
      const u = new SpeechSynthesisUtterance(String(text || ""));
      u.lang = TTS_LANG;
      u.rate = TTS_RATE;
      u.pitch = 1.0;
      u.onend = () => resolve();
      u.onerror = () => resolve();
      window.speechSynthesis.speak(u);
    });
  }

  async function speakCountdown(seconds) {
    for (let i = seconds; i >= 1; i--) {
      if (!running) return;
      await speak(String(i));
      await sleep(120);
    }
  }

  function normalizeForMarker(s) {
    return (s || "")
      .replace(/\s+/g, "")
      .replace(/[^\p{L}\p{N}]/gu, "")
      .toLowerCase();
  }

  function levenshtein(a, b) {
    if (a === b) return 0;
    const al = a.length, bl = b.length;
    if (al === 0) return bl;
    if (bl === 0) return al;
    const dp = Array.from({ length: al + 1 }, () => new Array(bl + 1).fill(0));
    for (let i = 0; i <= al; i++) dp[i][0] = i;
    for (let j = 0; j <= bl; j++) dp[0][j] = j;
    for (let i = 1; i <= al; i++) {
      for (let j = 1; j <= bl; j++) {
        const cost = a[i - 1] === b[j - 1] ? 0 : 1;
        dp[i][j] = Math.min(
          dp[i - 1][j] + 1,
          dp[i][j - 1] + 1,
          dp[i - 1][j - 1] + cost
        );
      }
    }
    return dp[al][bl];
  }

  // ì´¬ì˜ì™„ë£Œ ê°ì§€: ê°•(ì •í™•) + ì•½(í¼ì§€/ê·¼ì ‘/ì˜ì–´DONE)
  function hasCompletionMarker(text) {
    const norm = normalizeForMarker(text);
    if (!norm) return false;

    if (norm.includes("ì´¬ì˜ì™„ë£Œ")) return true;
    if (norm.includes("ì´¬ì˜ì™„ë£Œdone") || norm.includes("ì´¬ì˜ì™„ë£Œend")) return true;

    const idxA = norm.indexOf("ì´¬ì˜");
    const idxB = norm.indexOf("ì™„ë£Œ");
    if (idxA !== -1 && idxB !== -1 && Math.abs(idxB - idxA) <= 10) return true;

    // í¸ì§‘ê±°ë¦¬ <= 1ì¸ êµ¬ê°„ ì¡´ì¬(ì˜ˆ: ì´¤ì˜ì™„ë£Œ, ì´¬ì˜ì™„ë¡œ)
    const target = "ì´¬ì˜ì™„ë£Œ";
    for (let i = 0; i <= norm.length - target.length; i++) {
      const sub = norm.slice(i, i + target.length);
      if (levenshtein(sub, target) <= 1) return true;
    }

    // DONEë§Œ ìˆì–´ë„ ì¢…ë£Œì‹œí‚¤ë©´ ì˜¤ê²€ì¶œì´ ìˆì„ ìˆ˜ ìˆì–´ â€œì´¬ì˜/ì™„ë£Œâ€ ë˜ëŠ” â€œì´¬ì˜ì™„ë£Œâ€ì™€ í•¨ê»˜ë§Œ ì¸ì •
    if (norm.includes("done") && (norm.includes("ì´¬ì˜") || norm.includes("ì™„ë£Œ"))) return true;

    return false;
  }

  function makeCanvasFromVideo() {
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;
    if (!vw || !vh) return null;

    const canvas = document.createElement("canvas");

    // iOS ë©”ëª¨ë¦¬/ì†ë„ ê³ ë ¤: ë„ˆë¹„ ìƒí•œ
    const maxW = 1700;
    const scale = Math.min(1, maxW / vw);
    canvas.width = Math.floor(vw * scale);
    canvas.height = Math.floor(vh * scale);

    const ctx = canvas.getContext("2d", { alpha: false });
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    return canvas;
  }

  function canvasToJpegBase64(canvas) {
    return canvas.toDataURL("image/jpeg", 0.92);
  }

  // ì§€ë¬¸-only í˜ì´ì§€ë„ í†µê³¼ ê°€ëŠ¥í•˜ë„ë¡ ì ìˆ˜ì‹ì„ ë¶„ê¸°í•œë‹¤.
  function textQualityScore(text) {
    const t = (text || "").trim();
    if (!t) return 0;

    const len = t.length;
    const lenScore = Math.max(0, Math.min(1, (len - 120) / 1200));

    const letters = (t.match(/[A-Za-z]/g) || []).length;
    const ratio = letters / Math.max(1, len);
    const engScore = Math.max(0, Math.min(1, (ratio - 0.05) / 0.28));

    const circled = ["â‘ ","â‘¡","â‘¢","â‘£","â‘¤"];
    let circCount = 0;
    for (const c of circled) if (t.includes(c)) circCount++;
    const choiceScore = circCount >= 5 ? 1 : (circCount / 5);

    let qHits = 0;
    for (let i = 1; i <= 60; i++) {
      const n2 = String(i).padStart(2,"0");
      const re = new RegExp(`(^|\\D)${n2}(\\D)`);
      if (re.test(t)) qHits++;
    }
    const qScore = Math.max(0, Math.min(1, qHits / 8));

    let score;
    if (circCount >= 3) {
      score = 0.32*lenScore + 0.28*choiceScore + 0.18*qScore + 0.22*engScore;
    } else {
      score = 0.60*lenScore + 0.40*engScore;
    }

    return Math.max(0, Math.min(1, score));
  }

  function combinedScore(conf, text) {
    const q = textQualityScore(text);
    if (typeof conf === "number" && isFinite(conf)) {
      return Math.max(0, Math.min(1, 0.60*conf + 0.40*q));
    }
    return q;
  }

  async function callOCR(imageDataUrl) {
    const res = await fetch("/.netlify/functions/ocr", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ imageDataUrl })
    });
    if (!res.ok) {
      const t = await res.text().catch(() => "");
      throw new Error(`OCR HTTP ${res.status}: ${t.slice(0,200)}`);
    }
    const data = await res.json();
    if (!data || !data.ok) {
      throw new Error(data?.error || "OCR failed");
    }
    return data; // {ok, text, conf}
  }

  function appendDebugAllText() {
    let out = "[OCR ëˆ„ì ]\n";
    for (let i = 1; i < pages.length; i++) {
      const p = pages[i];
      if (!p) continue;
      out += `\n[í˜ì´ì§€ ${p.pageIndex}] conf=${(p.bestConf ?? "null")} score=${p.bestScore.toFixed(3)} shots=${p.shotsCount}\n`;
      out += (p.bestText || "").trim() + "\n";
    }
    ocrAll.value = out.trim();
  }

  async function ensureCamera() {
    if (stream) return;

    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      },
      audio: false
    });
    video.srcObject = stream;

    await new Promise((resolve) => {
      if (video.readyState >= 2) return resolve();
      video.addEventListener("loadedmetadata", () => resolve(), { once: true });
    });

    await sleep(200);
  }

  async function stopAll(msg) {
    running = false;
    setPhase("IDLE");
    btnAuto.disabled = false;
    btnStop.disabled = true;
    shotPill.textContent = "-";
    pagePill.textContent = "-";
    try { window.speechSynthesis.cancel(); } catch {}
    setStatus(msg || "ì •ì§€í–ˆë‹¤.");
  }

  // ===== OCR: í•œ í˜ì´ì§€ ë©€í‹°ìƒ· í›„ ë² ìŠ¤íŠ¸ ì±„íƒ =====
  async function ocrOnePage(pageIndex) {
    pagePill.textContent = String(pageIndex);

    const shotsCount = (retryCountSamePage >= 2) ? SHOTS_PER_PAGE_MAX : SHOTS_PER_PAGE_BASE;
    shotPill.textContent = String(shotsCount);

    const shots = [];
    for (let s = 1; s <= shotsCount; s++) {
      if (!running) return null;

      const canvas = makeCanvasFromVideo();
      if (!canvas) throw new Error("ì¹´ë©”ë¼ ìº¡ì²˜ ì‹¤íŒ¨(ë¹„ë””ì˜¤ ì¤€ë¹„ ì „ì¼ ìˆ˜ ìˆë‹¤).");

      const imageDataUrl = canvasToJpegBase64(canvas);

      setStatus(`í˜ì´ì§€ ${pageIndex} OCR ì¤‘ì´ë‹¤. (ìƒ· ${s}/${shotsCount})`);

      try {
        const ocr = await callOCR(imageDataUrl);
        const conf = (typeof ocr.conf === "number" && isFinite(ocr.conf)) ? ocr.conf : null;
        const text = (ocr.text || "");
        const score = combinedScore(conf, text);
        shots.push({ ok: true, conf, text, score });
      } catch (e) {
        shots.push({ ok: false, conf: null, text: "", score: 0, error: String(e) });
      }

      await sleep(120);
    }

    let best = null;
    for (const sh of shots) {
      if (!sh.ok) continue;
      if (!best || sh.score > best.score) best = sh;
    }
    if (!best) {
      return { ok: false, bestText: "", bestConf: null, bestScore: 0, shotsCount };
    }

    return { ok: true, bestText: best.text, bestConf: best.conf, bestScore: best.score, shotsCount };
  }

  function pagePassesThreshold(bestText, bestScore) {
    const t = (bestText || "").trim();
    if (t.length < MIN_TEXT_LEN) return false;

    const relax = Math.min(RELAX_MAX, retryCountSamePage * RELAX_PER_RETRY);
    const required = 0.58 - relax; // ê¸°ë³¸ ê¸°ì¤€(ì™„í™” ì ìš©)
    return bestScore >= required;
  }

  // ====== OCR ë£¨í”„: ì´¬ì˜ì™„ë£Œê¹Œì§€ ======
  async function runOcrLoop() {
    setPhase("OCRING");
    retryCountSamePage = 0;
    currentPageIndex = 1;

    while (running) {
      setStatus(`í˜ì´ì§€ ${currentPageIndex}ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë§ì¶˜ ë’¤ ê°€ë§Œíˆ ìœ ì§€í•˜ë¼.`);
      await sleep(150);

      const result = await ocrOnePage(currentPageIndex);
      if (!result) return; // stopped

      const { ok, bestText, bestConf, bestScore, shotsCount } = result;

      // OCR ìì²´ê°€ í†µìœ¼ë¡œ ì‹¤íŒ¨í–ˆìœ¼ë©´ ì¬ì´¬ì˜
      if (!ok) {
        retryCountSamePage++;
        setStatus(`í˜ì´ì§€ ${currentPageIndex} OCRì´ ì‹¤íŒ¨í–ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜ì„ ìš”êµ¬í•œë‹¤.`);
        await speak(`ì§€ê¸ˆ í˜ì´ì§€ ì¸ì‹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${RETRY_SECONDS}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
        await speakCountdown(RETRY_SECONDS);
        continue;
      }

      // âœ… ì´¬ì˜ì™„ë£ŒëŠ” â€œí’ˆì§ˆê²€ì‚¬ë³´ë‹¤ ë¨¼ì €â€ ì²˜ë¦¬(ë„ˆ ìš”êµ¬ ë°˜ì˜)
      if (hasCompletionMarker(bestText)) {
        pages[currentPageIndex] = {
          pageIndex: currentPageIndex,
          bestText,
          bestConf,
          bestScore,
          shotsCount
        };
        appendDebugAllText();

        setStatus(`â€œì´¬ì˜ì™„ë£Œâ€ë¥¼ ê°ì§€í–ˆë‹¤. OCRì„ ì¢…ë£Œí•˜ê³  ìë™ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.`);
        await speak("ì´¬ì˜ ì™„ë£Œë¥¼ í™•ì¸í–ˆìŠµë‹ˆë‹¤. ì´ì œ ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
        break;
      }

      // í’ˆì§ˆê²€ì‚¬
      if (!pagePassesThreshold(bestText, bestScore)) {
        retryCountSamePage++;
        setStatus(`í˜ì´ì§€ ${currentPageIndex} OCR ë¶ˆí•©ê²©ì´ë‹¤. (score=${bestScore.toFixed(2)}, retry=${retryCountSamePage})\në‹¤ì‹œ ì´¬ì˜ì„ ìš”êµ¬í•œë‹¤.`);
        await speak(`ì§€ê¸ˆ í˜ì´ì§€ ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${RETRY_SECONDS}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
        await speakCountdown(RETRY_SECONDS);
        continue;
      }

      // í•©ê²© ì €ì¥
      pages[currentPageIndex] = {
        pageIndex: currentPageIndex,
        bestText,
        bestConf,
        bestScore,
        shotsCount
      };
      appendDebugAllText();

      // ë‹¤ìŒ í˜ì´ì§€ ì•ˆë‚´
      retryCountSamePage = 0;
      await speak(`ì´ í˜ì´ì§€ ì¸ì‹ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”. ${BETWEEN_PAGES_SECONDS}ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¥¼ ì¸ì‹í•©ë‹ˆë‹¤.`);
      await speakCountdown(BETWEEN_PAGES_SECONDS);
      currentPageIndex++;
    }

    if (!running) return;

    await validateThenSolve();
  }

  // ====== íŒŒì‹±/ê²€ì¦/ì¬ì´¬ì˜(ìˆ˜ë™ í¸ì§‘ ì—†ìŒ) ======
  function normalizeTextForParsing(t) {
    return (t || "")
      .replace(/\r/g, "\n")
      .replace(/[ \t]+/g, " ")
      .replace(/\n{3,}/g, "\n\n");
  }

  function coerceChoicesSymbols(t) {
    // ì œí•œì  ë³´ì •: " 1) " í˜•íƒœë¥¼ â‘  ë¡œ ë°”ê¿ˆ(ì˜¤íƒ ì¤„ì´ë ¤ê³  'ê³µë°±+ìˆ«ì+)' ì¡°ê±´ë§Œ)
    return (t || "")
      .replace(/(^|\s)1\)(?=\s*\S)/g, "$1â‘ ")
      .replace(/(^|\s)2\)(?=\s*\S)/g, "$1â‘¡")
      .replace(/(^|\s)3\)(?=\s*\S)/g, "$1â‘¢")
      .replace(/(^|\s)4\)(?=\s*\S)/g, "$1â‘£")
      .replace(/(^|\s)5\)(?=\s*\S)/g, "$1â‘¤");
  }

  function findBestStartIndexForN(text, n) {
    const t = text;
    const n2 = String(n).padStart(2, "0");
    const regs = [
      new RegExp(`(^|\\n)\\s*${n2}\\s+(?=\\S)`, "g"),
      new RegExp(`(^|\\n)\\s*${n}\\s+(?=\\S)`, "g")
    ];

    let best = null; // {idx, bonus}
    for (const re of regs) {
      let m;
      while ((m = re.exec(t)) !== null) {
        const idx = m.index;
        const window = t.slice(idx, Math.min(t.length, idx + 900));
        const hasChoices = window.includes("â‘ ") && window.includes("â‘¡") && window.includes("â‘¢");
        const bonus = hasChoices ? 1 : 0;

        if (!best || bonus > best.bonus || (bonus === best.bonus && idx < best.idx)) {
          best = { idx, bonus };
        }
      }
    }
    return best ? best.idx : -1;
  }

  function parseQuestionsFromFullText(fullText) {
    let t = normalizeTextForParsing(fullText);
    t = coerceChoicesSymbols(t);

    // 1~60ê¹Œì§€ íƒìƒ‰(í•™êµ/ì—°ë„ ë”°ë¼ 50ì´ ì•„ë‹ ê°€ëŠ¥ì„± ëŒ€ë¹„. ì˜ì–´ëŠ” ë³´í†µ 50ì´ì§€ë§Œ í™•ì‹ ì€ ëª» í•œë‹¤.)
    const starts = [];
    for (let n = 1; n <= 60; n++) {
      const idx = findBestStartIndexForN(t, n);
      if (idx !== -1) starts.push({ n, idx });
    }
    starts.sort((a,b) => a.idx - b.idx);

    // segment ë§Œë“¤ê¸°
    const segments = [];
    for (let i = 0; i < starts.length; i++) {
      const start = starts[i].idx;
      const end = (i + 1 < starts.length) ? starts[i+1].idx : t.length;
      const seg = t.slice(start, end).trim();
      segments.push(seg);
    }

    const questions = [];
    const issues = [];
    const seen = new Set();

    for (const seg of segments) {
      const m = seg.match(/^\s*(0?[1-9]|[1-5]\d|60)\b/);
      if (!m) continue;

      const n = Number(m[1]);
      if (!(n >= 1 && n <= 60)) continue;
      if (seen.has(n)) continue;
      seen.add(n);

      const i1 = seg.indexOf("â‘ ");
      const i2 = seg.indexOf("â‘¡");
      const i3 = seg.indexOf("â‘¢");
      const i4 = seg.indexOf("â‘£");
      const i5 = seg.indexOf("â‘¤");

      if ([i1,i2,i3,i4,i5].some(x => x === -1)) {
        issues.push({ type: "choices_missing", n });
        questions.push({ n, stem: seg.slice(0, 240).trim(), choices: [] });
        continue;
      }

      const stem = seg.slice(m[0].length, i1).trim();
      const c1 = seg.slice(i1 + 1, i2).trim();
      const c2 = seg.slice(i2 + 1, i3).trim();
      const c3 = seg.slice(i3 + 1, i4).trim();
      const c4 = seg.slice(i4 + 1, i5).trim();
      const c5 = seg.slice(i5 + 1).trim();

      const choices = [c1,c2,c3,c4,c5].map(s => s.replace(/\s+/g," ").trim());

      if (stem.length < 8) issues.push({ type: "stem_short", n });
      if (choices.some(c => c.length < 3)) issues.push({ type: "choice_short", n });

      questions.push({ n, stem, choices });
    }

    questions.sort((a,b) => a.n - b.n);

    const maxN = questions.length ? Math.max(...questions.map(q => q.n)) : 0;
    // ì˜ì–´ì‹œí—˜ì„ ë³´í†µ 50ë¬¸í•­ìœ¼ë¡œ ë³´ë˜(ëŒ€ë¶€ë¶„), OCR/í˜•ì‹ì— ë”°ë¼ maxNì´ ì¡í ìˆ˜ ìˆìœ¼ë‹ˆ ë™ì ìœ¼ë¡œ ê¸°ëŒ€ê°’ì„ ë§Œë“ ë‹¤.
    const expected = (maxN >= 45) ? 50 : (maxN >= 35 ? maxN : 0);

    if (expected && questions.filter(q => q.choices.length === 5).length < Math.max(1, Math.floor(expected * 0.80))) {
      issues.push({ type: "too_few_questions", expected, got: questions.length });
    }

    return { questions, issues };
  }

  function findPageForQuestion(qNumber) {
    const n2 = String(qNumber).padStart(2,"0");
    const re1 = new RegExp(`(^|\\D)${n2}(\\D)`);
    const re2 = new RegExp(`(^|\\D)${qNumber}(\\D)`);
    for (let i = 1; i < pages.length; i++) {
      const txt = pages[i]?.bestText || "";
      if (!txt) continue;
      const window = txt.slice(0, 6000);
      if ((re1.test(window) || re2.test(window)) && (window.includes("â‘ ") || window.includes("1)"))) return i;
    }
    // ëª» ì°¾ìœ¼ë©´ ìµœê·¼ í˜ì´ì§€ ìš°ì„ 
    return Math.max(1, pages.length - 1);
  }

  async function recapturePage(pageIndex, reasonTts) {
    if (!running) return false;

    setPhase("OCRING");
    pagePill.textContent = String(pageIndex);

    await speak(`${reasonTts} ${pageIndex}í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${BETWEEN_PAGES_SECONDS}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
    await speakCountdown(BETWEEN_PAGES_SECONDS);
    if (!running) return false;

    retryCountSamePage = 0;

    while (running) {
      const result = await ocrOnePage(pageIndex);
      if (!result) return false;

      const { ok, bestText, bestConf, bestScore, shotsCount } = result;
      if (!ok) {
        retryCountSamePage++;
        await speak(`ì¸ì‹ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${RETRY_SECONDS}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
        await speakCountdown(RETRY_SECONDS);
        continue;
      }

      // ì¬ì´¬ì˜ì—ì„œë„ ì´¬ì˜ì™„ë£Œê°€ ì„ì—¬ ë“¤ì–´ì˜¤ë©´ ê·¸ëƒ¥ ì €ì¥ì€ í•˜ë˜(ë§ˆì»¤ëŠ” ë§ˆì§€ë§‰ í˜ì´ì§€ì—ì„œë§Œ ì“°ëŠ” ì „ì œ)
      if (!pagePassesThreshold(bestText, bestScore) && !hasCompletionMarker(bestText)) {
        retryCountSamePage++;
        await speak(`ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”. ${RETRY_SECONDS}ì´ˆ ë’¤ì— ìë™ìœ¼ë¡œ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
        await speakCountdown(RETRY_SECONDS);
        continue;
      }

      pages[pageIndex] = { pageIndex, bestText, bestConf, bestScore, shotsCount };
      appendDebugAllText();
      await speak(`${pageIndex}í˜ì´ì§€ ì¬ì´¬ì˜ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
      return true;
    }

    return false;
  }

  async function validateThenSolve() {
    setPhase("VALIDATING");
    setStatus("ì „ì²´ OCR í…ìŠ¤íŠ¸ë¥¼ ì¡°ë¦½í•˜ê³  ë¬¸í•­ êµ¬ì¡°ë¥¼ ê²€ì¦ ì¤‘ì´ë‹¤â€¦");

    while (running) {
      // fullText ì¡°ë¦½
      let fullText = "";
      for (let i = 1; i < pages.length; i++) {
        const p = pages[i];
        if (!p?.bestText) continue;
        // ë§ˆì»¤ ì´í›„ í…ìŠ¤íŠ¸ê°€ ì„ì—¬ë„ íŒŒì‹±ì— ë°©í•´ë  ìˆ˜ ìˆì–´, íŒŒì‹± ë‹¨ê³„ì—ì„œë§Œ ë§ˆì»¤ ë¬¸êµ¬ ìì²´ëŠ” ì œê±°
        fullText += `\n\n[í˜ì´ì§€ ${i}]\n` + (p.bestText || "");
      }

      // ì´¬ì˜ì™„ë£Œ ë¬¸êµ¬ëŠ” ì œê±°í•˜ê³  íŒŒì‹±(ë§ˆì»¤ê°€ ë¬¸ì œ í…ìŠ¤íŠ¸ì— ì„ì—¬ë„ íŒŒì‹± ë°©í•´ ë°©ì§€)
      const cleanedFullText = fullText.replace(/ì´¬ì˜\s*ì™„ë£Œ/gi, "").replace(/ì´¬ì˜ì™„ë£Œ/gi, "");

      const { questions, issues } = parseQuestionsFromFullText(cleanedFullText);

      const missingChoices = issues.filter(x => x.type === "choices_missing");
      const tooFew = issues.find(x => x.type === "too_few_questions");

      if (!tooFew && missingChoices.length === 0) {
        setStatus(`ê²€ì¦ í†µê³¼. íŒŒì‹±ëœ ë¬¸í•­ ìˆ˜: ${questions.length}ê°œ. ìë™ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.`);
        await speak("ê²€ì¦ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
        await solveQuestionsInChunks(questions);
        return;
      }

      // ìë™ ì¬ì´¬ì˜ ëŒ€ìƒ ì„ ì •
      let targetPage = null;
      let reason = "";

      if (missingChoices.length > 0) {
        const qn = missingChoices[0].n;
        targetPage = findPageForQuestion(qn);
        reason = `${qn}ë²ˆ ë¬¸ì œ í…ìŠ¤íŠ¸ê°€ ë¹„ì •ìƒì…ë‹ˆë‹¤.`;
      } else {
        targetPage = Math.max(1, pages.length - 1);
        reason = "ë¬¸í•­ íŒŒì‹± ê°œìˆ˜ê°€ ë¶€ì¡±í•©ë‹ˆë‹¤.";
      }

      setStatus(`ê²€ì¦ ì‹¤íŒ¨: ${reason}\ní˜ì´ì§€ ${targetPage}ë¥¼ ìë™ ì¬ì´¬ì˜í•œë‹¤.`);
      const ok = await recapturePage(targetPage, reason);
      if (!ok) return;

      await sleep(200);
      setPhase("VALIDATING");
    }
  }

  // ====== ìë™ í’€ì´(10ë¬¸í•­ì”©) ======
  function normalizeAnswerValue(v) {
    if (v == null) return null;
    const s = String(v).trim();
    if (/^[1-5]$/.test(s)) return Number(s);
    const map = { "â‘ ":1,"â‘¡":2,"â‘¢":3,"â‘£":4,"â‘¤":5 };
    if (map[s]) return map[s];
    const m = s.match(/([1-5])/);
    if (m) return Number(m[1]);
    return null;
  }

  async function callSolve(itemsChunk) {
    const res = await fetch("/.netlify/functions/solve", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        items: itemsChunk.map(q => ({
          n: q.n,
          stem: q.stem,
          choices: q.choices
        }))
      })
    });

    if (!res.ok) {
      const t = await res.text().catch(() => "");
      throw new Error(`SOLVE HTTP ${res.status}: ${t.slice(0,200)}`);
    }

    const data = await res.json();
    if (!data || !data.ok) throw new Error(data?.error || "SOLVE failed");
    return data.answers;
  }

  async function solveQuestionsInChunks(questions) {
    setPhase("SOLVING");

    const qs = questions
      .filter(q => q && Number.isFinite(q.n) && q.n >= 1 && q.n <= 60 && Array.isArray(q.choices) && q.choices.length === 5 && q.stem)
      .sort((a,b) => a.n - b.n);

    if (qs.length === 0) {
      setStatus("í’€ì´ ê°€ëŠ¥í•œ ë¬¸í•­ì„ ì°¾ì§€ ëª»í–ˆë‹¤. OCRì´ ì‹¬í•˜ê²Œ ê¹¨ì¡Œì„ ê°€ëŠ¥ì„±ì´ í¬ë‹¤.");
      await speak("í’€ì´ ê°€ëŠ¥í•œ ë¬¸í•­ì„ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜ì´ í•„ìš”í•©ë‹ˆë‹¤.");
      return;
    }

    // 10ë¬¸í•­ ë‹¨ìœ„ ë¶„í• 
    const chunks = [];
    for (let i = 0; i < qs.length; i += SOLVE_CHUNK_SIZE) {
      chunks.push(qs.slice(i, i + SOLVE_CHUNK_SIZE));
    }

    const answers = {}; // number -> 1..5

    for (let ci = 0; ci < chunks.length; ci++) {
      if (!running) return;

      const chunk = chunks[ci];
      const range = `${chunk[0].n}ë²ˆë¶€í„° ${chunk[chunk.length-1].n}ë²ˆê¹Œì§€`;

      setStatus(`ìë™ í’€ì´ ì¤‘ì´ë‹¤. (${ci+1}/${chunks.length}) ${range}`);
      await speak(`${range}ë¥¼ í’€ì´í•©ë‹ˆë‹¤.`);

      // ì™„ì „ ìë™: ì‹¤íŒ¨í•˜ë©´ ê³„ì† ì¬ì‹œë„
      while (running) {
        try {
          const resAns = await callSolve(chunk);

          for (const q of chunk) {
            const v = normalizeAnswerValue(resAns?.[String(q.n)]);
            if (!v) throw new Error(`${q.n}ë²ˆ ì •ë‹µì´ ì—†ê±°ë‚˜ í˜•ì‹ì´ ì´ìƒí•˜ë‹¤.`);
            answers[q.n] = v;
          }
          break;
        } catch (e) {
          setStatus(`í’€ì´ ì‹¤íŒ¨(${range}). ìë™ ì¬ì‹œë„ ì¤‘ì´ë‹¤.\nì›ì¸: ${String(e)}`);
          await speak("í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤.");
          await sleep(900);
        }
      }
    }

    await speakAnswers(answers);
  }

  async function speakAnswers(answers) {
    setPhase("SPEAKING");
    setStatus("ì •ë‹µì„ ìŒì„±ìœ¼ë¡œ ì½ëŠ”ë‹¤.");

    const nums = Object.keys(answers).map(n => Number(n)).filter(n => Number.isFinite(n)).sort((a,b) => a-b);
    for (const n of nums) {
      if (!running) return;
      const a = answers[n];
      if (!a) continue;
      await speak(`${n}ë²ˆ ì •ë‹µì€ ${a}ë²ˆì…ë‹ˆë‹¤.`);
      await sleep(180);
    }

    await speak("ì •ë‹µ ë‚­ë…ì´ ëë‚¬ìŠµë‹ˆë‹¤.");
    setStatus("ì™„ë£Œ.");
    setPhase("IDLE");
    btnAuto.disabled = false;
    btnStop.disabled = true;
    shotPill.textContent = "-";
  }

  // ===== ë²„íŠ¼ =====
  btnTestVoice.addEventListener("click", async () => {
    await speak("ìŒì„± í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤. ìë™ OCRì„ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
  });

  btnStop.addEventListener("click", async () => {
    await stopAll("ì •ì§€í–ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•˜ë ¤ë©´ â€˜ìë™ OCR ì‹œì‘â€™ì„ ëˆ„ë¥´ë¼.");
  });

  btnAuto.addEventListener("click", async () => {
    if (running) return;

    try {
      running = true;
      btnAuto.disabled = true;
      btnStop.disabled = false;

      setPhase("OCRING");
      pages.length = 0;
      ocrAll.value = "";
      retryCountSamePage = 0;
      currentPageIndex = 1;

      setStatus("ì¹´ë©”ë¼ë¥¼ ì—¬ëŠ” ì¤‘ì´ë‹¤â€¦");
      await ensureCamera();

      // ì²« TTS ì•ˆì •í™”(ì‚¬ìš©ì í´ë¦­ ì´ë²¤íŠ¸ ë‚´ë¶€)
      await speak("ìë™ OCRì„ ì‹œì‘í•©ë‹ˆë‹¤. ì²« í˜ì´ì§€ë¥¼ í™”ë©´ì— ë³´ì—¬ ì£¼ì„¸ìš”.");

      await runOcrLoop();
    } catch (e) {
      setStatus("ì¹˜ëª…ì  ì˜¤ë¥˜ê°€ ë°œìƒí–ˆë‹¤:\n" + String(e));
      try { await speak("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”."); } catch {}
      await stopAll();
    }
  });

})();
</script>
</body>
</html>
