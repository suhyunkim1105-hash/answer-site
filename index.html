<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>OCR → 자동 풀이</title>
  <style>
    body { margin:0; font-family: -apple-system, system-ui, Segoe UI, Roboto, sans-serif; background:#0b0b0f; color:#fff; }
    .wrap { max-width: 900px; margin: 0 auto; padding: 14px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; }
    button {
      background:#1c1c24; color:#fff; border:1px solid #2d2d3a;
      border-radius:14px; padding:12px 14px; font-size:15px;
    }
    button:active { transform: scale(0.99); }
    .card {
      background:#111118; border:1px solid #222233; border-radius:18px; padding:12px; margin-top:12px;
    }
    .title { font-weight:700; margin-bottom:8px; opacity:0.95; }
    .muted { opacity:0.75; font-size:13px; line-height:1.35; }
    video { width:100%; border-radius:14px; background:#000; }
    textarea {
      width:100%; min-height:160px; background:#0f0f16; color:#fff;
      border:1px solid #222233; border-radius:14px; padding:12px; font-size:14px; line-height:1.5;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>

  <!-- Tesseract v5 (unpkg) -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="row">
      <button id="btnCam">카메라 시작(필수 1회 탭)</button>
      <button id="btnTTS">음성 연결/테스트(필수 1회 탭)</button>
      <button id="btnReset">OCR 재시작(새로고침)</button>
      <button id="btnForce">지금까지로 풀이</button>
    </div>

    <div class="card">
      <div class="title">상태</div>
      <div id="status" class="muted mono">대기중…</div>
    </div>

    <div class="card">
      <div class="title">카메라</div>
      <video id="video" playsinline muted></video>
      <div class="muted" style="margin-top:8px;">
        iOS는 카메라/음성은 “첫 탭”이 필요하다. 위 버튼 2개는 반드시 한 번 눌러라.
      </div>
    </div>

    <div class="card">
      <div class="title">실시간 OCR(누적)</div>
      <textarea id="ocrBox" placeholder="OCR 누적 텍스트가 여기에 쌓임"></textarea>
    </div>

    <div class="card">
      <div class="title">답안</div>
      <textarea id="ansBox" placeholder="아직 답안 없음"></textarea>
      <div class="row" style="margin-top:10px;">
        <button id="btnSpeak">답안 읽기</button>
        <button id="btnStop">음성 중지</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ====== 설정 (너가 원하는 안정성 우선 값) ======
  const OCR_INTERVAL_MS = 2500;        // OCR 갱신 주기
  const MIN_LEN = 2400;               // 공백 제외 누적 길이 기준
  const MIN_CONF = 70;                // 평균 신뢰도(대략) 기준
  const MAX_WAIT_MS = 8 * 60 * 1000;  // 최대 대기(지문 부족 자동 풀이)
  const SOLVE_ENDPOINT = "/.netlify/functions/solve";

  // Tesseract 경로(핵심: iOS에서 로딩 안정)
  const TESS_CFG = {
    workerPath: "https://unpkg.com/tesseract.js@5/dist/worker.min.js",
    corePath: "https://unpkg.com/tesseract.js-core@5/tesseract-core.wasm.js",
    langPath: "https://tessdata.projectnaptha.com/4.0.0"
  };

  // ====== 상태 변수 ======
  let stream = null;
  let worker = null;
  let ocrTimer = null;
  let solved = false;

  let ocrText = "";
  let confSamples = [];
  let startTime = Date.now();

  // iOS TTS
  let synth = window.speechSynthesis;
  let currentUtter = null;

  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const videoEl = $("video");
  const ocrBox = $("ocrBox");
  const ansBox = $("ansBox");

  function setStatus(msg) {
    statusEl.textContent = msg;
  }

  function stripSpaces(s) {
    return (s || "").replace(/\s+/g, "");
  }

  function avg(arr) {
    if (!arr.length) return 0;
    return arr.reduce((a,b)=>a+b,0) / arr.length;
  }

  function nowSummary(extra="") {
    const lenNoSpace = stripSpaces(ocrText).length;
    const conf = avg(confSamples);
    const elapsed = Math.floor((Date.now() - startTime)/1000);
    return `자동 OCR(누적) → 자동 풀이 | 누적 길이(공백제외): ${lenNoSpace} / 기준 ${MIN_LEN} | 평균 신뢰도(대략): ${conf.toFixed(1)}% | 경과: ${elapsed}s ${extra}`;
  }

  async function startCamera() {
    if (stream) return;
    try {
      stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: "environment",
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        },
        audio: false
      });
      videoEl.srcObject = stream;
      await videoEl.play();
      setStatus(nowSummary("| 카메라 연결 완료"));
    } catch (e) {
      setStatus("카메라 실패: " + (e?.message || e));
    }
  }

  async function initOCR() {
    if (worker) return;

    try {
      setStatus("OCR 엔진: 로딩 중… (tesseract worker/wasm 불러오는 중)");
      worker = await Tesseract.createWorker("kor", 1, {
        workerPath: TESS_CFG.workerPath,
        corePath: TESS_CFG.corePath,
        langPath: TESS_CFG.langPath,
        logger: m => {
          // 너무 시끄러우면 주석
          // console.log(m);
        }
      });

      // 안정성 옵션 (속도보다 정확도쪽)
      await worker.setParameters({
        tessedit_pageseg_mode: "6"
      });

      setStatus("OCR 엔진: 준비됨 ✅");
    } catch (e) {
      worker = null;
      setStatus("OCR 엔진 로딩 실패(네트워크/차단 가능): " + (e?.message || e));
    }
  }

  function captureCanvas() {
    const c = document.createElement("canvas");
    const vw = videoEl.videoWidth || 0;
    const vh = videoEl.videoHeight || 0;
    if (!vw || !vh) return null;

    // 중앙 크롭(흔들림/배경 줄이기)
    const crop = 0.85; // 0.85 = 중앙 85% 사용
    const cw = Math.floor(vw * crop);
    const ch = Math.floor(vh * crop);
    const sx = Math.floor((vw - cw)/2);
    const sy = Math.floor((vh - ch)/2);

    c.width = cw;
    c.height = ch;
    const ctx = c.getContext("2d", { willReadFrequently: true });
    ctx.drawImage(videoEl, sx, sy, cw, ch, 0, 0, cw, ch);
    return c;
  }

  function mergeAppend(prev, next) {
    // 초단순 누적(안정성 우선): 다음 텍스트가 너무 짧거나 잡음이면 무시
    const cleanNext = (next || "").trim();
    if (cleanNext.length < 20) return prev;

    // 중복 줄이기: 마지막 200자 정도 겹치면 이어붙이지 않음
    const tail = prev.slice(-200);
    if (tail && cleanNext.includes(tail.slice(-80))) return prev;

    // 너무 길어지면 앞부분 조금 자르고 유지(메모리 폭주 방지)
    const merged = (prev + "\n" + cleanNext).trim();
    if (merged.length > 20000) return merged.slice(-20000);
    return merged;
  }

  async function ocrOnce() {
    if (!stream) return;
    if (!worker) return;

    const canvas = captureCanvas();
    if (!canvas) return;

    try {
      const { data } = await worker.recognize(canvas);
      const text = (data?.text || "").replace(/\u0000/g, "").trim();

      // 신뢰도는 word confidence 평균을 대충 계산
      let conf = 0;
      if (data?.words?.length) {
        const cs = data.words.map(w => (typeof w.confidence === "number" ? w.confidence : 0));
        conf = avg(cs);
      }

      if (conf) confSamples.push(conf);
      if (confSamples.length > 30) confSamples.shift();

      ocrText = mergeAppend(ocrText, text);
      ocrBox.value = ocrText;

      setStatus(nowSummary(`| 마지막 conf=${(conf||0).toFixed(1)}%`));

      // 트리거 체크
      await maybeSolve(false);
    } catch (e) {
      setStatus(nowSummary(`| OCR 에러: ${e?.message || e}`));
    }
  }

  async function maybeSolve(force) {
    if (solved) return;

    const lenNoSpace = stripSpaces(ocrText).length;
    const conf = avg(confSamples);
    const elapsed = Date.now() - startTime;

    const enough = (lenNoSpace >= MIN_LEN && conf >= MIN_CONF);
    const timeout = (elapsed >= MAX_WAIT_MS);

    if (!force && !enough && !timeout) return;

    solved = true;
    const reason = force ? "강제 풀이" : (enough ? "충분한 지문 인식으로 자동 풀이" : "지문 부족(시간 초과)로 자동 풀이");
    ansBox.value = reason + "…";
    setStatus(nowSummary(`| SOLVE 호출: ${reason}`));

    try {
      const payload = {
        ocrText: ocrText,
        meta: { reason, lenNoSpace, conf }
      };

      const res = await fetch(SOLVE_ENDPOINT, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      const txt = await res.text();

      if (!res.ok) {
        ansBox.value = `ERROR ${res.status}\n` + txt;
        return;
      }

      ansBox.value = txt || "No answer (모델 응답 비어있음). 입력을 더 줄여서 다시 시도";
    } catch (e) {
      ansBox.value = `SOLVE 호출 실패: ${e?.message || e}`;
    }
  }

  function startLoop() {
    if (ocrTimer) return;
    ocrTimer = setInterval(ocrOnce, OCR_INTERVAL_MS);
  }

  function resetAll() {
    solved = false;
    ocrText = "";
    confSamples = [];
    startTime = Date.now();
    ocrBox.value = "";
    ansBox.value = "";
    setStatus("초기화 완료. 카메라/음성 버튼을 다시 1회 탭하고 진행.");
  }

  function ttsInitTest() {
    // iOS는 사용자 제스처로 한 번 말 시켜야 이후 자동 재생이 안정
    try {
      if (!synth) return;
      const u = new SpeechSynthesisUtterance("음성 연결 완료");
      u.lang = "ko-KR";
      synth.cancel();
      synth.speak(u);
      setStatus(nowSummary("| 음성 연결 완료"));
    } catch (e) {
      setStatus(nowSummary("| 음성 실패: " + (e?.message || e)));
    }
  }

  function speakAnswer() {
    if (!synth) return;
    const text = (ansBox.value || "").trim();
    if (!text) return;
    synth.cancel();
    currentUtter = new SpeechSynthesisUtterance(text);
    currentUtter.lang = "ko-KR";
    synth.speak(currentUtter);
  }

  function stopSpeak() {
    if (!synth) return;
    synth.cancel();
  }

  // ====== 버튼 바인딩 ======
  $("btnCam").addEventListener("click", async () => {
    await startCamera();
    await initOCR();
    startLoop();
  });

  $("btnTTS").addEventListener("click", () => ttsInitTest());
  $("btnReset").addEventListener("click", () => resetAll());
  $("btnForce").addEventListener("click", async () => {
    await initOCR();
    await maybeSolve(true);
  });

  $("btnSpeak").addEventListener("click", () => speakAnswer());
  $("btnStop").addEventListener("click", () => stopSpeak());

  // 페이지 로드시 상태만
  setStatus("대기중… (카메라 시작 버튼을 먼저 1회 탭)");
})();
</script>
</body>
</html>
