<!-- index.html (ë£¨íŠ¸) -->
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Auto OCR â†’ Solve â†’ TTS</title>
  <style>
    body { font-family: system-ui, -apple-system, sans-serif; margin: 16px; }
    .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    button { padding:10px 12px; border:1px solid #ccc; border-radius:10px; background:#fff; }
    button.primary { border-color:#111; background:#111; color:#fff; }
    button.danger { border-color:#b00020; color:#b00020; }
    #videoWrap { position:relative; width:100%; max-width:520px; }
    video { width:100%; border-radius:12px; background:#000; }
    #overlay { position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:48px; font-weight:800; text-shadow:0 2px 10px rgba(0,0,0,.6);
      pointer-events:none;
    }
    #log, #ocrOut, #ansOut, #accOut { white-space:pre-wrap; background:#f7f7f7; padding:12px; border-radius:12px; border:1px solid #e5e5e5; }
    .small { color:#555; font-size:12px; }
  </style>
</head>
<body>
  <h2>Auto OCR â†’ Solve â†’ TTS</h2>

  <div class="row">
    <button id="btnCam" class="primary">ì¹´ë©”ë¼ ì¼œê¸°</button>
    <button id="btnStart" class="primary" disabled>AUTO START</button>
    <button id="btnStop" class="danger" disabled>STOP</button>
    <button id="btnVoice">ğŸ”Š ìŒì„± ON(1íšŒ íƒ­)</button>
    <button id="btnTtsTest" disabled>ğŸ§ª TTS í…ŒìŠ¤íŠ¸</button>
    <button id="btnSpeak" disabled>ğŸ” ì •ë‹µ 4íšŒ ì½ê¸°</button>
  </div>

  <p class="small">
    STOP TOKENì€ ì„œë²„ ì„¤ì •(STOP_TOKEN)ì—ì„œ ê°€ì ¸ì˜¨ë‹¤. (ê¸°ë³¸ê°’: ABCDEFGH)
  </p>

  <div id="videoWrap">
    <video id="video" playsinline autoplay muted></video>
    <div id="overlay"></div>
  </div>

  <h3>ìƒíƒœ / ë¡œê·¸</h3>
  <div id="log"></div>

  <h3>ëˆ„ì  OCR</h3>
  <div id="ocrOut"></div>

  <h3>ì •ë‹µ</h3>
  <div id="ansOut"></div>

  <h3>ì •ë‹µë¥ (ì„ íƒ)</h3>
  <p class="small">ê³µì‹ ì •ë‹µì„ â€œ1:B 2:D â€¦â€ ë˜ëŠ” â€œ1ë²ˆ: Bâ€ í˜•íƒœë¡œ ë¶™ì—¬ë„£ê³  ë¹„êµ ë²„íŠ¼ì„ ëˆ„ë¥´ë©´ %ë¥¼ ê³„ì‚°í•œë‹¤.</p>
  <textarea id="keyIn" rows="4" style="width:100%;max-width:520px;"></textarea><br/>
  <div class="row" style="margin-top:8px;">
    <button id="btnCompare" disabled>âœ… ì •ë‹µë¥  ê³„ì‚°</button>
  </div>
  <div id="accOut"></div>

<script>
(() => {
  // ===== DOM =====
  const el = {
    video: document.getElementById("video"),
    overlay: document.getElementById("overlay"),
    log: document.getElementById("log"),
    ocrOut: document.getElementById("ocrOut"),
    ansOut: document.getElementById("ansOut"),
    accOut: document.getElementById("accOut"),
    keyIn: document.getElementById("keyIn"),
    btnCam: document.getElementById("btnCam"),
    btnStart: document.getElementById("btnStart"),
    btnStop: document.getElementById("btnStop"),
    btnVoice: document.getElementById("btnVoice"),
    btnTtsTest: document.getElementById("btnTtsTest"),
    btnSpeak: document.getElementById("btnSpeak"),
    btnCompare: document.getElementById("btnCompare"),
  };

  // ===== ìƒíƒœ =====
  let STOP_TOKEN = "ABCDEFGH";
  let stream = null;
  let running = false;

  let voiceUnlocked = false;
  let audioCtx = null;
  let selectedVoice = null;

  let lastAnswersObj = null; // { "1":"A"... }
  let lastAnswerText = "";

  const SHOTS_PER_PAGE = 3;
  const COUNTDOWN_SEC = 5;
  const MAX_PAGES = 40;

  function now() {
    const d = new Date();
    return d.toTimeString().slice(0,8);
  }
  function log(msg) {
    const line = `[${now()}] ${msg}`;
    el.log.textContent += (el.log.textContent ? "\n" : "") + line;
    el.log.scrollTop = el.log.scrollHeight;
    console.log(line);
  }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  async function loadConfig() {
    try {
      const r = await fetch("/.netlify/functions/config");
      const j = await r.json();
      if (j?.stopToken) STOP_TOKEN = String(j.stopToken).trim() || STOP_TOKEN;
      log(`STOP TOKEN = ${STOP_TOKEN}`);
    } catch {
      log(`STOP TOKEN = ${STOP_TOKEN} (config ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨ â†’ ê¸°ë³¸ê°’)`);
    }
  }

  function getPreviewInfo() {
    const w = el.video.videoWidth || 0;
    const h = el.video.videoHeight || 0;
    return { w, h };
  }

  async function initCamera() {
    if (stream) return;

    const constraints = {
      audio: false,
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 2560 },
        height: { ideal: 1440 },
      }
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    el.video.srcObject = stream;

    await new Promise(res => el.video.onloadedmetadata = res);
    await el.video.play();

    const { w, h } = getPreviewInfo();
    log(`ì¹´ë©”ë¼ OK (${w}x${h})`);

    if (w && h && (Math.min(w,h) < 1400)) {
      log(`ê²½ê³ : í”„ë¦¬ë·° í•´ìƒë„ê°€ ë‚®ë‹¤(${w}x${h}). (ë°‘ì¤„/ì„ ì§€ ë¼ë²¨) OCR ì •í™•ë„ í¬ê²Œ í•˜ë½`);
      log(`ëŒ€ì‘: (1) ë” ë°ê²Œ (2) ê±°ë¦¬ ëŠ˜ë¦¬ê³  ì¢…ì´ë¥¼ í™”ë©´ì— ê½‰ ì±„ìš°ê¸° (3) ì‚¬íŒŒë¦¬ ì¬ì‹œë„`);
    }

    el.btnStart.disabled = false;
  }

  // ===== ìº¡ì²˜ + ì „ì²˜ë¦¬(ì¤‘ìš”) =====
  async function capturePreprocessedDataUrl() {
    const vw = el.video.videoWidth;
    const vh = el.video.videoHeight;
    if (!vw || !vh) throw new Error("video not ready");

    const scale = 1.25; // ë°‘ì¤„/ë¼ë²¨ ì‚´ë¦¬ê¸°ìš© ì—…ìŠ¤ì¼€ì¼
    const cw = Math.floor(vw * scale);
    const ch = Math.floor(vh * scale);

    const canvas = document.createElement("canvas");
    canvas.width = cw;
    canvas.height = ch;
    const ctx = canvas.getContext("2d");

    // í•„í„°ë¡œ ëŒ€ë¹„/ëª…ë„ ì˜¬ë¦¬ê³  í‘ë°±í™”
    ctx.filter = "grayscale(1) contrast(1.55) brightness(1.15)";
    ctx.drawImage(el.video, 0, 0, cw, ch);

    // JPEGë¡œ
    return await new Promise((resolve) => {
      canvas.toBlob((blob) => {
        const fr = new FileReader();
        fr.onload = () => resolve(fr.result); // data:image/jpeg;base64,...
        fr.readAsDataURL(blob);
      }, "image/jpeg", 0.92);
    });
  }

  function cleanForStopDetect(s) {
    return (s || "").toUpperCase().replace(/\s+/g, "");
  }
  function stripStopToken(text) {
    const idx = (text || "").toUpperCase().indexOf(STOP_TOKEN);
    if (idx === -1) return text;
    return text.slice(0, idx).trim();
  }

  function heuristicQuality(text) {
    // ì´ ê°’ì€ "ì§„ì§œ OCR ì‹ ë¢°ë„"ê°€ ì•„ë‹ˆë¼, "í…ìŠ¤íŠ¸ê°€ ì–¼ë§ˆë‚˜ ê·¸ëŸ´ë“¯í•œì§€"ì— ëŒ€í•œ íœ´ë¦¬ìŠ¤í‹±
    if (!text) return 0;
    const t = text.trim();
    const len = t.length;
    const letters = (t.match(/[A-Za-z]/g) || []).length;
    const ratio = len ? (letters / len) : 0;
    const base = Math.min(100, (len / 1600) * 70) + (ratio * 30);
    return Math.max(0, Math.min(100, base));
  }

  async function ocrImage(dataUrl) {
    const r = await fetch("/.netlify/functions/ocr", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ image: dataUrl })
    });
    const j = await r.json();
    if (!r.ok) throw new Error(j?.error || "OCR failed");
    return j; // { text }
  }

  async function solveText(fullText) {
    const r = await fetch("/.netlify/functions/solve", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ text: fullText })
    });
    const j = await r.json();
    if (!r.ok) throw new Error(j?.error || "SOLVE failed");
    return j; // { answers, answer_text }
  }

  // ===== TTS (iOS ì•ˆì •í™”) =====
  function pickVoice() {
    const voices = window.speechSynthesis.getVoices() || [];
    // í•œêµ­ì–´ ìš°ì„ 
    let v = voices.find(x => (x.lang || "").toLowerCase().startsWith("ko"));
    if (!v) v = voices[0] || null;
    selectedVoice = v;
    if (v) log(`TTS voice ì„ íƒ: ${v.name} (${v.lang})`);
    else log("TTS voice ì—†ìŒ(ê¸°ê¸°/ë¸Œë¼ìš°ì € ë¬¸ì œ ê°€ëŠ¥)");
  }

  async function unlockVoice() {
    if (!("speechSynthesis" in window)) {
      log("ì´ ë¸Œë¼ìš°ì €ëŠ” SpeechSynthesis ë¯¸ì§€ì›");
      return;
    }

    // AudioContextë„ ê°™ì´ ì–¸ë½(ë¬´ìŒ ë¬¸ì œ ì™„í™”)
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (AC) {
        audioCtx = audioCtx || new AC();
        await audioCtx.resume();
        log("AudioContext ì–¸ë½ ì™„ë£Œ");
      }
    } catch (e) {
      log("AudioContext ì–¸ë½ ì‹¤íŒ¨: " + e.message);
    }

    // voicesê°€ ë¹„ì–´ìˆë‹¤ê°€ ë‚˜ì¤‘ì— ì±„ì›Œì§€ëŠ” ë¬¸ì œ ëŒ€ì‘
    await new Promise((res) => {
      let done = false;
      const finish = () => { if (!done) { done = true; res(); } };

      const tryPick = () => {
        pickVoice();
        if (selectedVoice) finish();
      };

      tryPick();
      // ì´ë²¤íŠ¸ ëŒ€ê¸°
      window.speechSynthesis.onvoiceschanged = () => {
        tryPick();
        finish();
      };
      setTimeout(finish, 600); // ë„ˆë¬´ ì˜¤ë˜ ê¸°ë‹¤ë¦¬ë©´ ê·¸ëƒ¥ ì§„í–‰
    });

    // ì‹¤ì œ ë°œí™”ë¡œ ì–¸ë½
    window.speechSynthesis.cancel();
    const ut = new SpeechSynthesisUtterance("ìŒì„± ì•ˆë‚´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.");
    ut.lang = "ko-KR";
    ut.volume = 1;
    if (selectedVoice) ut.voice = selectedVoice;

    await new Promise((res) => {
      ut.onstart = () => log("TTS onstart");
      ut.onend = () => { log("TTS onend"); res(); };
      ut.onerror = (e) => { log("TTS onerror: " + (e?.error || "unknown")); res(); };
      window.speechSynthesis.speak(ut);
      // ì•ˆì „ íƒ€ì„ì•„ì›ƒ
      setTimeout(res, 2500);
    });

    voiceUnlocked = true;
    el.btnTtsTest.disabled = false;
    el.btnSpeak.disabled = !lastAnswerText;
    log("ì •ë‹µ TTS ì‚¬ìš© ê°€ëŠ¥(ì–¸ë½ ì™„ë£Œ).");
  }

  function speak(text, repeat=4) {
    if (!voiceUnlocked) {
      log("TTS ì ê¹€: 'ğŸ”Š ìŒì„± ON' 1íšŒ íƒ­ í•„ìš”");
      return;
    }
    if (!text) return;

    window.speechSynthesis.cancel();

    let count = 0;
    const run = () => {
      if (count >= repeat) return;
      const ut = new SpeechSynthesisUtterance(text);
      ut.lang = "ko-KR";
      ut.volume = 1;
      ut.rate = 1.0;
      if (selectedVoice) ut.voice = selectedVoice;

      ut.onstart = () => log(`ì •ë‹µ ì½ê¸° ì‹œì‘(${count+1}/${repeat})`);
      ut.onend = () => { count++; run(); };
      ut.onerror = (e) => log("ì •ë‹µ TTS ì˜¤ë¥˜: " + (e?.error || "unknown"));

      window.speechSynthesis.speak(ut);
    };
    run();
  }

  // ===== ì •ë‹µë¥  ê³„ì‚° =====
  function parseKey(text) {
    // "1:B 2:D" / "1ë²ˆ: B" / JSON {"1":"B"} ëŒ€ì‘
    const t = (text || "").trim();
    if (!t) return null;

    try {
      const j = JSON.parse(t);
      const obj = j.answers && typeof j.answers === "object" ? j.answers : j;
      if (obj && typeof obj === "object") {
        const out = {};
        for (const [k,v] of Object.entries(obj)) {
          const kk = String(k).replace(/\D/g,"");
          const vv = String(v).trim().toUpperCase();
          if (!kk) continue;
          if (!["A","B","C","D","E"].includes(vv)) continue;
          out[kk] = vv;
        }
        if (Object.keys(out).length) return out;
      }
    } catch {}

    const out = {};
    const re = /(\d{1,2})\s*(?:ë²ˆ)?\s*[:=\-]?\s*([A-Ea-e])/g;
    let m;
    while ((m = re.exec(t))) {
      out[String(Number(m[1]))] = m[2].toUpperCase();
    }
    return Object.keys(out).length ? out : null;
  }

  function compareAnswers(pred, gold) {
    const keys = Object.keys(gold);
    let hit = 0, total = 0;
    const wrong = [];
    for (const k of keys) {
      total++;
      const p = pred?.[k];
      const g = gold[k];
      if (p === g) hit++;
      else wrong.push(`${k}(${p||"?"}â‰ ${g})`);
    }
    const pct = total ? (hit/total*100) : 0;
    return { hit, total, pct, wrong };
  }

  // ===== AUTO ë£¨í”„ =====
  async function countdown(sec) {
    for (let s = sec; s >= 1; s--) {
      el.overlay.textContent = String(s);
      await sleep(1000);
    }
    el.overlay.textContent = "";
  }

  async function runAuto() {
    if (!stream) await initCamera();
    running = true;
    el.btnStart.disabled = true;
    el.btnStop.disabled = false;

    el.ocrOut.textContent = "";
    el.ansOut.textContent = "";
    el.accOut.textContent = "";
    lastAnswerText = "";
    lastAnswersObj = null;
    el.btnSpeak.disabled = true;
    el.btnCompare.disabled = true;

    log("AUTO START");

    let fullText = "";
    for (let page = 1; page <= MAX_PAGES && running; page++) {
      let best = { hq: -1, text: "", shot: 0 };

      for (let shot = 1; shot <= SHOTS_PER_PAGE && running; shot++) {
        log(`í˜ì´ì§€ ${page} / ìƒ· ${shot} ì¹´ìš´íŠ¸ë‹¤ìš´ ì‹œì‘ (${COUNTDOWN_SEC}s)`);
        await countdown(COUNTDOWN_SEC);

        let dataUrl;
        try {
          dataUrl = await capturePreprocessedDataUrl();
        } catch (e) {
          log(`CAPTURE FAIL page=${page} shot=${shot} err=${e.message}`);
          continue;
        }

        let ocr;
        try {
          ocr = await ocrImage(dataUrl);
        } catch (e) {
          log(`OCR FAIL page=${page} shot=${shot} err=${e.message}`);
          continue;
        }

        const t = (ocr.text || "");
        const hq = heuristicQuality(t);
        log(`OCR OK page=${page} shot=${shot} len=${t.length} hq=${hq.toFixed(1)}(íœ´ë¦¬ìŠ¤í‹±)`);

        if (hq > best.hq) best = { hq, text: t, shot };

        if (cleanForStopDetect(t).includes(STOP_TOKEN)) break;
      }

      log(`í˜ì´ì§€ ${page} ì™„ë£Œ (best hq=${best.hq.toFixed(1)}, shot=${best.shot})`);

      fullText += `\n\n[PAGE ${page}]\n` + (best.text || "").trim() + "\n";
      el.ocrOut.textContent = fullText.trim();

      if (cleanForStopDetect(best.text).includes(STOP_TOKEN)) {
        log(`STOP TOKEN ê°ì§€ (${STOP_TOKEN}) â†’ ì¢…ë£Œ`);
        fullText = stripStopToken(fullText);
        break;
      }
    }

    running = false;
    el.btnStop.disabled = true;

    const trimmed = (fullText || "").trim();
    if (trimmed.length < 300) {
      log("ì •ë‹µ ê³„ì‚° ì¤‘ë‹¨: ëˆ„ì  OCR í…ìŠ¤íŠ¸ ë„ˆë¬´ ì§§ìŒ(ì´¬ì˜/STOP í™•ì¸)");
      el.btnStart.disabled = false;
      return;
    }

    log("ì •ë‹µ ê³„ì‚° ì‹œì‘ (/solve í˜¸ì¶œ)");
    let solved;
    try {
      solved = await solveText(trimmed);
    } catch (e) {
      log("ì •ë‹µ ê³„ì‚° ì‹¤íŒ¨: " + e.message);
      el.btnStart.disabled = false;
      return;
    }

    const answers = solved.answers || {};
    lastAnswersObj = answers;

    const keys = Object.keys(answers).map(x=>Number(x)).filter(n=>!Number.isNaN(n)).sort((a,b)=>a-b);
    let pretty = "";
    for (const k of keys) pretty += `${k}ë²ˆ: ${answers[String(k)]}\n`;
    lastAnswerText = pretty.trim();

    el.ansOut.textContent = lastAnswerText || JSON.stringify(solved, null, 2);
    el.btnCompare.disabled = false;

    log("ì •ë‹µ ìˆ˜ì‹  OK");
    if (voiceUnlocked && lastAnswerText) {
      log("ì •ë‹µ TTS 4íšŒ ì¬ìƒ ì‹œì‘");
      speak(lastAnswerText, 4);
    } else {
      log("TTS ë¯¸ì¬ìƒ: 'ğŸ”Š ìŒì„± ON' ë²„íŠ¼ 1íšŒ íƒ­ í•„ìš”");
      el.btnSpeak.disabled = true;
    }

    el.btnSpeak.disabled = !(voiceUnlocked && lastAnswerText);
    el.btnStart.disabled = false;
  }

  function stopAuto() {
    running = false;
    el.overlay.textContent = "";
    log("STOP(ì‚¬ìš©ì)");
    el.btnStop.disabled = true;
    el.btnStart.disabled = false;
  }

  // ===== ì´ë²¤íŠ¸ =====
  el.btnCam.onclick = async () => {
    try { await initCamera(); }
    catch (e) { log("ì¹´ë©”ë¼ ì‹¤íŒ¨: " + e.message); }
  };

  el.btnStart.onclick = async () => {
    try { await runAuto(); }
    catch (e) {
      log("AUTO ì˜¤ë¥˜: " + e.message);
      running = false;
      el.btnStart.disabled = false;
      el.btnStop.disabled = true;
    }
  };

  el.btnStop.onclick = stopAuto;

  el.btnVoice.onclick = async () => {
    await unlockVoice();
    el.btnSpeak.disabled = !(voiceUnlocked && lastAnswerText);
  };

  el.btnTtsTest.onclick = () => {
    speak("í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤. ì†Œë¦¬ ë“¤ë¦¬ë©´ ì •ìƒì…ë‹ˆë‹¤.", 1);
  };

  el.btnSpeak.onclick = () => {
    if (lastAnswerText) speak(lastAnswerText, 4);
  };

  el.btnCompare.onclick = () => {
    const gold = parseKey(el.keyIn.value);
    if (!gold) {
      el.accOut.textContent = "ê³µì‹ ì •ë‹µ íŒŒì‹± ì‹¤íŒ¨(í˜•ì‹: 1:B 2:D â€¦ ë˜ëŠ” 1ë²ˆ: B â€¦)";
      return;
    }
    const r = compareAnswers(lastAnswersObj, gold);
    el.accOut.textContent =
      `ì •ë‹µë¥ : ${r.hit}/${r.total} = ${r.pct.toFixed(1)}%\n` +
      (r.wrong.length ? `ì˜¤ë‹µ: ${r.wrong.join(", ")}` : "ì˜¤ë‹µ ì—†ìŒ");
  };

  // init
  loadConfig();
})();
</script>
</body>
</html>
