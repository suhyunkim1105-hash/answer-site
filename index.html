<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Auto OCR(ëˆ„ì ) â†’ Auto Solve (KOR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <!-- Tesseract v5 -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 10px;
      background: #000;
      color: #fff;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }
    .wrap { max-width: 980px; margin: 0 auto; }

    #videoBox {
      position: relative;
      width: 100%;
      border: 1px solid #333;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
    }
    #video {
      width: 100%;
      height: auto;
      display: block;
      transform-origin: center center;
    }
    #overlay {
      position: absolute;
      inset: 0;
      border: 2px solid rgba(0, 255, 0, 0.30);
      pointer-events: none;
    }

    #topBar {
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    button {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #333;
      background: #151515;
      color: #fff;
      font-size: 13px;
      cursor: pointer;
    }
    button:active { transform: scale(0.98); }

    #status {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #333;
      border-radius: 10px;
      background: #111;
      font-size: 13px;
      line-height: 1.4;
      white-space: pre-wrap;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 10px;
    }
    .panel {
      border: 1px solid #333;
      border-radius: 10px;
      background: #0b0b0b;
      padding: 10px;
    }
    .panel h3 {
      margin: 0 0 8px 0;
      font-size: 14px;
      color: #cfcfcf;
      font-weight: 600;
    }
    textarea, pre {
      width: 100%;
      border: 1px solid #222;
      border-radius: 8px;
      background: #000;
      color: #fff;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 10px;
      margin: 0;
    }
    textarea { height: 240px; resize: vertical; }
    pre { min-height: 260px; white-space: pre-wrap; }

    .hint {
      margin-top: 6px;
      font-size: 12px;
      color: #aaa;
      line-height: 1.35;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="videoBox">
      <video id="video" autoplay playsinline></video>
      <div id="overlay"></div>
    </div>

    <div id="topBar">
      <button id="btnSpeakTest">ğŸ”Š ìŒì„± í…ŒìŠ¤íŠ¸(í•œ ë²ˆ íƒ­)</button>
      <button id="btnForceSolve">âš¡ ì§€ê¸ˆê¹Œì§€ë¡œ ê°•ì œ í’€ì´</button>
      <button id="btnReset">ğŸ”„ OCR ì¬ì‹œì‘(ìƒˆë¡œê³ ì¹¨)</button>
    </div>

    <div id="status">ì´ˆê¸°í™” ì¤‘...</div>

    <div class="grid">
      <div class="panel">
        <h3>ì‹¤ì‹œê°„ OCR(ëˆ„ì )</h3>
        <textarea id="ocrPreview" readonly></textarea>
        <div class="hint">
          ìˆ«ì/íŠ¹ìˆ˜ë¬¸ìëŠ” í‘œì‹œ(ì¶œë ¥)ì—ì„œ ì™„ì „íˆ ì œê±°ë¨.<br/>
          ìŒì„±ì´ ì•ˆ ë“¤ë¦¬ë©´: (1) ë¬´ìŒëª¨ë“œ OFF (2) ë³¼ë¥¨ ì˜¬ë¦¬ê¸° (3) ìœ„ â€œìŒì„± í…ŒìŠ¤íŠ¸â€ ë²„íŠ¼ 1ë²ˆ íƒ­.
        </div>
      </div>

      <div class="panel">
        <h3>ë‹µì•ˆ</h3>
        <pre id="answerBox"></pre>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // 0) ì„¤ì •
  // =========================
  const OCR_INTERVAL_MS = 5000;          // iOS ì•ˆì •ì„±: 3ì´ˆ â†’ 5ì´ˆ
  const OCR_LANG = "kor";                // í•œêµ­ì–´ OCR
  const TEXT_THRESHOLD_EFFECTIVE = 2400; // "ì¶©ë¶„íˆ ë´„" ê¸°ì¤€(ê³µë°± ì œì™¸)
  const INSUFFICIENT_WARN_MS = 60 * 1000;// 1ë¶„ ì§€ì† ì‹œ ì•ˆë‚´
  const MAX_WAIT_MS = 8 * 60 * 1000;     // 8ë¶„ì´ë©´ ë¶€ì¡±í•´ë„ ìë™ í’€ì´
  const SOLVE_URL = "/.netlify/functions/solve";

  // ìº¡ì²˜ í¬ê¸°(ë„ˆë¬´ í¬ë©´ iOSì—ì„œ Aborted(-1) ì˜ ëœ¸)
  const CAP_MAX_W = 1600;

  // iOS í¬ë˜ì‹œ ì›ì¸ì´ë¼ OFF(ì›í•˜ë©´ ë‚˜ì¤‘ì— ë‹¤ì‹œ ì¼œê¸°)
  const PREPROCESS_BINARIZE = false;

  // í™”ë©´ í”„ë¦¬ë·° ë°°ìœ¨(0.8)
  const PREVIEW_SCALE = 0.8;

  // ì¹´ë©”ë¼ ì¤Œ(ê°€ëŠ¥í•˜ë©´ 0.8)
  const REQUESTED_CAMERA_ZOOM = 0.8;

  // ìƒˆ ì„¸ê·¸ë¨¼íŠ¸(í˜ì´ì§€ ì¶”ì •) ë³€í™”ê°€ 20ì´ˆ ì—†ìœ¼ë©´ "ë§ˆì§€ë§‰ê¹Œì§€ ë´„"ìœ¼ë¡œ ê°€ì •í•˜ê³  í’€ì´
  const NO_NEW_SEGMENT_SOLVE_MS = 20000;

  // TTS
  const TTS_ENABLED = true;
  const TTS_RATE = 1.05;
  const TTS_PITCH = 1.0;
  const TTS_STATUS_COOLDOWN_MS = 12000;

  // =========================
  // 1) DOM
  // =========================
  const video = document.getElementById("video");
  const statusEl = document.getElementById("status");
  const ocrPreviewEl = document.getElementById("ocrPreview");
  const answerBoxEl = document.getElementById("answerBox");
  const btnSpeakTest = document.getElementById("btnSpeakTest");
  const btnForceSolve = document.getElementById("btnForceSolve");
  const btnReset = document.getElementById("btnReset");

  // =========================
  // 2) ë‚´ë¶€ ìƒíƒœ
  // =========================
  let stream = null;
  let track = null;

  let ocrRunning = false;
  let lastOcrAt = 0;

  // ëˆ„ì  ì„¸ê·¸ë¨¼íŠ¸(í˜ì´ì§€ ì¶”ì •)
  const segments = []; // { text, effLen, conf, updatedAt, sig }
  let lastNewSegmentAt = 0;

  // ëˆ„ì  ì „ì²´
  let cumulativeText = "";
  let cumulativeEffLen = 0;
  let cumulativeAvgConf = 0;

  // ê°€ë ¤ì§/ê±°ë¦¬ ì¶”ì •
  let blocked = false;
  let tooNear = false;
  let tooFar = false;

  // ë¶€ì¡± íƒ€ì´ë¨¸
  let insufficientSince = null;

  // solve ìƒíƒœ
  let solved = false;
  let solving = false;

  // TTS ìƒíƒœ
  let lastStatusSpokenAt = 0;
  let audioUnlocked = false;

  // ì¹´ë©”ë¼ ì¤Œ ì ìš© ê²°ê³¼
  let appliedZoomInfo = "ì•Œ ìˆ˜ ì—†ìŒ";

  // iOS í¬ë˜ì‹œ ê°ì§€
  let ocrFailCount = 0;

  // ë°ê¸°/ì›€ì§ì„ ë¶„ì„ìš©
  const BW = 64, BH = 36;
  const bCanvas = document.createElement("canvas");
  bCanvas.width = BW;
  bCanvas.height = BH;
  const bCtx = bCanvas.getContext("2d", { willReadFrequently: true });
  let prevThumb = null;
  let lastStableStart = 0;

  // ìº¡ì²˜ ìº”ë²„ìŠ¤(ì¬ì‚¬ìš©)
  const capCanvas = document.createElement("canvas");
  const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

  // Tesseract worker(ì¬ì‚¬ìš©í•´ì„œ ì•ˆì •ì„±/ì†ë„â†‘)
  let worker = null;
  let workerReady = false;
  let workerInitPromise = null;

  // =========================
  // 3) ìœ í‹¸
  // =========================
  function now() { return Date.now(); }

  function effectiveLenOf(text) {
    return (text || "").replace(/\s/g, "").length;
  }

  function normalizeForCompare(text) {
    return (text || "")
      .replace(/\s/g, "")
      .replace(/[^\uAC00-\uD7A3]/g, ""); // í•œê¸€ë§Œ ë‚¨ê¹€
  }

  function signatureOf(text) {
    const n = normalizeForCompare(text);
    return n.slice(0, 240);
  }

  function similarity(a, b) {
    const A = a || "", B = b || "";
    if (!A || !B) return 0;
    const len = Math.max(A.length, B.length);
    if (len === 0) return 0;
    const min = Math.min(A.length, B.length);
    let same = 0;
    for (let i = 0; i < min; i++) if (A[i] === B[i]) same++;
    return same / len;
  }

  function setStatus(lines) {
    statusEl.textContent = lines.join("\n");
  }

  // =========================
  // 4) í…ìŠ¤íŠ¸ ì •ë¦¬(ìš”ì²­: ìˆ«ì/ê¸°í˜¸ ì œê±°)
  // =========================
  function cleanOcrText(raw) {
    let t = (raw || "").replace(/\r/g, "").replace(/\s+\n/g, "\n").trim();

    // âœ… ìˆ«ì/ì˜ë¬¸/ê¸°í˜¸ ì œê±°: í•œê¸€ + ê³µë°±/ì¤„ë°”ê¿ˆë§Œ ë‚¨ê¹€
    t = t.replace(/[^ \n\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3]/g, "");

    // ê³µë°± ì •ë¦¬
    t = t.replace(/[ \t]{2,}/g, " ");
    t = t.replace(/\n{3,}/g, "\n\n");

    return t.trim();
  }

  // =========================
  // 5) ë¹„ìŠ·í•œ ë¬¸ì¥ "ë” ë§ëŠ” ê±¸ë¡œ" êµì •(ë¼ì¸ ë‹¨ìœ„ ë³‘í•©)
  // =========================
  function mergeLinewise(oldText, newText, oldConf, newConf) {
    const oldLines = (oldText || "").split("\n").map(s => s.trim());
    const newLines = (newText || "").split("\n").map(s => s.trim());
    const maxLen = Math.max(oldLines.length, newLines.length);

    const out = [];
    for (let i = 0; i < maxLen; i++) {
      const a = oldLines[i] || "";
      const b = newLines[i] || "";

      if (!a && b) { out.push(b); continue; }
      if (a && !b) { out.push(a); continue; }
      if (!a && !b) continue;

      const na = normalizeForCompare(a);
      const nb = normalizeForCompare(b);
      const sim = similarity(na, nb);

      // ê°™ì€ ì¤„ë¡œ ë³´ì´ë©´(ë¹„ìŠ·í•˜ë©´) ë” ì¢‹ì€ ìª½ ì„ íƒ
      if (sim >= 0.58) {
        const aEff = effectiveLenOf(a);
        const bEff = effectiveLenOf(b);

        // 1) ê¸¸ì´ê°€ ë” ê¸´ ìª½ ìš°ì„ (ì •ë³´ëŸ‰â†‘)
        // 2) ê¸¸ì´ê°€ ë¹„ìŠ·í•˜ë©´ conf ë†’ì€ ìª½
        const pickB =
          (bEff > aEff + 6) ||
          (Math.abs(bEff - aEff) <= 6 && (newConf > oldConf + 2));

        out.push(pickB ? b : a);
      } else {
        // ë‹¤ë¥¸ ë¬¸ì¥ìœ¼ë¡œ ë³´ì´ë©´: ë‘˜ ë‹¤ ìœ ì§€(ì•„ë˜ì— ë¶™ì„)
        out.push(a);
        out.push(b);
      }
    }

    // ë¹ˆ ì¤„ ì •ë¦¬
    return out.filter(x => (x || "").trim().length > 0).join("\n").trim();
  }

  // =========================
  // 6) iOS ìŒì„±(TTS)
  // =========================
  function unlockAudioOnce() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    speak("ìŒì„±ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.", true);
  }

  async function ensureVoicesReady(timeoutMs = 1800) {
    if (!("speechSynthesis" in window)) return false;

    const synth = window.speechSynthesis;
    const start = now();

    let voices = synth.getVoices();
    if (voices && voices.length > 0) return true;

    return await new Promise((resolve) => {
      let done = false;

      const timer = setInterval(() => {
        voices = synth.getVoices();
        if (voices && voices.length > 0) {
          if (!done) { done = true; clearInterval(timer); resolve(true); }
        }
        if (now() - start > timeoutMs) {
          if (!done) { done = true; clearInterval(timer); resolve(false); }
        }
      }, 120);

      synth.onvoiceschanged = () => {
        voices = synth.getVoices();
        if (voices && voices.length > 0) {
          if (!done) { done = true; clearInterval(timer); resolve(true); }
        }
      };
    });
  }

  function pickKoreanVoice() {
    if (!("speechSynthesis" in window)) return null;
    const voices = window.speechSynthesis.getVoices() || [];
    const ko = voices.filter(v => (v.lang || "").toLowerCase().startsWith("ko"));
    if (ko.length > 0) return ko[0];
    return voices.length ? voices[0] : null;
  }

  async function speak(text, force = false) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const t = (text || "").trim();
    if (!t) return;

    const tNow = now();
    if (!force && tNow - lastStatusSpokenAt < TTS_STATUS_COOLDOWN_MS) return;

    const ok = await ensureVoicesReady();
    const voice = ok ? pickKoreanVoice() : null;

    try {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(t);
      u.lang = "ko-KR";
      u.rate = TTS_RATE;
      u.pitch = TTS_PITCH;
      if (voice) u.voice = voice;
      lastStatusSpokenAt = tNow;
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  async function speakLong(text) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;

    const t = (text || "").trim();
    if (!t) return;

    await ensureVoicesReady();
    const voice = pickKoreanVoice();

    const chunkSize = 900;
    const chunks = [];
    for (let i = 0; i < t.length; i += chunkSize) chunks.push(t.slice(i, i + chunkSize));

    try {
      window.speechSynthesis.cancel();
      let idx = 0;
      const speakNext = () => {
        if (idx >= chunks.length) return;
        const u = new SpeechSynthesisUtterance(chunks[idx]);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        if (voice) u.voice = voice;
        u.onend = () => { idx += 1; speakNext(); };
        window.speechSynthesis.speak(u);
      };
      speakNext();
    } catch (e) {}
  }

  // ë²„íŠ¼ ì´ë²¤íŠ¸(ëª…ì‹œì  íƒ­ìœ¼ë¡œ iOS TTS í™•ì‹¤íˆ ì¼œê¸°)
  btnSpeakTest.addEventListener("click", async () => {
    unlockAudioOnce();

    const hasSynth = ("speechSynthesis" in window);
    const voiceOk = await ensureVoicesReady();
    const v = voiceOk ? pickKoreanVoice() : null;

    const msg =
      !hasSynth ? "ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„±ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
      : (!voiceOk ? "ìŒì„± ëª©ë¡ ë¡œë”©ì´ ì§€ì—°ë©ë‹ˆë‹¤. ë¬´ìŒëª¨ë“œ í•´ì œì™€ ë³¼ë¥¨ì„ ì˜¬ë¦¬ê³  ë‹¤ì‹œ ëˆŒëŸ¬ì£¼ì„¸ìš”."
      : ("ìŒì„± í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤. " + (v ? ("í˜„ì¬ ìŒì„±: " + (v.name || "ì•Œ ìˆ˜ ì—†ìŒ")) : "")));

    speak(msg, true);
  });

  btnReset.addEventListener("click", () => location.reload());

  btnForceSolve.addEventListener("click", async () => {
    unlockAudioOnce();
    await autoSolve("ì‚¬ìš©ì ê°•ì œ í’€ì´(ì§€ë¬¸ ë¶€ì¡± ê°€ëŠ¥)");
  });

  // í™”ë©´ íƒ­/í„°ì¹˜ë¡œë„ ì–¸ë½
  document.addEventListener("click", unlockAudioOnce, { passive: true, once: true });
  document.addEventListener("touchstart", unlockAudioOnce, { passive: true, once: true });

  // =========================
  // 7) iOS Aborted(-1) ëŒ€ì‘
  // =========================
  async function hardResetOcrEngine() {
    try { await speak("OCR ì—”ì§„ì´ ì˜¤ë¥˜ë¡œ ì¤‘ë‹¨ë˜ì–´ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.", true); } catch (e) {}
    setTimeout(() => { location.reload(); }, 600);
  }

  // =========================
  // 8) ì¹´ë©”ë¼ ì‹œì‘ + ì¤Œ
  // =========================
  async function startCamera() {
    try {
      video.style.transform = `scale(${PREVIEW_SCALE})`;

      setStatus([
        "ì¹´ë©”ë¼ ìš”ì²­ ì¤‘...",
        "ê¶Œí•œ íŒì—…ì´ ëœ¨ë©´ 'í—ˆìš©'."
      ]);

      const constraints = {
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 3840 },
          height: { ideal: 2160 },
          frameRate: { ideal: 30 }
        },
        audio: false
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      track = stream.getVideoTracks()[0] || null;

      await new Promise((resolve) => {
        if (video.readyState >= 2) return resolve();
        video.onloadedmetadata = () => resolve();
      });

      await tryApplyZoom(track, REQUESTED_CAMERA_ZOOM);

      setStatus(buildStatusLines("ì¹´ë©”ë¼ ON Â· OCR ì¤€ë¹„"));
      requestAnimationFrame(analyzeLoop);

      // OCR worker ì¤€ë¹„ í›„ ë£¨í”„ ì‹œì‘
      await initOcrWorker();
      scheduleOcrLoop();

      setStatus(buildStatusLines("ì¹´ë©”ë¼ ON Â· ìë™ OCR ì‹œì‘"));
    } catch (e) {
      console.error(e);
      setStatus(["ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨", String(e)]);
      speak("ì¹´ë©”ë¼ ì ‘ê·¼ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", true);
    }
  }

  async function tryApplyZoom(track, requested) {
    try {
      if (!track || typeof track.getCapabilities !== "function") {
        appliedZoomInfo = "zoom cap ì—†ìŒ";
        return;
      }
      const cap = track.getCapabilities();
      if (!cap || typeof cap.zoom === "undefined") {
        appliedZoomInfo = "zoom ë¯¸ì§€ì›";
        return;
      }

      const minZ = cap.zoom.min;
      const maxZ = cap.zoom.max;
      const target = Math.max(minZ, Math.min(maxZ, requested));

      if (typeof track.applyConstraints === "function") {
        await track.applyConstraints({ advanced: [{ zoom: target }] });
        appliedZoomInfo = `ìš”ì²­ ${requested} â†’ ì ìš© ${target} (cap ${minZ}-${maxZ})`;
      } else {
        appliedZoomInfo = "applyConstraints ì—†ìŒ";
      }
    } catch (e) {
      appliedZoomInfo = "zoom ì ìš© ì‹¤íŒ¨";
    }
  }

  // =========================
  // 9) ë°ê¸°/ì›€ì§ì„ ë¶„ì„(ê°€ë ¤ì§)
  // =========================
  function analyzeFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      return { blocked: false, stable: false, avgBright: 255, diffAvg: 0 };
    }

    bCtx.drawImage(video, 0, 0, BW, BH);
    const img = bCtx.getImageData(0, 0, BW, BH).data;

    const len = BW * BH;
    const currThumb = new Uint8Array(len);

    let sumBright = 0;
    let diffSum = 0;

    for (let i = 0, p = 0; i < img.length; i += 4, p++) {
      const r = img[i], g = img[i + 1], b = img[i + 2];
      const gray = (r + g + b) / 3;
      currThumb[p] = gray;
      sumBright += gray;
      if (prevThumb) diffSum += Math.abs(gray - prevThumb[p]);
    }

    const avgBright = sumBright / len;
    const diffAvg = prevThumb ? (diffSum / len) : 0;
    prevThumb = currThumb;

    const isBlocked = avgBright < 20;

    const tNow = now();
    let stable = false;
    if (diffAvg < 8) {
      if (!lastStableStart) lastStableStart = tNow;
      if (tNow - lastStableStart >= 900) stable = true;
    } else {
      lastStableStart = 0;
    }

    return { blocked: isBlocked, stable, avgBright, diffAvg };
  }

  function analyzeLoop() {
    const a = analyzeFrame();
    blocked = a.blocked;
    requestAnimationFrame(analyzeLoop);
  }

  // =========================
  // 10) ìº¡ì²˜
  // =========================
  function captureToCanvas() {
    const vw = video.videoWidth;
    const vh = video.videoHeight;

    if (!vw || !vh) {
      capCanvas.width = 640;
      capCanvas.height = 360;
      capCtx.fillStyle = "black";
      capCtx.fillRect(0, 0, capCanvas.width, capCanvas.height);
      return capCanvas;
    }

    const cropW = vw;
    const cropH = vh;
    const cropX = 0;
    const cropY = 0;

    const scale = Math.min(1, CAP_MAX_W / cropW);
    const outW = Math.max(480, Math.floor(cropW * scale));
    const outH = Math.max(360, Math.floor(cropH * scale));

    capCanvas.width = outW;
    capCanvas.height = outH;

    capCtx.imageSmoothingEnabled = false;
    capCtx.drawImage(video, cropX, cropY, cropW, cropH, 0, 0, outW, outH);

    // iOS í¬ë˜ì‹œ ì¤„ì´ë ¤ê³  ê¸°ë³¸ OFF
    if (PREPROCESS_BINARIZE) {
      // (ë‚˜ì¤‘ì— í•„ìš”í•˜ë©´ ì—¬ê¸°ì„œ ì´ì§„í™”/ìƒ¤í”„ë‹ ì¶”ê°€ ê°€ëŠ¥)
    }

    return capCanvas;
  }

  // =========================
  // 11) Tesseract worker ì´ˆê¸°í™”(í•œ ë²ˆë§Œ)
  // =========================
  async function initOcrWorker() {
    if (workerReady) return true;
    if (workerInitPromise) return workerInitPromise;

    workerInitPromise = (async () => {
      try {
        setStatus(buildStatusLines("OCR ì—”ì§„ ë¡œë”© ì¤‘..."));

        if (worker) {
          try { await worker.terminate(); } catch (e) {}
          worker = null;
        }

        worker = await Tesseract.createWorker({
          logger: (m) => {
            if (m && m.status === "recognizing text") {
              const p = Math.round((m.progress || 0) * 100);
              setStatus(buildStatusLines(`OCR ì—”ì§„ ì¤€ë¹„... ${p}%`));
            }
          }
        });

        await worker.loadLanguage(OCR_LANG);
        await worker.initialize(OCR_LANG);

        workerReady = true;
        setStatus(buildStatusLines("OCR ì—”ì§„ ì¤€ë¹„ ì™„ë£Œ"));
        return true;
      } catch (e) {
        workerReady = false;
        setStatus(buildStatusLines("OCR ì—”ì§„ ë¡œë”© ì‹¤íŒ¨: " + String(e)));
        return false;
      } finally {
        workerInitPromise = null;
      }
    })();

    return workerInitPromise;
  }

  // =========================
  // 12) OCR ë£¨í”„(ë©ˆì¶”ì§€ ì•Šê²Œ)
  // =========================
  function shouldTryOcr() {
    if (solved || solving) return false;
    if (ocrRunning) return false;
    if (blocked) return false;

    const tNow = now();
    if (tNow - lastOcrAt < OCR_INTERVAL_MS) return false;

    return true;
  }

  async function doOcrOnce() {
    if (!shouldTryOcr()) return;

    // workerê°€ ì¤€ë¹„ ì•ˆ ë˜ì—ˆìœ¼ë©´ ë‹¤ì‹œ ì‹œë„
    if (!workerReady) {
      const ok = await initOcrWorker();
      if (!ok) return;
    }

    ocrRunning = true;
    lastOcrAt = now();

    try {
      const canvas = captureToCanvas();
      setStatus(buildStatusLines("OCR ì§„í–‰ ì¤‘..."));

      const result = await worker.recognize(canvas);

      const rawText = (result && result.data && result.data.text) ? result.data.text : "";
      const conf = (result && result.data && typeof result.data.confidence === "number")
        ? result.data.confidence
        : 0;

      const text = cleanOcrText(rawText);
      const effLen = effectiveLenOf(text);

      if (effLen < 30 || conf < 5) {
        setStatus(buildStatusLines("OCR ì™„ë£Œ(ë„ˆë¬´ ì§§ìŒ/ë‚®ì€ ì‹ ë¢°ë„)"));
        return;
      }

      // ê±°ë¦¬ ì¶”ì •(íœ´ë¦¬ìŠ¤í‹±)
      tooFar = (effLen < 450 && conf < 35);
      tooNear = (effLen >= 900 && conf < 35);

      updateSegments(text, effLen, conf);
      updateCumulative();

      // ë¶€ì¡± íƒ€ì´ë¨¸
      const tNow = now();
      if (cumulativeEffLen < TEXT_THRESHOLD_EFFECTIVE) {
        if (!insufficientSince) insufficientSince = tNow;
      } else {
        insufficientSince = null;
      }

      ocrPreviewEl.value = cumulativeText;
      setStatus(buildStatusLines("OCR ì™„ë£Œ"));

      // ìë™ í’€ì´ ì¡°ê±´
      if (!solved && !solving) {
        const enough = cumulativeEffLen >= TEXT_THRESHOLD_EFFECTIVE;
        const noNewFor = lastNewSegmentAt ? (tNow - lastNewSegmentAt) : 0;
        const insufficientDuration = insufficientSince ? (tNow - insufficientSince) : 0;

        // 1ë¶„ ì—°ì† ë¶€ì¡±ì´ë©´ ì•ˆë‚´(ì •ë§ ë¶€ì¡±í•  ë•Œë§Œ)
        if (insufficientSince && insufficientDuration >= INSUFFICIENT_WARN_MS && insufficientDuration < MAX_WAIT_MS) {
          speak(buildInsufficientReason(), false);
        }

        if (enough && noNewFor >= NO_NEW_SEGMENT_SOLVE_MS) {
          await autoSolve("ëˆ„ì  ì¶©ë¶„ + ìƒˆ í˜ì´ì§€ ë³€í™” ì—†ìŒ");
          return;
        }

        if (insufficientSince && insufficientDuration >= MAX_WAIT_MS) {
          await autoSolve("ìµœëŒ€ ëŒ€ê¸°ì‹œê°„ ì´ˆê³¼(ì§€ë¬¸ ë¶€ì¡±). í˜„ì¬ ëˆ„ì  ë‚´ìš©ìœ¼ë¡œ í’€ì´");
          return;
        }
      }

      // ì„±ê³µí•˜ë©´ failCount ë¦¬ì…‹
      ocrFailCount = 0;

    } catch (e) {
      console.error(e);
      const msg = String(e || "");
      setStatus(buildStatusLines("OCR ì—ëŸ¬: " + msg));

      // âœ… iOSì—ì„œ ìì£¼ ëœ¨ëŠ” í¬ë˜ì‹œ: RuntimeError: Aborted(-1)
      if (msg.includes("Aborted") || msg.includes("RuntimeError")) {
        ocrFailCount += 1;
        workerReady = false;
        try { if (worker) await worker.terminate(); } catch (x) {}
        worker = null;

        // 1ë²ˆì€ ì—”ì§„ ì¬ì´ˆê¸°í™”, 2ë²ˆ ì—°ì†ì´ë©´ ìƒˆë¡œê³ ì¹¨ì´ ê°€ì¥ í™•ì‹¤
        if (ocrFailCount >= 2) {
          await hardResetOcrEngine();
          return;
        } else {
          await initOcrWorker();
          return;
        }
      }
    } finally {
      ocrRunning = false;
    }
  }

  function updateSegments(text, effLen, conf) {
    const sig = signatureOf(text);

    let bestIdx = -1;
    let bestSim = 0;

    for (let i = 0; i < segments.length; i++) {
      const s = segments[i];
      const sim = similarity(sig, s.sig);
      if (sim > bestSim) {
        bestSim = sim;
        bestIdx = i;
      }
    }

    const SAME_PAGE_SIM = 0.62;

    if (bestIdx >= 0 && bestSim >= SAME_PAGE_SIM) {
      const prev = segments[bestIdx];

      // âœ… "ë¹„ìŠ·í•œ ë¬¸ì¥ë“¤ì€ ë” ë§ëŠ” ê±¸ë¡œ" = ë¼ì¸ ë‹¨ìœ„ ë³‘í•©
      const merged = mergeLinewise(prev.text, text, prev.conf, conf);
      const mergedEff = effectiveLenOf(merged);

      // ë³‘í•© ê²°ê³¼ê°€ ë” ì¢‹ì•„ì¡Œìœ¼ë©´ ê°±ì‹ 
      const better =
        (mergedEff > prev.effLen + 30) ||
        (Math.abs(mergedEff - prev.effLen) <= 30 && conf > prev.conf + 3);

      if (better) {
        segments[bestIdx] = { text: merged, effLen: mergedEff, conf: Math.max(prev.conf, conf), updatedAt: now(), sig: signatureOf(merged) };
      } else {
        // ìµœì†Œí•œ ìµœì‹  ì‹œê°„ ê°±ì‹ 
        segments[bestIdx].updatedAt = now();
      }
      return;
    }

    segments.push({ text, effLen, conf, updatedAt: now(), sig });
    lastNewSegmentAt = now();
  }

  function updateCumulative() {
    let out = "";
    let totalEff = 0;
    let confSum = 0;

    for (let i = 0; i < segments.length; i++) {
      const s = segments[i];
      if (i > 0) out += "\n\n----------\n\n";
      out += s.text;
      totalEff += s.effLen;
      confSum += s.conf;
    }

    cumulativeText = out.trim();
    cumulativeEffLen = totalEff;
    cumulativeAvgConf = segments.length ? (confSum / segments.length) : 0;
  }

  // =========================
  // 13) ìƒíƒœ/ì•ˆë‚´
  // =========================
  function buildInsufficientReason() {
    if (blocked) return "ì¹´ë©”ë¼ê°€ ê°€ë ¤ì¡ŒìŠµë‹ˆë‹¤. ë Œì¦ˆë¥¼ ê°€ë¦¬ì§€ ì•Šê²Œ í•´ì£¼ì„¸ìš”.";
    if (tooFar) return "ì§€ë¬¸ì´ ë„ˆë¬´ ë©€ì–´ ë³´ì…ë‹ˆë‹¤. ì¢…ì´ë¥¼ í™”ë©´ì— ë” í¬ê²Œ ì±„ì›Œì£¼ì„¸ìš”.";
    if (tooNear) return "ì§€ë¬¸ì´ ë„ˆë¬´ ê°€ê¹Œì›Œ ë³´ì…ë‹ˆë‹¤. ì¡°ê¸ˆë§Œ ë©€ë¦¬ ë‘ê³  ë‹¤ì‹œ ë¹„ì¶°ì£¼ì„¸ìš”.";
    return "ì•„ì§ ì§€ë¬¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ì²« ì œì‹œë¬¸ë¶€í„° ë§ˆì§€ë§‰ ì§ˆë¬¸ê¹Œì§€ ì²œì²œíˆ ë¹„ì¶°ì£¼ì„¸ìš”.";
  }

  function buildStatusLines(extraLine) {
    const lines = [];
    lines.push("ìë™ OCR(ëˆ„ì ) â†’ ìë™ í’€ì´");
    lines.push(`í”„ë¦¬ë·° ë°°ìœ¨: ${PREVIEW_SCALE} | ì¹´ë©”ë¼ zoom: ${appliedZoomInfo}`);
    lines.push(`ì¹´ë©”ë¼ ìƒíƒœ: ${blocked ? "ê°€ë ¤ì§" : "ì •ìƒ"}`);

    let dist = "ì •ìƒ(ì¶”ì •)";
    if (tooFar) dist = "ë„ˆë¬´ ë©‚(ì¶”ì •)";
    else if (tooNear) dist = "ë„ˆë¬´ ê°€ê¹Œì›€(ì¶”ì •)";
    lines.push(`ê±°ë¦¬ ìƒíƒœ: ${dist}`);

    lines.push(`ì„¸ê·¸ë¨¼íŠ¸(í˜ì´ì§€ ì¶”ì •) ìˆ˜: ${segments.length}`);
    lines.push(`ëˆ„ì  OCR ê¸¸ì´(ê³µë°±ì œì™¸): ${cumulativeEffLen} / ê¸°ì¤€ ${TEXT_THRESHOLD_EFFECTIVE}`);
    lines.push(`í‰ê·  OCR ì‹ ë¢°ë„(ëŒ€ëµ): ${cumulativeAvgConf.toFixed(1)}%`);

    if (insufficientSince && cumulativeEffLen < TEXT_THRESHOLD_EFFECTIVE) {
      const sec = Math.floor((now() - insufficientSince) / 1000);
      lines.push(`ì§€ë¬¸ ë¶€ì¡± ì§€ì†: ${sec}ì´ˆ (1ë¶„ ì•ˆë‚´, 8ë¶„ì´ë©´ ìë™ í’€ì´)`);
    } else {
      lines.push("ì§€ë¬¸ ë¶€ì¡± ì§€ì†: 0ì´ˆ");
    }

    const synthOk = ("speechSynthesis" in window) ? "ì§€ì›" : "ë¯¸ì§€ì›";
    lines.push(`ìŒì„±(TTS): ${synthOk} | ì–¸ë½: ${audioUnlocked ? "ì™„ë£Œ" : "ëŒ€ê¸°(ë²„íŠ¼ íƒ­)"}`);

    if (extraLine) lines.push(String(extraLine));
    return lines;
  }

  // =========================
  // 14) ìë™ í’€ì´(solve)
  // =========================
  async function autoSolve(reason) {
    if (solved || solving) return;
    solving = true;

    unlockAudioOnce();

    const payloadText = (cumulativeText || "").trim();
    if (!payloadText) {
      answerBoxEl.textContent = "ëˆ„ì  OCR í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.";
      solving = false;
      return;
    }

    setStatus(buildStatusLines(`í’€ì´ ìš”ì²­ ì¤‘... (${reason})`));
    answerBoxEl.textContent = "í’€ì´ ìƒì„± ì¤‘...";

    // solve.jsëŠ” { ocrText } ê¸°ëŒ€(ë„¤ ì½”ë“œ ê¸°ì¤€)
    const body = JSON.stringify({ ocrText: payloadText });

    try {
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();

      let out = "";
      if (ct.includes("application/json")) {
        let data;
        try { data = await res.json(); }
        catch (e) { out = "JSON íŒŒì‹± ì—ëŸ¬: " + String(e); }
        if (!out) {
          if (data && typeof data.answer === "string") out = data.answer;
          else if (data && typeof data.body === "string") out = data.body;
          else out = JSON.stringify(data);
        }
      } else {
        out = await res.text();
      }

      if (!res.ok) {
        answerBoxEl.textContent = `ì„œë²„ ì—ëŸ¬ (status ${res.status})\n\n${out.slice(0, 4000)}`;
        speak("ì„œë²„ ì—ëŸ¬ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", true);
        solving = false;
        return;
      }

      // ì„±ê³µ
      solved = true;

      const isInsufficientSolve =
        (reason || "").includes("ìµœëŒ€ ëŒ€ê¸°ì‹œê°„") ||
        (reason || "").includes("ì§€ë¬¸ ë¶€ì¡±") ||
        (reason || "").includes("ê°•ì œ í’€ì´");

      const prefix = isInsufficientSolve
        ? "ì§€ë¬¸ì´ ë¶€ì¡±í•˜ì—¬ í˜„ì¬ê¹Œì§€ ì¸ì‹ëœ ë‚´ìš©ìœ¼ë¡œ ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.\n\n"
        : "";

      answerBoxEl.textContent = prefix + out;
      setStatus(buildStatusLines("í’€ì´ ì™„ë£Œ"));

      if (isInsufficientSolve) {
        speak("ì§€ë¬¸ì´ ë¶€ì¡±í•˜ì—¬ í˜„ì¬ê¹Œì§€ ì¸ì‹ëœ ë‚´ìš©ìœ¼ë¡œ ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.", true);
      } else {
        speak("ë‹µì•ˆì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.", true);
      }

      speakLong(prefix + out);

    } catch (e) {
      console.error(e);
      answerBoxEl.textContent = "ìš”ì²­ ì‹¤íŒ¨: " + String(e);
      speak("ìš”ì²­ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", true);
    } finally {
      solving = false;
    }
  }

  // =========================
  // 15) OCR ë£¨í”„ ì‹œì‘
  // =========================
  function scheduleOcrLoop() {
    doOcrOnce();
    setInterval(() => { doOcrOnce(); }, OCR_INTERVAL_MS);
  }

  // =========================
  // 16) ì‹œì‘
  // =========================
  startCamera();
})();
</script>
</body>
</html>


