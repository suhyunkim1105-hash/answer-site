<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Auto OCR(ëˆ„ì ) â†’ Auto Solve (KOR)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>

  <!-- Tesseract.js v5 -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body { margin:0; padding:10px; background:#000; color:#fff; font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif; }
    .wrap { max-width:980px; margin:0 auto; }
    #videoBox { position:relative; width:100%; border:1px solid #333; border-radius:12px; overflow:hidden; background:#000; }
    #video { width:100%; height:auto; display:block; transform-origin:center center; }
    #overlay { position:absolute; inset:0; border:2px solid rgba(0,255,0,0.30); pointer-events:none; }
    #topBar { margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
    button { padding:10px 12px; border-radius:10px; border:1px solid #333; background:#151515; color:#fff; font-size:13px; cursor:pointer; }
    button:active { transform:scale(0.98); }
    #status { margin-top:10px; padding:10px; border:1px solid #333; border-radius:10px; background:#111; font-size:13px; line-height:1.4; white-space:pre-wrap; }
    .grid { display:grid; grid-template-columns:1fr; gap:10px; margin-top:10px; }
    .panel { border:1px solid #333; border-radius:10px; background:#0b0b0b; padding:10px; }
    .panel h3 { margin:0 0 8px 0; font-size:14px; color:#cfcfcf; font-weight:600; }
    textarea, pre {
      width:100%;
      border:1px solid #222;
      border-radius:8px;
      background:#000;
      color:#fff;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace;
      font-size:12px;
      padding:10px;
      margin:0;
    }
    textarea { height:240px; resize:vertical; }
    pre { min-height:260px; white-space:pre-wrap; }
    .hint { margin-top:6px; font-size:12px; color:#aaa; line-height:1.35; }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="videoBox">
      <video id="video" autoplay playsinline></video>
      <div id="overlay"></div>
    </div>

    <div id="topBar">
      <button id="btnSpeakTest">ğŸ”Š ìŒì„± í…ŒìŠ¤íŠ¸(í•œ ë²ˆ íƒ­)</button>
      <button id="btnForceSolve">âš¡ ì§€ê¸ˆê¹Œì§€ë¡œ ê°•ì œ í’€ì´</button>
      <button id="btnReset">ğŸ”„ OCR ì¬ì‹œì‘(ìƒˆë¡œê³ ì¹¨)</button>
    </div>

    <div id="status">ì´ˆê¸°í™” ì¤‘...</div>

    <div class="grid">
      <div class="panel">
        <h3>ì‹¤ì‹œê°„ OCR(ëˆ„ì )</h3>
        <textarea id="ocrPreview" readonly></textarea>
        <div class="hint">
          ìˆ«ì/íŠ¹ìˆ˜ë¬¸ìëŠ” í™”ë©´ í‘œì‹œì—ì„œ ì œê±°ë¨(ë°©í•´ ìµœì†Œí™”).<br/>
          iOSëŠ” ë‹µì•ˆ TTSê°€ ìë™ìœ¼ë¡œ ì•ˆ ë‚˜ì˜¬ ìˆ˜ ìˆìœ¼ë‹ˆ â€œìŒì„± í…ŒìŠ¤íŠ¸â€ë¥¼ í•œ ë²ˆ ëˆŒëŸ¬ì„œ ì–¸ë½í•´ì¤˜ì•¼ í•¨.
        </div>
      </div>

      <div class="panel">
        <h3>ë‹µì•ˆ</h3>
        <pre id="answerBox"></pre>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // ì„¤ì •
  // =========================
  const OCR_INTERVAL_MS = 6000;                 // ë„ˆë¬´ ì§§ìœ¼ë©´ iOSì—ì„œ ë©”ëª¨ë¦¬/ë°œì—´ë¡œ Aborted(-1) í™•ë¥ â†‘
  const OCR_LANG = "kor";

  const TEXT_THRESHOLD_EFFECTIVE = 2400;        // ê³µë°± ì œì™¸ ëˆ„ì  ê¸¸ì´ ê¸°ì¤€
  const INSUFFICIENT_WARN_MS = 60 * 1000;       // 1ë¶„ ì§€ë‚˜ë©´ â€œì§€ë¬¸ ë¶€ì¡±â€ ì•ˆë‚´
  const MAX_WAIT_MS = 8 * 60 * 1000;            // 8ë¶„ì´ë©´ â€œì§€ë¬¸ ë¶€ì¡± ìë™í’€ì´â€
  const NO_NEW_SEGMENT_SOLVE_MS = 20000;        // ìƒˆ í˜ì´ì§€(ì„¸ê·¸ë¨¼íŠ¸) ë³€í™”ê°€ 20ì´ˆ ì—†ìœ¼ë©´ ìë™ í’€ì´

  const SOLVE_URL = "/.netlify/functions/solve";

  const CAP_MAX_W = 1280;                       // 1600ë³´ë‹¤ ë‚®ì¶°ì„œ iOS ì•ˆì •ì„±â†‘
  const PREVIEW_SCALE = 0.8;                    // í™”ë©´ í”„ë¦¬ë·° ë°°ìœ¨(ì‚¬ìš©ì ìš”ì²­)
  const REQUESTED_CAMERA_ZOOM = 0.8;            // ì§€ì›ë˜ëŠ” ê¸°ê¸°ë©´ ì¹´ë©”ë¼ ì¤Œ ì ìš© ì‹œë„

  const TTS_ENABLED = true;
  const TTS_RATE = 1.05;
  const TTS_PITCH = 1.0;
  const TTS_STATUS_COOLDOWN_MS = 12000;

  // âœ… OCR ì—”ì§„ ë¬´í•œ ë¡œë”© ë°©ì§€: íƒ€ì„ì•„ì›ƒ/ì¬ì‹œë„
  const WORKER_INIT_TIMEOUT_MS = 35000;
  const WORKER_RETRY_MAX = 2;

  // âœ… í•œêµ­ì–´ traineddata ë¡œë”© ê²½ë¡œ(ê°€ì¥ ì•ˆì •ì ì¸ CDN)
  // ì•„ë˜ ê²½ë¡œì— kor.traineddata(.gz)ê°€ ìˆì–´ì•¼ í•¨
  const LANG_PATH = "https://cdn.jsdelivr.net/npm/@tesseract.js-data/kor/4.0.0_best_int";

  // =========================
  // DOM
  // =========================
  const video = document.getElementById("video");
  const statusEl = document.getElementById("status");
  const ocrPreviewEl = document.getElementById("ocrPreview");
  const answerBoxEl = document.getElementById("answerBox");
  const btnSpeakTest = document.getElementById("btnSpeakTest");
  const btnForceSolve = document.getElementById("btnForceSolve");
  const btnReset = document.getElementById("btnReset");

  // =========================
  // ìƒíƒœ
  // =========================
  let stream = null;
  let track = null;

  let ocrRunning = false;
  let lastOcrAt = 0;

  const segments = [];
  let lastNewSegmentAt = 0;

  let cumulativeText = "";
  let cumulativeEffLen = 0;
  let cumulativeAvgConf = 0;

  let blocked = false;
  let tooNear = false;
  let tooFar = false;

  let insufficientSince = null;

  let solved = false;
  let solving = false;

  let lastStatusSpokenAt = 0;
  let audioUnlocked = false;

  let appliedZoomInfo = "ì•Œ ìˆ˜ ì—†ìŒ";

  let ocrFailCount = 0;

  // ë¶„ì„(ê°€ë ¤ì§/ì•ˆì •ë„)
  const BW = 64, BH = 36;
  const bCanvas = document.createElement("canvas");
  bCanvas.width = BW; bCanvas.height = BH;
  const bCtx = bCanvas.getContext("2d", { willReadFrequently: true });
  let prevThumb = null;
  let lastStableStart = 0;

  // ìº¡ì²˜ ìº”ë²„ìŠ¤(ì¬ì‚¬ìš©)
  const capCanvas = document.createElement("canvas");
  const capCtx = capCanvas.getContext("2d", { willReadFrequently: true });

  // Tesseract worker
  let worker = null;
  let workerReady = false;

  // =========================
  // ìœ í‹¸
  // =========================
  const now = () => Date.now();

  function effectiveLenOf(text) {
    return (text || "").replace(/\s/g, "").length;
  }

  function normalizeForCompare(text) {
    return (text || "").replace(/\s/g, "").replace(/[^\uAC00-\uD7A3]/g, "");
  }

  function signatureOf(text) {
    return normalizeForCompare(text).slice(0, 240);
  }

  function similarity(a, b) {
    const A = a || "", B = b || "";
    if (!A || !B) return 0;
    const len = Math.max(A.length, B.length);
    const min = Math.min(A.length, B.length);
    let same = 0;
    for (let i = 0; i < min; i++) if (A[i] === B[i]) same++;
    return len ? (same / len) : 0;
  }

  function setStatus(lines) {
    statusEl.textContent = lines.join("\n");
  }

  // =========================
  // í…ìŠ¤íŠ¸ ì •ë¦¬(ìˆ«ì/ê¸°í˜¸ ì œê±°)
  // =========================
  function cleanOcrText(raw) {
    let t = (raw || "").replace(/\r/g, "").replace(/\s+\n/g, "\n").trim();

    // í•œê¸€(ìëª¨ í¬í•¨) + ê³µë°±/ê°œí–‰ë§Œ ë‚¨ê¹€
    t = t.replace(/[^ \n\u1100-\u11FF\u3130-\u318F\uAC00-\uD7A3]/g, "");

    t = t.replace(/[ \t]{2,}/g, " ");
    t = t.replace(/\n{3,}/g, "\n\n");
    return t.trim();
  }

  // =========================
  // ë¹„ìŠ·í•œ ë¬¸ì¥ êµì •(ë¼ì¸ ë³‘í•©)
  // =========================
  function mergeLinewise(oldText, newText, oldConf, newConf) {
    const oldLines = (oldText || "").split("\n").map(s => s.trim());
    const newLines = (newText || "").split("\n").map(s => s.trim());
    const maxLen = Math.max(oldLines.length, newLines.length);

    const out = [];
    for (let i = 0; i < maxLen; i++) {
      const a = oldLines[i] || "";
      const b = newLines[i] || "";
      if (!a && b) { out.push(b); continue; }
      if (a && !b) { out.push(a); continue; }
      if (!a && !b) continue;

      const na = normalizeForCompare(a);
      const nb = normalizeForCompare(b);
      const sim = similarity(na, nb);

      if (sim >= 0.58) {
        const aEff = effectiveLenOf(a);
        const bEff = effectiveLenOf(b);
        const pickB =
          (bEff > aEff + 6) ||
          (Math.abs(bEff - aEff) <= 6 && (newConf > oldConf + 2));
        out.push(pickB ? b : a);
      } else {
        out.push(a);
        out.push(b);
      }
    }
    return out.filter(x => (x || "").trim().length > 0).join("\n").trim();
  }

  // =========================
  // TTS
  // =========================
  function unlockAudioOnce() {
    if (audioUnlocked) return;
    audioUnlocked = true;
    speak("ìŒì„±ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.", true);
  }

  async function ensureVoicesReady(timeoutMs = 1800) {
    if (!("speechSynthesis" in window)) return false;
    const synth = window.speechSynthesis;
    const start = now();
    let voices = synth.getVoices();
    if (voices && voices.length > 0) return true;

    return await new Promise((resolve) => {
      let done = false;
      const timer = setInterval(() => {
        voices = synth.getVoices();
        if (voices && voices.length > 0) {
          if (!done) { done = true; clearInterval(timer); resolve(true); }
        }
        if (now() - start > timeoutMs) {
          if (!done) { done = true; clearInterval(timer); resolve(false); }
        }
      }, 120);

      synth.onvoiceschanged = () => {
        voices = synth.getVoices();
        if (voices && voices.length > 0) {
          if (!done) { done = true; clearInterval(timer); resolve(true); }
        }
      };
    });
  }

  function pickKoreanVoice() {
    if (!("speechSynthesis" in window)) return null;
    const voices = window.speechSynthesis.getVoices() || [];
    const ko = voices.filter(v => (v.lang || "").toLowerCase().startsWith("ko"));
    if (ko.length > 0) return ko[0];
    return voices.length ? voices[0] : null;
  }

  async function speak(text, force = false) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;
    const t = (text || "").trim();
    if (!t) return;

    const tNow = now();
    if (!force && tNow - lastStatusSpokenAt < TTS_STATUS_COOLDOWN_MS) return;

    const ok = await ensureVoicesReady();
    const voice = ok ? pickKoreanVoice() : null;

    try {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(t);
      u.lang = "ko-KR";
      u.rate = TTS_RATE;
      u.pitch = TTS_PITCH;
      if (voice) u.voice = voice;
      lastStatusSpokenAt = tNow;
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  async function speakLong(text) {
    if (!TTS_ENABLED) return;
    if (!("speechSynthesis" in window)) return;
    const t = (text || "").trim();
    if (!t) return;

    await ensureVoicesReady();
    const voice = pickKoreanVoice();

    const chunkSize = 900;
    const chunks = [];
    for (let i = 0; i < t.length; i += chunkSize) chunks.push(t.slice(i, i + chunkSize));

    try {
      window.speechSynthesis.cancel();
      let idx = 0;
      const speakNext = () => {
        if (idx >= chunks.length) return;
        const u = new SpeechSynthesisUtterance(chunks[idx]);
        u.lang = "ko-KR";
        u.rate = TTS_RATE;
        u.pitch = TTS_PITCH;
        if (voice) u.voice = voice;
        u.onend = () => { idx += 1; speakNext(); };
        window.speechSynthesis.speak(u);
      };
      speakNext();
    } catch (e) {}
  }

  btnSpeakTest.addEventListener("click", async () => {
    unlockAudioOnce();
    const hasSynth = ("speechSynthesis" in window);
    const voiceOk = await ensureVoicesReady();
    const v = voiceOk ? pickKoreanVoice() : null;

    const msg =
      !hasSynth ? "ì´ ë¸Œë¼ìš°ì €ëŠ” ìŒì„±ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤."
      : (!voiceOk ? "ìŒì„± ëª©ë¡ ë¡œë”©ì´ ì§€ì—°ë©ë‹ˆë‹¤. ë¬´ìŒëª¨ë“œ í•´ì œì™€ ë³¼ë¥¨ì„ ì˜¬ë¦¬ê³  ë‹¤ì‹œ ëˆŒëŸ¬ì£¼ì„¸ìš”."
      : ("ìŒì„± í…ŒìŠ¤íŠ¸ì…ë‹ˆë‹¤. " + (v ? ("í˜„ì¬ ìŒì„±: " + (v.name || "ì•Œ ìˆ˜ ì—†ìŒ")) : "")));

    speak(msg, true);
  });

  btnReset.addEventListener("click", () => location.reload());
  btnForceSolve.addEventListener("click", async () => {
    unlockAudioOnce();
    await autoSolve("ì‚¬ìš©ì ê°•ì œ í’€ì´(ì§€ë¬¸ ë¶€ì¡± ê°€ëŠ¥)");
  });

  document.addEventListener("click", unlockAudioOnce, { passive: true, once: true });
  document.addEventListener("touchstart", unlockAudioOnce, { passive: true, once: true });

  // =========================
  // â€œAborted(-1)â€ ëŒ€ì‘: OCR ì—”ì§„ ì¬ì´ˆê¸°í™”/ìµœì¢… ìƒˆë¡œê³ ì¹¨
  // =========================
  async function hardResetOcrEngine() {
    try { await speak("OCR ì—”ì§„ì´ ì¤‘ë‹¨ë˜ì–´ ìƒˆë¡œê³ ì¹¨í•©ë‹ˆë‹¤.", true); } catch (e) {}
    setTimeout(() => { location.reload(); }, 600);
  }

  // =========================
  // Timeout helper
  // =========================
  async function withTimeout(promise, ms, label) {
    let timer;
    const timeout = new Promise((_, reject) => {
      timer = setTimeout(() => reject(new Error(label + " timeout")), ms);
    });
    try {
      return await Promise.race([promise, timeout]);
    } finally {
      clearTimeout(timer);
    }
  }

  // =========================
  // ì¹´ë©”ë¼
  // =========================
  async function startCamera() {
    try {
      video.style.transform = `scale(${PREVIEW_SCALE})`;
      setStatus(["ì¹´ë©”ë¼ ìš”ì²­ ì¤‘...", "ê¶Œí•œ íŒì—…ì´ ëœ¨ë©´ 'í—ˆìš©'"]);

      const constraints = {
        video: {
          facingMode: { ideal: "environment" },
          width: { ideal: 3840 },
          height: { ideal: 2160 },
          frameRate: { ideal: 30 }
        },
        audio: false
      };

      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      track = stream.getVideoTracks()[0] || null;

      await new Promise((resolve) => {
        if (video.readyState >= 2) return resolve();
        video.onloadedmetadata = () => resolve();
      });

      await tryApplyZoom(track, REQUESTED_CAMERA_ZOOM);

      setStatus(buildStatusLines("ì¹´ë©”ë¼ ON Â· OCR ì¤€ë¹„"));
      requestAnimationFrame(analyzeLoop);

      const ok = await initOcrWorkerWithRetry();
      if (!ok) {
        setStatus(buildStatusLines("OCR ì—”ì§„ ë¡œë”© ì‹¤íŒ¨. Wi-Fië¡œ ì ‘ì† í›„ ìƒˆë¡œê³ ì¹¨."));
        speak("OCR ì—”ì§„ ë¡œë”©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì™€ì´íŒŒì´ë¡œ ì ‘ì† í›„ ìƒˆë¡œê³ ì¹¨ í•´ì£¼ì„¸ìš”.", true);
        return;
      }

      scheduleOcrLoop();
      setStatus(buildStatusLines("ì¹´ë©”ë¼ ON Â· ìë™ OCR ì‹œì‘"));
    } catch (e) {
      console.error(e);
      setStatus(["ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨", String(e)]);
      speak("ì¹´ë©”ë¼ ì ‘ê·¼ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", true);
    }
  }

  async function tryApplyZoom(track, requested) {
    try {
      if (!track || typeof track.getCapabilities !== "function") { appliedZoomInfo = "zoom cap ì—†ìŒ"; return; }
      const cap = track.getCapabilities();
      if (!cap || typeof cap.zoom === "undefined") { appliedZoomInfo = "zoom ë¯¸ì§€ì›"; return; }
      const minZ = cap.zoom.min, maxZ = cap.zoom.max;
      const target = Math.max(minZ, Math.min(maxZ, requested));
      if (typeof track.applyConstraints === "function") {
        await track.applyConstraints({ advanced: [{ zoom: target }] });
        appliedZoomInfo = `ìš”ì²­ ${requested} â†’ ì ìš© ${target} (cap ${minZ}-${maxZ})`;
      } else {
        appliedZoomInfo = "applyConstraints ì—†ìŒ";
      }
    } catch (e) {
      appliedZoomInfo = "zoom ì ìš© ì‹¤íŒ¨";
    }
  }

  // =========================
  // ê°€ë ¤ì§/ì•ˆì •ë„
  // =========================
  function analyzeFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      return { blocked:false, stable:false };
    }

    bCtx.drawImage(video, 0, 0, BW, BH);
    const img = bCtx.getImageData(0, 0, BW, BH).data;

    const len = BW * BH;
    const currThumb = new Uint8Array(len);

    let sumBright = 0;
    let diffSum = 0;

    for (let i = 0, p = 0; i < img.length; i += 4, p++) {
      const r = img[i], g = img[i+1], b = img[i+2];
      const gray = (r + g + b) / 3;
      currThumb[p] = gray;
      sumBright += gray;
      if (prevThumb) diffSum += Math.abs(gray - prevThumb[p]);
    }

    const avgBright = sumBright / len;
    const diffAvg = prevThumb ? (diffSum / len) : 0;
    prevThumb = currThumb;

    const isBlocked = avgBright < 20;

    const tNow = now();
    let stable = false;
    if (diffAvg < 8) {
      if (!lastStableStart) lastStableStart = tNow;
      if (tNow - lastStableStart >= 900) stable = true;
    } else {
      lastStableStart = 0;
    }

    return { blocked:isBlocked, stable };
  }

  function analyzeLoop() {
    const a = analyzeFrame();
    blocked = a.blocked;
    requestAnimationFrame(analyzeLoop);
  }

  // =========================
  // ìº¡ì²˜
  // =========================
  function captureToCanvas() {
    const vw = video.videoWidth;
    const vh = video.videoHeight;

    if (!vw || !vh) {
      capCanvas.width = 640; capCanvas.height = 360;
      capCtx.fillStyle = "black";
      capCtx.fillRect(0, 0, capCanvas.width, capCanvas.height);
      return capCanvas;
    }

    const cropW = vw;
    const cropH = vh;

    const scale = Math.min(1, CAP_MAX_W / cropW);
    const outW = Math.max(480, Math.floor(cropW * scale));
    const outH = Math.max(360, Math.floor(cropH * scale));

    capCanvas.width = outW;
    capCanvas.height = outH;

    capCtx.imageSmoothingEnabled = false;
    capCtx.drawImage(video, 0, 0, cropW, cropH, 0, 0, outW, outH);
    return capCanvas;
  }

  // =========================
  // OCR Worker init (í•µì‹¬: langPath + timeout + retry)
  // =========================
  async function initOcrWorkerWithRetry() {
    for (let attempt = 1; attempt <= WORKER_RETRY_MAX; attempt++) {
      const ok = await initOcrWorkerOnce(attempt);
      if (ok) return true;
      try { if (worker) await worker.terminate(); } catch (e) {}
      worker = null;
      workerReady = false;
    }
    return false;
  }

  async function initOcrWorkerOnce(attempt) {
    try {
      setStatus(buildStatusLines(`OCR ì—”ì§„ ë¡œë”© ì¤‘... (ì‹œë„ ${attempt}/${WORKER_RETRY_MAX})`));

      worker = await Tesseract.createWorker({
        langPath: LANG_PATH,
        logger: (m) => {
          if (!m || !m.status) return;
          const p = (typeof m.progress === "number") ? Math.round(m.progress * 100) : null;
          if (p !== null) setStatus(buildStatusLines(`OCR ì—”ì§„ ë¡œë”© ì¤‘... [${m.status}] ${p}%`));
          else setStatus(buildStatusLines(`OCR ì—”ì§„ ë¡œë”© ì¤‘... [${m.status}]`));
        }
      });

      await withTimeout(worker.loadLanguage(OCR_LANG), WORKER_INIT_TIMEOUT_MS, "loadLanguage");
      await withTimeout(worker.initialize(OCR_LANG), WORKER_INIT_TIMEOUT_MS, "initialize");

      // ìˆ«ì/ê¸°í˜¸ë¥¼ OCR ë‹¨ê³„ì—ì„œ ëœ ë³´ì´ê²Œ (ìµœì¢… ì œê±°ëŠ” cleanOcrTextì—ì„œ)
      await worker.setParameters({
        tessedit_char_blacklist: "0123456789~`!@#$%^&*()-_=+[]{}\\|;:'\",.<>/?Â·â€¢â€»â„ƒâ„‰Â©Â®â„¢"
      });

      workerReady = true;
      setStatus(buildStatusLines("OCR ì—”ì§„ ì¤€ë¹„ ì™„ë£Œ"));
      return true;

    } catch (e) {
      console.error(e);
      setStatus(buildStatusLines("OCR ì—”ì§„ ë¡œë”© ì‹¤íŒ¨: " + String(e)));
      return false;
    }
  }

  // =========================
  // OCR ë£¨í”„
  // =========================
  function shouldTryOcr() {
    if (solved || solving) return false;
    if (ocrRunning) return false;
    if (!workerReady) return false;
    if (blocked) return false;
    const tNow = now();
    if (tNow - lastOcrAt < OCR_INTERVAL_MS) return false;
    return true;
  }

  async function doOcrOnce() {
    if (!shouldTryOcr()) return;

    ocrRunning = true;
    lastOcrAt = now();

    try {
      const canvas = captureToCanvas();
      setStatus(buildStatusLines("OCR ì§„í–‰ ì¤‘..."));

      const result = await worker.recognize(canvas);

      const rawText = (result && result.data && result.data.text) ? result.data.text : "";
      const conf = (result && result.data && typeof result.data.confidence === "number")
        ? result.data.confidence
        : 0;

      const text = cleanOcrText(rawText);
      const effLen = effectiveLenOf(text);

      if (effLen < 30 || conf < 5) {
        setStatus(buildStatusLines("OCR ì™„ë£Œ(ë„ˆë¬´ ì§§ìŒ/ë‚®ì€ ì‹ ë¢°ë„)"));
        return;
      }

      // ê±°ë¦¬ ì¶”ì •(íœ´ë¦¬ìŠ¤í‹±)
      tooFar = (effLen < 450 && conf < 35);
      tooNear = (effLen >= 900 && conf < 35);

      updateSegments(text, effLen, conf);
      updateCumulative();

      // ë¶€ì¡± íƒ€ì´ë¨¸
      const tNow = now();
      if (cumulativeEffLen < TEXT_THRESHOLD_EFFECTIVE) {
        if (!insufficientSince) insufficientSince = tNow;
      } else {
        insufficientSince = null;
      }

      ocrPreviewEl.value = cumulativeText;
      setStatus(buildStatusLines("OCR ì™„ë£Œ"));

      // ìë™ í’€ì´ ì¡°ê±´
      if (!solved && !solving) {
        const enough = cumulativeEffLen >= TEXT_THRESHOLD_EFFECTIVE;
        const noNewFor = lastNewSegmentAt ? (tNow - lastNewSegmentAt) : 0;
        const insufficientDuration = insufficientSince ? (tNow - insufficientSince) : 0;

        if (insufficientSince && insufficientDuration >= INSUFFICIENT_WARN_MS && insufficientDuration < MAX_WAIT_MS) {
          speak(buildInsufficientReason(), false);
        }

        if (enough && noNewFor >= NO_NEW_SEGMENT_SOLVE_MS) {
          await autoSolve("ëˆ„ì  ì¶©ë¶„ + ë³€í™” ì—†ìŒ");
          return;
        }

        if (insufficientSince && insufficientDuration >= MAX_WAIT_MS) {
          await autoSolve("ìµœëŒ€ ëŒ€ê¸°ì‹œê°„ ì´ˆê³¼(ì§€ë¬¸ ë¶€ì¡±). í˜„ì¬ ëˆ„ì  ë‚´ìš©ìœ¼ë¡œ í’€ì´");
          return;
        }
      }

      ocrFailCount = 0;

    } catch (e) {
      console.error(e);
      const msg = String(e || "");
      setStatus(buildStatusLines("OCR ì—ëŸ¬: " + msg));

      // iOSì—ì„œ ì¢…ì¢… ëœ¨ëŠ” â€œRuntimeError: Aborted(-1)â€ ê³„ì—´ ëŒ€ì‘
      if (msg.includes("Aborted") || msg.includes("RuntimeError")) {
        ocrFailCount += 1;
        workerReady = false;
        try { if (worker) await worker.terminate(); } catch (x) {}
        worker = null;

        if (ocrFailCount >= 2) {
          await hardResetOcrEngine();
          return;
        } else {
          const ok = await initOcrWorkerWithRetry();
          if (!ok) return;
        }
      }
    } finally {
      ocrRunning = false;
    }
  }

  function updateSegments(text, effLen, conf) {
    const sig = signatureOf(text);

    let bestIdx = -1;
    let bestSim = 0;

    for (let i = 0; i < segments.length; i++) {
      const s = segments[i];
      const sim = similarity(sig, s.sig);
      if (sim > bestSim) { bestSim = sim; bestIdx = i; }
    }

    const SAME_PAGE_SIM = 0.62;

    if (bestIdx >= 0 && bestSim >= SAME_PAGE_SIM) {
      const prev = segments[bestIdx];
      const merged = mergeLinewise(prev.text, text, prev.conf, conf);
      const mergedEff = effectiveLenOf(merged);

      const better =
        (mergedEff > prev.effLen + 30) ||
        (Math.abs(mergedEff - prev.effLen) <= 30 && conf > prev.conf + 3);

      if (better) {
        segments[bestIdx] = {
          text: merged,
          effLen: mergedEff,
          conf: Math.max(prev.conf, conf),
          updatedAt: now(),
          sig: signatureOf(merged)
        };
      } else {
        segments[bestIdx].updatedAt = now();
      }
      return;
    }

    segments.push({ text, effLen, conf, updatedAt: now(), sig });
    lastNewSegmentAt = now();
  }

  function updateCumulative() {
    let out = "";
    let totalEff = 0;
    let confSum = 0;

    for (let i = 0; i < segments.length; i++) {
      const s = segments[i];
      if (i > 0) out += "\n\n----------\n\n";
      out += s.text;
      totalEff += s.effLen;
      confSum += s.conf;
    }

    cumulativeText = out.trim();
    cumulativeEffLen = totalEff;
    cumulativeAvgConf = segments.length ? (confSum / segments.length) : 0;
  }

  function buildInsufficientReason() {
    if (blocked) return "ì¹´ë©”ë¼ê°€ ê°€ë ¤ì¡ŒìŠµë‹ˆë‹¤. ë Œì¦ˆë¥¼ ê°€ë¦¬ì§€ ì•Šê²Œ í•´ì£¼ì„¸ìš”.";
    if (tooFar) return "ì§€ë¬¸ì´ ë„ˆë¬´ ë©€ì–´ ë³´ì…ë‹ˆë‹¤. ì¢…ì´ë¥¼ í™”ë©´ì— ë” í¬ê²Œ ì±„ì›Œì£¼ì„¸ìš”.";
    if (tooNear) return "ì§€ë¬¸ì´ ë„ˆë¬´ ê°€ê¹Œì›Œ ë³´ì…ë‹ˆë‹¤. ì¡°ê¸ˆë§Œ ë©€ë¦¬ ë‘ê³  ë‹¤ì‹œ ë¹„ì¶°ì£¼ì„¸ìš”.";
    return "ì•„ì§ ì§€ë¬¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ì²« ì œì‹œë¬¸ë¶€í„° ë§ˆì§€ë§‰ ì§ˆë¬¸ê¹Œì§€ ì²œì²œíˆ ë¹„ì¶°ì£¼ì„¸ìš”.";
  }

  function buildStatusLines(extraLine) {
    const lines = [];
    lines.push("ìë™ OCR(ëˆ„ì ) â†’ ìë™ í’€ì´");
    lines.push(`í”„ë¦¬ë·° ë°°ìœ¨: ${PREVIEW_SCALE} | ì¹´ë©”ë¼ zoom: ${appliedZoomInfo}`);
    lines.push(`ì¹´ë©”ë¼ ìƒíƒœ: ${blocked ? "ê°€ë ¤ì§" : "ì •ìƒ"}`);

    let dist = "ì •ìƒ(ì¶”ì •)";
    if (tooFar) dist = "ë„ˆë¬´ ë©‚(ì¶”ì •)";
    else if (tooNear) dist = "ë„ˆë¬´ ê°€ê¹Œì›€(ì¶”ì •)";
    lines.push(`ê±°ë¦¬ ìƒíƒœ: ${dist}`);

    lines.push(`ì„¸ê·¸ë¨¼íŠ¸(í˜ì´ì§€ ì¶”ì •) ìˆ˜: ${segments.length}`);
    lines.push(`ëˆ„ì  OCR ê¸¸ì´(ê³µë°±ì œì™¸): ${cumulativeEffLen} / ê¸°ì¤€ ${TEXT_THRESHOLD_EFFECTIVE}`);
    lines.push(`í‰ê·  OCR ì‹ ë¢°ë„(ëŒ€ëµ): ${cumulativeAvgConf.toFixed(1)}%`);

    if (insufficientSince && cumulativeEffLen < TEXT_THRESHOLD_EFFECTIVE) {
      const sec = Math.floor((now() - insufficientSince) / 1000);
      lines.push(`ì§€ë¬¸ ë¶€ì¡± ì§€ì†: ${sec}ì´ˆ (1ë¶„ ì•ˆë‚´, 8ë¶„ì´ë©´ ìë™ í’€ì´)`);
    } else {
      lines.push("ì§€ë¬¸ ë¶€ì¡± ì§€ì†: 0ì´ˆ");
    }

    const synthOk = ("speechSynthesis" in window) ? "ì§€ì›" : "ë¯¸ì§€ì›";
    lines.push(`ìŒì„±(TTS): ${synthOk} | ì–¸ë½: ${audioUnlocked ? "ì™„ë£Œ" : "ëŒ€ê¸°(ë²„íŠ¼ íƒ­)"}`);

    if (extraLine) lines.push(String(extraLine));
    return lines;
  }

  // =========================
  // ìë™ í’€ì´ (ë‹µì•ˆ + ë‹µì•ˆ TTS)
  // =========================
  async function autoSolve(reason) {
    if (solved || solving) return;
    solving = true;

    unlockAudioOnce();

    const payloadText = (cumulativeText || "").trim();
    if (!payloadText) {
      answerBoxEl.textContent = "ëˆ„ì  OCR í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.";
      solving = false;
      return;
    }

    setStatus(buildStatusLines(`í’€ì´ ìš”ì²­ ì¤‘... (${reason})`));
    answerBoxEl.textContent = "í’€ì´ ìƒì„± ì¤‘...";

    const body = JSON.stringify({ ocrText: payloadText });

    try {
      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();

      let out = "";
      if (ct.includes("application/json")) {
        let data;
        try { data = await res.json(); }
        catch (e) { out = "JSON íŒŒì‹± ì—ëŸ¬: " + String(e); }

        if (!out) {
          if (data && typeof data.answer === "string") out = data.answer;
          else if (data && typeof data.raw === "string") out = data.raw;
          else if (data && typeof data.error === "string") out = "ì—ëŸ¬: " + data.error;
          else out = JSON.stringify(data);
        }
      } else {
        out = await res.text();
      }

      if (!res.ok) {
        answerBoxEl.textContent = `ì„œë²„ ì—ëŸ¬ (status ${res.status})\n\n${out.slice(0, 4000)}`;
        speak("ì„œë²„ ì—ëŸ¬ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.", true);
        solving = false;
        return;
      }

      solved = true;

      const isInsufficientSolve =
        (reason || "").includes("ìµœëŒ€ ëŒ€ê¸°ì‹œê°„") ||
        (reason || "").includes("ì§€ë¬¸ ë¶€ì¡±") ||
        (reason || "").includes("ê°•ì œ í’€ì´");

      const prefix = isInsufficientSolve
        ? "ì§€ë¬¸ì´ ë¶€ì¡±í•˜ì—¬ í˜„ì¬ê¹Œì§€ ì¸ì‹ëœ ë‚´ìš©ìœ¼ë¡œ ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.\n\n"
        : "";

      answerBoxEl.textContent = prefix + out;
      setStatus(buildStatusLines("í’€ì´ ì™„ë£Œ"));

      if (isInsufficientSolve) {
        speak("ì§€ë¬¸ì´ ë¶€ì¡±í•˜ì—¬ í˜„ì¬ê¹Œì§€ ì¸ì‹ëœ ë‚´ìš©ìœ¼ë¡œ ìë™ í’€ì´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.", true);
      } else {
        speak("ë‹µì•ˆì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.", true);
      }

      // âœ… ë‹µì•ˆë„ ìŒì„±ìœ¼ë¡œ ë‚­ë…
      speakLong(prefix + out);

    } catch (e) {
      console.error(e);
      answerBoxEl.textContent = "ìš”ì²­ ì‹¤íŒ¨: " + String(e);
      speak("ìš”ì²­ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.", true);
    } finally {
      solving = false;
    }
  }

  // =========================
  // OCR ë£¨í”„
  // =========================
  function scheduleOcrLoop() {
    doOcrOnce();
    setInterval(() => { doOcrOnce(); }, OCR_INTERVAL_MS);
  }

  // =========================
  // ì‹œì‘
  // =========================
  startCamera();
})();
</script>
</body>
</html>



