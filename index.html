<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 16px; }
    #status { white-space: pre-wrap; padding: 10px; border: 1px solid #ddd; border-radius: 8px; min-height: 96px; }
    button { padding: 12px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; font-size: 16px; }
    button:disabled { opacity: 0.5; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    textarea { width: 100%; min-height: 140px; margin-top: 10px; }
    .small { font-size: 12px; color: #666; line-height: 1.45; }

    .camWrap { width: 100%; max-width: 520px; }
    video { width: 100%; border-radius: 12px; background: #000; display:block; }
  </style>
</head>
<body>
  <h2>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</h2>

  <div id="status">ëŒ€ê¸° ì¤‘</div>

  <div class="row" style="margin:12px 0;">
    <button id="btnAudio">ğŸ”Š ì˜¤ë””ì˜¤ ì¤€ë¹„(í•œ ë²ˆë§Œ)</button>
    <button id="btnStart">ğŸ“¸ ìë™ ì‹œì‘</button>
    <button id="btnStop" disabled>â›” ì¤‘ì§€</button>
    <button id="btnReplay" disabled>ğŸ” ì •ë‹µ ë‹¤ì‹œë“£ê¸°</button>
  </div>

  <div class="small">
    - ë§ˆì§€ë§‰ í˜ì´ì§€ì— <b>XVRTH</b> ë¥¼ êµµê³  í¬ê²Œ ì ìœ¼ë©´ ìë™ìœ¼ë¡œ OCR ì¢…ë£Œ í›„ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br/>
    - iOS ë¬´ìŒëª¨ë“œ(ì‚¬ì¼ëŸ°íŠ¸)ë©´ TTSê°€ ì•ˆ ë“¤ë¦´ ìˆ˜ ìˆë‹¤. ë¬´ìŒ í•´ì œ + ë³¼ë¥¨ ì˜¬ë ¤ë¼.<br/>
    - ì¢…ì´ê°€ í™”ë©´ì—ì„œ ë„ˆë¬´ ì‘ê²Œ ì¡íˆë©´ ìë™ìœ¼ë¡œ â€œê°€ê¹Œì´â€ ì˜¤ë¼ê³  ë§í•œë‹¤(ì™„ì „ ìë™).
  </div>

  <div style="margin-top:12px;">
    <div class="camWrap">
      <video id="video" autoplay playsinline muted></video>
    </div>
  </div>

  <h3 style="margin-top:16px;">OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸)</h3>
  <textarea id="ocrBox" placeholder="ìë™ OCR ê²°ê³¼ê°€ ëˆ„ì ëœë‹¤(ìˆ˜ë™ ìˆ˜ì • ê¸ˆì§€)."></textarea>

  <h3 style="margin-top:16px;">ì •ë‹µ(ë””ë²„ê·¸)</h3>
  <textarea id="ansBox" placeholder="ìë™ í’€ì´ ê²°ê³¼ê°€ ì—¬ê¸°ì— ì¶œë ¥ëœë‹¤."></textarea>

<script>
(() => {
  const OCR_URL   = "/.netlify/functions/ocr";
  const SOLVE_URL = "/.netlify/functions/solve";

  // ì´¬ì˜/ì¸ì‹ ì„¤ì •
  const SHOTS_PER_PAGE = 3;
  const SHOT_GAP_MS = 120;              // 5ì´ˆ ëŒ€ê¸° ì‚­ì œ
  const MAX_PAGES = 30;
  const MAX_RETRY_PER_PAGE = 4;

  // í˜ì´ì§€ ë„˜ê¹€ ì•ˆë‚´ í›„ ë‹¤ìŒ ì´¬ì˜ê¹Œì§€ ëŒ€ê¸°
  const TURN_PAGE_WAIT_MS = 650;

  // OCR í’ˆì§ˆ ê¸°ì¤€
  const MIN_TEXT_LEN = 650;
  const MIN_QNUM_HITS = 2;
  const PASSAGE_LEN_OK = 1250;

  // â€œì¢…ì´ ë„ˆë¬´ ì‘ìŒâ€ ê¸°ì¤€(í”„ë ˆì„ ëŒ€ë¹„ ì¢…ì´ ë°”ìš´ë”©ë°•ìŠ¤ ë©´ì )
  const MIN_PAPER_AREA_RATIO = 0.20; // A4 ì—°ìŠµ ê¸°ì¤€: 20% ë¯¸ë§Œì´ë©´ ë„ˆë¬´ ë©€ë‹¤

  // ì¢…ë£Œ ê°ì§€
  const STOP_PHRASE = "XVRTH";

  // ì •ë‹µ TTS
  const ANSWER_ROUNDS = 4;
  const BETWEEN_ANS_MS = 2000;          // ë¬¸í•­ ì‚¬ì´ 2ì´ˆ
  const BETWEEN_ROUND_MS = 600;

  let running = false;
  let stream = null;

  let currentPage = 1;
  let pages = []; // {page, text, conf, qnums:Set<number>}
  let allText = "";

  let koVoice = null;
  let audioReady = false;
  let lastAnswers = null;

  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnAudio = document.getElementById("btnAudio");
  const btnStart = document.getElementById("btnStart");
  const btnStop = document.getElementById("btnStop");
  const btnReplay = document.getElementById("btnReplay");
  const ocrBox = document.getElementById("ocrBox");
  const ansBox = document.getElementById("ansBox");

  btnStart.disabled = false;
  btnStop.disabled = true;
  btnReplay.disabled = true;

  function log(msg) {
    const t = new Date().toLocaleTimeString("ko-KR", { hour12:false });
    statusEl.textContent = `[${t}] ${msg}\n` + statusEl.textContent;
    console.log(msg);
  }
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // ---------- iOS ì˜¤ë””ì˜¤ ì–¸ë½ ----------
  async function beep() {
    try {
      const AC = window.AudioContext || window.webkitAudioContext;
      if (!AC) return;
      const ctx = new AC();
      await ctx.resume().catch(()=>{});
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = 880;
      gain.gain.value = 0.08;
      osc.connect(gain);
      gain.connect(ctx.destination);
      osc.start();
      osc.stop(ctx.currentTime + 0.08);
    } catch (_) {}
  }

  async function unlockAudio() {
    if (audioReady) return true;
    try { speechSynthesis.getVoices(); } catch (_) {}
    await beep();
    audioReady = true;
    log("AudioContext ì–¸ë½ ì™„ë£Œ");
    return true;
  }

  // ---------- TTS ----------
  function pickKoreanVoice() {
    const voices = speechSynthesis.getVoices() || [];
    const ko = voices.filter(v => (v.lang || "").toLowerCase().startsWith("ko"));
    const preferred = ko.find(v => /yuna|ìœ ë‚˜|ì„œí˜„|ì§€ì€|ì•„ë¦¬/i.test(v.name));
    koVoice = preferred || ko[0] || null;
    if (koVoice) log(`TTS voice: ${koVoice.name} (${koVoice.lang})`);
    else log("TTS voice ì„ íƒ ì‹¤íŒ¨");
  }

  function speak(text) {
    return new Promise(resolve => {
      try {
        const u = new SpeechSynthesisUtterance(String(text));
        u.lang = "ko-KR";
        u.rate = 1.0;
        if (koVoice) u.voice = koVoice;
        u.onend = resolve;
        u.onerror = resolve;
        speechSynthesis.speak(u);
      } catch (_) { resolve(); }
    });
  }

  async function speakTurnPage(page) {
    await speak(`í˜ì´ì§€ ${page} ì¸ì‹ ì™„ë£Œ. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë„˜ê²¨ ì£¼ì„¸ìš”.`);
    await sleep(TURN_PAGE_WAIT_MS);
  }

  async function speakAnswers(answerNumMap) {
    const toLetter = (n)=>["A","B","C","D","E"][Number(n)-1] || "";
    const keys = Object.keys(answerNumMap).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);

    try { speechSynthesis.cancel(); } catch (_) {}

    for (let r=1; r<=ANSWER_ROUNDS; r++) {
      for (const q of keys) {
        const a = toLetter(answerNumMap[String(q)]);
        if (!a) continue;
        await speak(`${q}ë²ˆ ${a}`);
        await sleep(BETWEEN_ANS_MS);
      }
      await sleep(BETWEEN_ROUND_MS);
    }
  }

  // ---------- Camera (ì¤Œ ê°•ì œ ì—†ìŒ) ----------
  async function getStreamWithFallback() {
    const tries = [
      { video: { facingMode: { ideal: "environment" }, width:{ ideal:1920 }, height:{ ideal:1080 } }, audio:false },
      { video: { facingMode: "environment" }, audio:false },
      { video: true, audio:false }
    ];
    let lastErr = null;
    for (const c of tries) {
      try { return await navigator.mediaDevices.getUserMedia(c); }
      catch (e) { lastErr = e; }
    }
    throw lastErr || new Error("getUserMedia failed");
  }

  async function applyBestCameraSettings() {
    try {
      const track = stream?.getVideoTracks?.()[0];
      if (!track || !track.getCapabilities || !track.applyConstraints) return;

      const caps = track.getCapabilities();
      const adv = [];

      // âœ… ì¤Œ: ì˜¬ë¦¬ì§€ ì•ŠìŒ. í˜¹ì‹œ ë‚¨ì•„ìˆì„ê¹Œë´ ìµœì†Œê°’ ë¦¬ì…‹ë§Œ.
      if (caps.zoom) {
        adv.push({ zoom: caps.zoom.min });
        log(`ì¤Œ ë¦¬ì…‹: ${caps.zoom.min}`);
      }
      if (caps.focusMode && Array.isArray(caps.focusMode) && caps.focusMode.includes("continuous")) {
        adv.push({ focusMode: "continuous" });
      }
      if (caps.exposureMode && Array.isArray(caps.exposureMode) && caps.exposureMode.includes("continuous")) {
        adv.push({ exposureMode: "continuous" });
      }
      if (caps.whiteBalanceMode && Array.isArray(caps.whiteBalanceMode) && caps.whiteBalanceMode.includes("continuous")) {
        adv.push({ whiteBalanceMode: "continuous" });
      }

      if (adv.length > 0) {
        await track.applyConstraints({ advanced: adv }).catch(()=>{});
      }
    } catch (_) {}
  }

  async function startCamera() {
    if (stream) return;
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      throw new Error("ì´ ë¸Œë¼ìš°ì €ëŠ” ì¹´ë©”ë¼ APIë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŒ");
    }

    stream = await getStreamWithFallback();
    video.srcObject = stream;

    try { await video.play(); } catch (_) {}

    const t0 = Date.now();
    while (video.readyState < 2 && Date.now() - t0 < 1500) {
      await sleep(50);
    }

    await applyBestCameraSettings();
    await sleep(200);

    log(`ì¹´ë©”ë¼ OK (${video.videoWidth}x${video.videoHeight})`);
  }

  // ---------- AUTO PAPER DETECT + CROP ----------
  // ì „ëµ: ë‹¤ìš´ìŠ¤ì¼€ì¼ â†’ ë°ì€ í”½ì…€ ë§ˆìŠ¤í¬(white paper) â†’ ë°”ìš´ë”© ë°•ìŠ¤ â†’ ì›ë³¸ ì¢Œí‘œë¡œ í™•ì¥ í¬ë¡­
  function detectPaperBoxOnFrame(srcCanvas) {
    const w = srcCanvas.width, h = srcCanvas.height;

    // ë„ˆë¬´ í° í•´ìƒë„ì—ì„œ ë¶„ì„í•˜ë©´ ëŠë¦¼ â†’ ë¶„ì„ìš© ë‹¤ìš´ìŠ¤ì¼€ì¼
    const targetW = 320;
    const scale = targetW / w;
    const dw = targetW;
    const dh = Math.max(1, Math.round(h * scale));

    const dcv = document.createElement("canvas");
    dcv.width = dw; dcv.height = dh;
    const dctx = dcv.getContext("2d", { willReadFrequently:true });
    dctx.drawImage(srcCanvas, 0, 0, w, h, 0, 0, dw, dh);

    const img = dctx.getImageData(0, 0, dw, dh);
    const data = img.data;

    // ë°ê¸° íˆìŠ¤í† ê·¸ë¨(ê°„ë‹¨)ìœ¼ë¡œ ì„ê³„ê°’ ê²°ì •(ê³ ì •+ë³´ì •)
    // ì¢…ì´ëŠ” ëŒ€ì²´ë¡œ ë§¤ìš° ë°ìŒ â†’ 0~255 ì¤‘ ìƒë‹¨ êµ¬ê°„ ì¡ê¸°
    // ì‹¤íŒ¨ë¥¼ ì¤„ì´ë ¤ê³  "í‰ê·  ë°ê¸°"ë¥¼ ë³´ê³  thresholdë¥¼ ì•½ê°„ ì¡°ì •
    let sum = 0;
    const n = dw * dh;
    for (let i=0; i<data.length; i+=4) {
      const r = data[i], g = data[i+1], b = data[i+2];
      const y = (r*0.2126 + g*0.7152 + b*0.0722);
      sum += y;
    }
    const mean = sum / n;
    let thr = Math.max(200, Math.min(235, mean + 25)); // í‰ê· +25, ìµœì†Œ 200

    let minX = dw, minY = dh, maxX = -1, maxY = -1;
    let hit = 0;

    for (let y=0; y<dh; y++) {
      for (let x=0; x<dw; x++) {
        const idx = (y*dw + x) * 4;
        const r = data[idx], g = data[idx+1], b = data[idx+2];
        const lum = (r*0.2126 + g*0.7152 + b*0.0722);

        // í° ì¢…ì´ í›„ë³´: ë°ê³ , ìƒ‰í¸ì°¨ ì‘ìŒ(íšŒìƒ‰/í°ìƒ‰)
        const maxc = Math.max(r,g,b), minc = Math.min(r,g,b);
        const chroma = maxc - minc;

        if (lum >= thr && chroma < 35) {
          hit++;
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }
      }
    }

    if (hit < n * 0.01 || maxX < 0) {
      return null; // ì¢…ì´ ëª» ì°¾ìŒ
    }

    // ë°”ìš´ë”©ë°•ìŠ¤ ë„ˆë¬´ ì–‡ê±°ë‚˜ ì´ìƒí•˜ë©´ null
    const bw = (maxX - minX + 1);
    const bh = (maxY - minY + 1);
    if (bw < dw * 0.25 || bh < dh * 0.25) {
      // ì¢…ì´ê°€ ë„ˆë¬´ ì‘ê±°ë‚˜ ì¼ë¶€ë§Œ ì¡í˜
      return { box: null, areaRatio: (bw*bh)/(dw*dh) };
    }

    // ë§ˆì§„(ë°”ìš´ë”©ë°•ìŠ¤ í™•ì¥)
    const mx = Math.round(bw * 0.06);
    const my = Math.round(bh * 0.06);

    let x0 = Math.max(0, minX - mx);
    let y0 = Math.max(0, minY - my);
    let x1 = Math.min(dw-1, maxX + mx);
    let y1 = Math.min(dh-1, maxY + my);

    // ì›ë³¸ ì¢Œí‘œë¡œ í™˜ì‚°
    const rx = Math.floor(x0 / scale);
    const ry = Math.floor(y0 / scale);
    const rw = Math.floor((x1 - x0 + 1) / scale);
    const rh = Math.floor((y1 - y0 + 1) / scale);

    const areaRatio = (bw*bh) / (dw*dh);
    return { box: { x: rx, y: ry, w: rw, h: rh }, areaRatio };
  }

  function captureAutoPaperCropBase64Jpeg(quality=0.92) {
    const w = video.videoWidth, h = video.videoHeight;
    if (!w || !h) throw new Error("ì¹´ë©”ë¼ í”„ë ˆì„ í¬ê¸° 0(ìŠ¤íŠ¸ë¦¼ ì¤€ë¹„ ì•ˆ ë¨)");

    const src = document.createElement("canvas");
    src.width = w; src.height = h;
    const sctx = src.getContext("2d");
    sctx.drawImage(video, 0, 0, w, h);

    const det = detectPaperBoxOnFrame(src);

    // í´ë°±: ì¢…ì´ ëª»ì°¾ìœ¼ë©´ ì „ì²´ í”„ë ˆì„ì„ ê·¸ëŒ€ë¡œ ë³´ëƒ„(ë‹¤ë§Œ í’ˆì§ˆì ìˆ˜ ë‚®ê²Œ ì²˜ë¦¬)
    if (!det || !det.box) {
      return { dataUrl: src.toDataURL("image/jpeg", quality), areaRatio: det?.areaRatio ?? 0 };
    }

    const { x, y, w:rw, h:rh } = det.box;

    // ì•ˆì „ clamp
    const cx = Math.max(0, Math.min(w-1, x));
    const cy = Math.max(0, Math.min(h-1, y));
    const cw = Math.max(1, Math.min(w - cx, rw));
    const ch = Math.max(1, Math.min(h - cy, rh));

    const crop = document.createElement("canvas");
    crop.width = cw;
    crop.height = ch;
    const cctx = crop.getContext("2d");
    cctx.drawImage(src, cx, cy, cw, ch, 0, 0, cw, ch);

    return { dataUrl: crop.toDataURL("image/jpeg", quality), areaRatio: det.areaRatio };
  }

  // ---------- OCR ----------
  async function callOcr(dataUrl, pageIndex) {
    const payload = { image: dataUrl, pageIndex, mode: "dual" };
    const res = await fetch(OCR_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    const j = await res.json().catch(()=>null);
    if (!j || !j.ok) return { ok:false, text:"", conf:0 };
    return { ok:true, text:String(j.text||""), conf:Number(j.conf||0) };
  }

  const normalizeNoSpace = (s)=>String(s||"").replace(/\s+/g,"").trim();
  function detectStop(text) {
    const t = normalizeNoSpace(text);
    return t.includes(normalizeNoSpace(STOP_PHRASE));
  }

  function qnumHits(text) {
    const m = String(text||"").match(/(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g);
    return m ? m.length : 0;
  }

  function extractQnumsFromPage(text) {
    const out = new Set();
    const re = /(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g;
    let m;
    const t = String(text||"");
    while ((m = re.exec(t)) !== null) out.add(parseInt(m[1],10));
    return out;
  }

  function qualityOk(text) {
    const len = String(text||"").length;
    const hits = qnumHits(text);
    if (len >= PASSAGE_LEN_OK) return true;
    if (len >= MIN_TEXT_LEN && hits >= MIN_QNUM_HITS) return true;
    return false;
  }

  async function ocrOnePage(pageIndex) {
    let best = null;

    for (let shot=1; shot<=SHOTS_PER_PAGE; shot++) {
      if (!running) return null;
      await sleep(SHOT_GAP_MS);

      const cap = captureAutoPaperCropBase64Jpeg(0.92);
      const r = await callOcr(cap.dataUrl, pageIndex);

      const text = r.ok ? r.text : "";
      const conf = r.ok ? r.conf : 0;
      const hits = qnumHits(text);

      // ì¢…ì´ ë©´ì ì´ ì‘ìœ¼ë©´ ì ìˆ˜ ê¹ì•„ì„œ â€œê°€ê¹Œì´â€ ìœ ë„
      const area = cap.areaRatio || 0;
      const areaPenalty = (area > 0 && area < MIN_PAPER_AREA_RATIO) ? -80 : 0;

      const score = (text.length/50) + (hits*30) + (conf*2) + areaPenalty;

      log(`OCR ${r.ok?"OK":"FAIL"} page=${pageIndex} shot=${shot} len=${text.length} conf=${conf} hits=${hits} paperArea=${(area*100).toFixed(1)}% score=${score.toFixed(1)}`);

      const cand = { shot, text, conf, score, stop: detectStop(text), areaRatio: area };
      if (!best || cand.score > best.score) best = cand;

      if (cand.stop) return cand;
    }

    if (!best) return null;
    best.stop = detectStop(best.text);
    return best;
  }

  function rebuildAllText() {
    allText = "";
    for (const p of pages) {
      allText += `[PAGE ${p.page}] (conf=${(p.conf||0).toFixed(1)})\n${p.text}\n\n`;
    }
    ocrBox.value = allText;
  }

  async function recaptureSpecificPages(targetPages) {
    for (const p of targetPages) {
      if (!running) return;
      await speak(`ë¬¸ì œê°€ ìˆëŠ” í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤. í˜ì´ì§€ ${p}ë¥¼ ë” ê°€ê¹Œì´ ë³´ì—¬ ì£¼ì„¸ìš”.`);
      await sleep(250);

      let ok = false;
      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) return;

        log(`ì¬ì´¬ì˜: í˜ì´ì§€ ${p} ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        const r = await ocrOnePage(p);
        if (!r) break;

        // ì¢…ì´ ë„ˆë¬´ ì‘ìœ¼ë©´ ì¦‰ì‹œ ì•ˆë‚´
        if (r.areaRatio > 0 && r.areaRatio < MIN_PAPER_AREA_RATIO) {
          await speak(`í˜ì´ì§€ ${p}ê°€ ë„ˆë¬´ ì‘ê²Œ ë³´ì…ë‹ˆë‹¤. íœ´ëŒ€í°ì„ ë” ê°€ê¹Œì´ ê°€ì ¸ì˜¤ì„¸ìš”.`);
          continue;
        }

        if (r.stop || qualityOk(r.text)) {
          const idx = pages.findIndex(x => x.page === p);
          const qnums = extractQnumsFromPage(r.text);
          const entry = { page:p, text:r.text, conf:r.conf, qnums };
          if (idx >= 0) pages[idx] = entry; else pages.push(entry);
          pages.sort((a,b)=>a.page-b.page);
          rebuildAllText();
          ok = true;
          break;
        }

        await speak(`ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. í˜ì´ì§€ ${p}ë¥¼ ì¡°ê¸ˆ ë” ê°€ê¹Œì´ ë³´ì—¬ ì£¼ì„¸ìš”.`);
      }

      if (!ok) {
        await speak(`í˜ì´ì§€ ${p}ê°€ ê³„ì† ì•ˆ ì½í™ë‹ˆë‹¤. ì¡°ëª… ë°˜ì‚¬ë¥¼ ì—†ì• ê³  ê°ë„ë¥¼ ë°”ê¿” ì£¼ì„¸ìš”.`);
        throw new Error(`ì¬ì´¬ì˜ ì‹¤íŒ¨(page=${p})`);
      }
    }
  }

  // ---------- Solve ----------
  async function callSolve(allText) {
    const res = await fetch(SOLVE_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ text: allText })
    });
    const j = await res.json().catch(()=>null);
    if (!j) return { ok:false, error:"Solve JSON parse failed" };
    return j;
  }

  function answersToText(ansNumMap) {
    const toLetter = (n)=>["A","B","C","D","E"][Number(n)-1] || "";
    const keys = Object.keys(ansNumMap||{}).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);
    return keys.map(k => `${k}ë²ˆ: ${toLetter(ansNumMap[String(k)])}`).join("\n");
  }

  function mapBadQuestionsToPages(badQs) {
    const pagesSet = new Set();
    for (const q of badQs) {
      for (const p of pages) {
        if (p.qnums && p.qnums.has(q)) pagesSet.add(p.page);
      }
    }
    return Array.from(pagesSet).sort((a,b)=>a-b);
  }

  // ---------- Main ----------
  async function runAuto() {
    running = true;
    btnStart.disabled = true;
    btnStop.disabled = false;
    btnReplay.disabled = true;

    pages = [];
    allText = "";
    currentPage = 1;
    ocrBox.value = "";
    ansBox.value = "";
    lastAnswers = null;

    await unlockAudio();
    pickKoreanVoice();

    await startCamera();
    await speak("ìë™ ì´¬ì˜ì„ ì‹œì‘í•©ë‹ˆë‹¤.");

    while (running && currentPage <= MAX_PAGES) {
      let okPage = false;
      let last = null;

      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) break;

        log(`í˜ì´ì§€ ${currentPage} OCR ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        last = await ocrOnePage(currentPage);
        if (!last) break;

        // ì¢…ì´ê°€ ë„ˆë¬´ ì‘ê²Œ ë³´ì´ë©´ ì¦‰ì‹œ ìŒì„± ì•ˆë‚´(ë°•ìŠ¤ ìš”êµ¬ ì—†ìŒ)
        if (last.areaRatio > 0 && last.areaRatio < MIN_PAPER_AREA_RATIO) {
          await speak(`í˜ì´ì§€ ${currentPage}ê°€ ë„ˆë¬´ ì‘ê²Œ ë³´ì…ë‹ˆë‹¤. íœ´ëŒ€í°ì„ ë” ê°€ê¹Œì´ ê°€ì ¸ì˜¤ì„¸ìš”.`);
          continue;
        }

        const ok = last.stop || qualityOk(last.text);

        if (ok) {
          const qnums = extractQnumsFromPage(last.text);
          pages.push({ page: currentPage, text: last.text, conf: last.conf, qnums });
          rebuildAllText();
          okPage = true;
          break;
        } else {
          await speak(`ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. í˜ì´ì§€ ${currentPage}ë¥¼ ë” ê°€ê¹Œì´ ë³´ì—¬ ì£¼ì„¸ìš”.`);
        }
      }

      if (!okPage) {
        await speak(`í˜ì´ì§€ ${currentPage}ë¥¼ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë°˜ì‚¬ë¥¼ ì—†ì• ê³  ë” ê°€ê¹Œì´ ì´¬ì˜í•´ ì£¼ì„¸ìš”.`);
        throw new Error(`OCR ì‹¤íŒ¨(page=${currentPage})`);
      }

      if (last && last.stop) {
        log(`STOP(${STOP_PHRASE}) ê°ì§€ â†’ OCR ì¢…ë£Œ`);
        break;
      }

      await speakTurnPage(currentPage);
      currentPage++;
    }

    await speak("ì´ì œ ë¬¸ì œë¥¼ í’‰ë‹ˆë‹¤.");

    for (let attempt=1; attempt<=2; attempt++) {
      const solved = await callSolve(allText);

      if (solved.ok && solved.answers) {
        lastAnswers = solved.answers;
        ansBox.value = answersToText(solved.answers);
        btnReplay.disabled = false;
        await speak("ì •ë‹µì„ ì½ê² ìŠµë‹ˆë‹¤.");
        await speakAnswers(solved.answers);
        log("ì™„ë£Œ");
        return;
      }

      const badQs = Array.isArray(solved.bad_questions) ? solved.bad_questions : [];
      if (badQs.length === 0 || attempt === 2) {
        log(`SOLVE ì‹¤íŒ¨: ${solved.error || "unknown"}`);
        await speak("í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”.");
        throw new Error(`SOLVE ì‹¤íŒ¨: ${solved.error || "unknown"}`);
      }

      const targetPages = mapBadQuestionsToPages(badQs);
      if (targetPages.length === 0) {
        await speak("ì¼ë¶€ ë¬¸í•­ ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”.");
        throw new Error("bad_questions page mapping failed");
      }

      await speak(`ë‹¤ìŒ ë¬¸í•­ì´ ì˜ ì•ˆ ì½í˜”ìŠµë‹ˆë‹¤. ${badQs.slice(0,10).join(", ")}ë²ˆ. í•´ë‹¹ í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
      await recaptureSpecificPages(targetPages);
    }
  }

  function stopAll() {
    running = false;
    btnStart.disabled = false;
    btnStop.disabled = true;
    try { speechSynthesis.cancel(); } catch(_) {}
    log("STOP");
  }

  btnAudio.addEventListener("click", async () => {
    try {
      await unlockAudio();
      pickKoreanVoice();
      await speak("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ.");
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì™„ë£Œ(ë²„íŠ¼)");
    } catch (e) {
      log("ì˜¤ë””ì˜¤ ì¤€ë¹„ ì‹¤íŒ¨: " + String(e?.message || e));
    }
  });

  btnStart.addEventListener("click", async () => {
    try {
      await runAuto();
    } catch (e) {
      log(`ERROR: ${e && e.message ? e.message : e}`);
      try { await speak("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”."); } catch (_) {}
      stopAll();
    }
  });

  btnStop.addEventListener("click", () => stopAll());

  btnReplay.addEventListener("click", async () => {
    try {
      await unlockAudio();
      pickKoreanVoice();
      if (!lastAnswers) { await speak("ì •ë‹µì´ ì—†ìŠµë‹ˆë‹¤."); return; }
      await speakAnswers(lastAnswers);
    } catch (e) {
      log("ì •ë‹µ ë‹¤ì‹œë“£ê¸° ì‹¤íŒ¨: " + String(e?.message || e));
    }
  });

  speechSynthesis.onvoiceschanged = () => pickKoreanVoice();
})();
</script>
</body>
</html>
