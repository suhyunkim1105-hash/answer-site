<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>NONSUL Auto OCR + Auto Solve (Fix)</title>

  <!-- Tesseract v5 -->
  <script src="https://unpkg.com/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body { margin:0; padding:10px; background:#000; color:#fff; font-family:system-ui,-apple-system,BlinkMacSystemFont,sans-serif; }
    .wrap { max-width:980px; margin:0 auto; }
    #videoBox { position:relative; width:100%; background:#000; border-radius:12px; overflow:hidden; border:1px solid rgba(0,255,0,0.35); }
    #video { width:100%; height:auto; transform-origin:center center; transform:scale(0.8); } /* í‘œì‹œìš© 0.8 */
    .btnRow { display:flex; gap:10px; flex-wrap:wrap; margin:10px 0; }
    button { padding:10px 12px; border-radius:10px; border:1px solid #444; background:#111; color:#fff; font-size:14px; }
    button:active { transform:scale(0.98); }
    .panel { border:1px solid #333; border-radius:12px; padding:12px; background:#0b0b0b; margin-top:10px; white-space:pre-wrap; line-height:1.35; font-size:14px; }
    .title { font-weight:700; margin-bottom:8px; font-size:15px; }
    pre { margin:0; font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono",monospace; font-size:12.5px;
          white-space:pre-wrap; word-break:break-word; max-height:360px; overflow:auto; padding:10px; border-radius:10px; background:#000; border:1px solid #222; }
    #answerOut { max-height:520px; font-size:13px; }
  </style>
</head>

<body>
<div class="wrap">
  <div id="videoBox">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <div class="btnRow">
    <button id="btnTTS">ğŸ”Š ìŒì„± ì—°ê²°(í•œ ë²ˆ íƒ­)</button>
    <button id="btnForceSolve">âš¡ ì§€ê¸ˆê¹Œì§€ë¡œ ê°•ì œ í’€ì´</button>
    <button id="btnRestart">ğŸ” OCR ì¬ì‹œì‘(ìƒˆë¡œê³ ì¹¨)</button>
  </div>

  <div class="panel" id="statusPanel">ë¡œë”© ì¤‘...</div>

  <div class="panel">
    <div class="title">ì‹¤ì‹œê°„ OCR(ëˆ„ì )</div>
    <pre id="ocrPreview"></pre>
  </div>

  <div class="panel">
    <div class="title">ë‹µì•ˆ</div>
    <pre id="answerOut"></pre>
  </div>
</div>

<script>
(() => {
  const SOLVE_URL = "/.netlify/functions/solve";

  // âœ… ìë™ OCR ì£¼ê¸°: ë„ˆë¬´ ì§§ìœ¼ë©´ iPhoneì—ì„œ í„°ì§ / ë„ˆë¬´ ê¸¸ë©´ ë‹µë‹µí•¨
  const OCR_INTERVAL_MS = 3500;

  const INSUFFICIENT_WARN_MS = 60 * 1000;
  const INSUFFICIENT_AUTO_SOLVE_MS = 8 * 60 * 1000;
  const READY_LEN_TARGET = 2400;

  const MAX_PREVIEW_CHARS = 16000;
  const MAX_SEND_CHARS = 9000;

  const OCR_LANG = "kor";

  const LANG_PATHS = [
    "https://cdn.jsdelivr.net/npm/@tesseract.js-data/kor/4.0.0_best/",
    "https://unpkg.com/@tesseract.js-data/kor@4.0.0_best/",
    "https://tessdata.projectnaptha.com/4.0.0/"
  ];

  const video = document.getElementById("video");
  const statusPanel = document.getElementById("statusPanel");
  const ocrPreview = document.getElementById("ocrPreview");
  const answerOut = document.getElementById("answerOut");
  const btnTTS = document.getElementById("btnTTS");
  const btnForceSolve = document.getElementById("btnForceSolve");
  const btnRestart = document.getElementById("btnRestart");

  let stream = null;

  let worker = null;
  let engineReady = false;
  let engineError = "";
  let ocrBusy = false;

  let segments = [];
  let avgConf = 0;

  let insufficientSince = null;
  let insufficientWarned = false;
  let solvedOnce = false;

  let ttsUnlocked = false;

  // í™”ë©´ ìƒíƒœ(ê°€ë ¤ì§/íë¦¼/ì›€ì§ì„) ì•ˆë‚´ë§Œ (âœ… OCR ì‹¤í–‰ì„ ë§‰ì§€ ì•ŠìŒ!)
  const MET_W = 72, MET_H = 40;
  const metCanvas = document.createElement("canvas");
  const metCtx = metCanvas.getContext("2d", { willReadFrequently: true });
  metCanvas.width = MET_W;
  metCanvas.height = MET_H;
  let prevThumb = null;
  let lastMetrics = { blocked:false, blurry:false, moving:false, bright:0 };

  // iPhone wasm í¬ë˜ì‹œ ë°©ì§€ìš© ë¦¬ì…‹
  let ocrCount = 0;
  const OCR_RESET_EVERY = 18;

  // ë””ë²„ê·¸
  let ocrAttemptCount = 0;
  let lastOcrAttemptAt = 0;

  function effectiveLen(s) { return (s || "").replace(/\s/g, "").length; }

  // ìˆ«ì/ê¸°í˜¸ ì œê±° + í•œê¸€ ìœ„ì£¼
  function normalizeText(raw) {
    const s = (raw || "")
      .replace(/\r/g, "")
      .replace(/[0-9]/g, "")
      .replace(/[~`^_=+<>\\|]/g, " ")
      .replace(/[â– â–¡â—†â—‡â—â—‹â–²â–³â–¼â–½â€»â˜…â˜†]/g, " ")
      .replace(/[(){}\[\]]/g, " ")
      .replace(/[â€œâ€"']/g, " ")
      .replace(/[â€¢Â·]/g, " ")
      .replace(/[â€”â€“]/g, "-")
      .replace(/[^\uAC00-\uD7A3\u3131-\u318E\u314F-\u3163\s\.\,\!\?\:\;\-\n]/g, " ")
      .replace(/[ \t]+/g, " ")
      .replace(/\n{3,}/g, "\n\n")
      .trim();

    return s.split("\n").map(x => x.trim()).join("\n").trim();
  }

  function makeSig(s) {
    return (s || "").replace(/\s+/g, "").slice(0, 600);
  }

  function mergeSegment(text, conf) {
    const sig = makeSig(text);
    let idx = -1;

    for (let i=0;i<segments.length;i++){
      const a = segments[i].sig.slice(0, 220);
      const b = sig.slice(0, 220);
      if (a && b && a === b) { idx = i; break; }
    }

    if (idx >= 0) {
      const old = segments[idx];
      const oldLen = effectiveLen(old.text);
      const newLen = effectiveLen(text);
      if (newLen > oldLen || conf > old.conf + 3) {
        segments[idx] = { text, conf, sig };
      }
    } else {
      segments.push({ text, conf, sig });
      if (segments.length > 45) segments = segments.slice(-45);
    }

    const sum = segments.reduce((a,s)=>a+(s.conf||0),0);
    avgConf = segments.length ? (sum / segments.length) : 0;
  }

  function getAccumulatedText() {
    const joined = segments.map(s=>s.text).join("\n\n");
    if (joined.length <= MAX_PREVIEW_CHARS) return joined;
    return joined.slice(joined.length - MAX_PREVIEW_CHARS);
  }

  function markInsufficient() {
    const now = Date.now();
    if (!insufficientSince) insufficientSince = now;
  }
  function clearInsufficient() {
    insufficientSince = null;
    insufficientWarned = false;
  }

  function speak(text) {
    if (!ttsUnlocked) return;
    try {
      window.speechSynthesis.cancel();
      const u = new SpeechSynthesisUtterance(String(text || "").slice(0, 2200));
      u.lang = "ko-KR";
      u.rate = 1.02;
      u.pitch = 1.0;
      window.speechSynthesis.speak(u);
    } catch (e) {}
  }

  function buildStatusText(lastMsg) {
    const acc = getAccumulatedText();
    const accLen = effectiveLen(acc);
    const now = Date.now();
    const dur = insufficientSince ? (now - insufficientSince) : 0;
    const sec = Math.floor(dur / 1000);

    const camState = lastMetrics.blocked ? "ê°€ë ¤ì§/ë„ˆë¬´ ì–´ë‘ì›€" :
                    lastMetrics.blurry ? "íë¦¼(ë„ˆë¬´ ê°€ê¹Œì›€/ì´ˆì )" :
                    lastMetrics.moving ? "ì •ìƒ(ì›€ì§ì„)" : "ì •ìƒ(ê³ ì •)";

    const lines = [];
    lines.push("ìë™ OCR(ëˆ„ì ) â†’ ìë™ í’€ì´");
    lines.push("í”„ë¦¬ë·° ë°°ìœ¨: 0.8 (í‘œì‹œìš©)");
    lines.push("ì¹´ë©”ë¼ ìƒíƒœ: " + camState + " | ë°ê¸°: " + lastMetrics.bright.toFixed(1));
    lines.push("ì„¸ê·¸ë¨¼íŠ¸(í˜ì´ì§€ ì¶”ì •) ìˆ˜: " + segments.length);
    lines.push("ëˆ„ì  OCR ê¸¸ì´(ê³µë°±ì œì™¸): " + accLen + " / ê¸°ì¤€ " + READY_LEN_TARGET);
    lines.push("í‰ê·  OCR ì‹ ë¢°ë„(ëŒ€ëµ): " + (avgConf ? avgConf.toFixed(1) : "0.0") + "%");
    lines.push("ì§€ë¬¸ ë¶€ì¡± ì§€ì†: " + (insufficientSince ? (sec + "ì´ˆ (1ë¶„ ì•ˆë‚´, 8ë¶„ ìë™í’€ì´)") : "0ì´ˆ"));
    lines.push("OCR ì—”ì§„: " + (engineReady ? "ì¤€ë¹„ë¨" : "ë¡œë”©/ë¶ˆì•ˆì •"));
    lines.push("OCR ì‹œë„ íšŸìˆ˜: " + ocrAttemptCount);
    lines.push("ë§ˆì§€ë§‰ ë©”ì‹œì§€: " + (lastMsg || "-"));
    if (!engineReady && engineError) lines.push("ì—”ì§„ ì—ëŸ¬: " + engineError);
    return lines.join("\n");
  }

  function setStatus(msg) {
    statusPanel.textContent = buildStatusText(msg);
  }

  btnTTS.addEventListener("click", () => {
    ttsUnlocked = true;
    btnTTS.textContent = "ğŸ”Š ìŒì„± ì—°ê²°ë¨";
    speak("ìŒì„± ì—°ê²° ì™„ë£Œ. ë‹µì•ˆì´ ë‚˜ì˜¤ë©´ ìë™ìœ¼ë¡œ ì½ì–´ì¤ë‹ˆë‹¤.");
  });

  btnRestart.addEventListener("click", () => location.reload());

  btnForceSolve.addEventListener("click", () => {
    triggerSolve(true, "ì‚¬ìš©ì ê°•ì œ í’€ì´", false);
  });

  async function startCamera() {
    try {
      const constraints = {
        video: { facingMode: { ideal: "environment" }, width: { ideal: 1920 }, height: { ideal: 1080 }, frameRate: { ideal: 30 } },
        audio: false
      };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;
      setStatus("ì¹´ë©”ë¼ ON");
    } catch (e) {
      engineError = "ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨: " + String(e && e.message ? e.message : e);
      setStatus("ì¹´ë©”ë¼ ì ‘ê·¼ ì‹¤íŒ¨");
    }
  }

  function analyzeCameraFrame() {
    if (!video.videoWidth || !video.videoHeight) {
      lastMetrics = { blocked:false, blurry:false, moving:true, bright:0 };
      return;
    }

    metCtx.drawImage(video, 0, 0, MET_W, MET_H);
    const img = metCtx.getImageData(0, 0, MET_W, MET_H).data;

    const n = MET_W * MET_H;
    let sum = 0;
    let diff = 0;

    const curr = new Uint8Array(n);
    for (let i=0, p=0; i<img.length; i+=4, p++){
      const r=img[i], g=img[i+1], b=img[i+2];
      const gray = (r + g + b) / 3;
      curr[p] = gray;
      sum += gray;
      if (prevThumb) diff += Math.abs(gray - prevThumb[p]);
    }

    const bright = sum / n;
    const motion = prevThumb ? (diff / n) : 999;

    let variance = 0;
    for (let i=0;i<n;i++){
      const d = curr[i] - bright;
      variance += d*d;
    }
    variance /= n;

    const blocked = bright < 18;
    const blurry = !blocked && variance < 220;
    const moving = motion >= 7;

    prevThumb = curr;
    lastMetrics = { blocked, blurry, moving, bright };
  }

  function buildOcrCanvas() {
    const vw = video.videoWidth || 0;
    const vh = video.videoHeight || 0;

    const canvas = document.createElement("canvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    if (!vw || !vh) {
      canvas.width = 640; canvas.height = 360;
      ctx.fillStyle = "black"; ctx.fillRect(0,0,canvas.width,canvas.height);
      return canvas;
    }

    const maxW = 1280;
    const scale = Math.min(1, maxW / vw);
    const outW = Math.floor(vw * scale);
    const outH = Math.floor(vh * scale);

    canvas.width = outW;
    canvas.height = outH;
    ctx.drawImage(video, 0, 0, outW, outH);

    // ëŒ€ë¹„ ê°•í™”
    const img = ctx.getImageData(0, 0, outW, outH);
    const d = img.data;
    const contrast = 1.25;
    const intercept = 128 * (1 - contrast);

    for (let i = 0; i < d.length; i += 4) {
      const r = d[i], g = d[i+1], b = d[i+2];
      let gray = (r*0.299 + g*0.587 + b*0.114);
      gray = gray * contrast + intercept;
      if (gray < 0) gray = 0;
      if (gray > 255) gray = 255;
      d[i] = d[i+1] = d[i+2] = gray;
      d[i+3] = 255;
    }
    ctx.putImageData(img, 0, 0);

    return canvas;
  }

  const withTimeout = (p, ms, msg) =>
    Promise.race([p, new Promise((_, rej) => setTimeout(() => rej(new Error(msg)), ms))]);

  async function terminateWorker() {
    if (!worker) return;
    try { await worker.terminate(); } catch (e) {}
    worker = null;
  }

  async function tryCreateWorker(langPath) {
    const logger = (m) => {
      if (!m || !m.status) return;
      const st = String(m.status);
      if (st.includes("loading") || st.includes("initializing")) {
        statusPanel.textContent = "OCR ì—”ì§„ ë¡œë”© ì¤‘...\n" + st;
      }
    };

    // v5 ë°©ì‹
    try {
      const w = await Tesseract.createWorker(OCR_LANG, 1, { logger, langPath });
      return w;
    } catch (e1) {}

    // ì˜ˆì™¸ì  ë²ˆë“¤ ëŒ€ì‘
    const w = await Tesseract.createWorker({ logger, langPath });
    if (w.loadLanguage) await w.loadLanguage(OCR_LANG);
    if (w.initialize) await w.initialize(OCR_LANG);
    return w;
  }

  async function initOcrEngine() {
    engineReady = false;
    engineError = "";
    await terminateWorker();

    for (let i=0;i<LANG_PATHS.length;i++){
      const lp = LANG_PATHS[i];
      setStatus("OCR ì–¸ì–´íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì‹œë„: " + lp);

      try {
        worker = await withTimeout(tryCreateWorker(lp), 45000, "createWorker timeout");

        if (worker.setParameters) {
          await worker.setParameters({
            tessedit_pageseg_mode: "6",
            preserve_interword_spaces: "1",
            tessedit_char_blacklist: "0123456789@#$%^&*_=+<>|{}[]~`",
          });
        }

        engineReady = true;
        engineError = "";
        ocrCount = 0;
        setStatus("OCR ì—”ì§„ ì¤€ë¹„ë¨");
        return;
      } catch (e) {
        engineError = String(e && e.message ? e.message : e);
        await terminateWorker();
      }
    }

    engineReady = false;
    setStatus("OCR ì—”ì§„ ë¡œë”© ì‹¤íŒ¨(ë„¤íŠ¸ì›Œí¬/CDN ì°¨ë‹¨ ê°€ëŠ¥)");
  }

  async function runOcrOnce() {
    if (!engineReady || !worker) return;
    if (ocrBusy) return;

    // âœ… ì—¬ê¸°ì„œë¶€í„°: ì›€ì§ì—¬ë„ OCRì€ ëˆë‹¤ (ë§‰ì§€ ì•ŠìŒ)
    analyzeCameraFrame();

    if (lastMetrics.blocked) {
      markInsufficient();
      setStatus("ì¹´ë©”ë¼ê°€ ê°€ë ¤ì¡Œê±°ë‚˜ ë„ˆë¬´ ì–´ë‘ì›€(ì¢…ì´ë¥¼ ë°ê²Œ)");
      return;
    }

    if (!video.videoWidth || !video.videoHeight) {
      markInsufficient();
      setStatus("ë¹„ë””ì˜¤ ì¤€ë¹„ ëŒ€ê¸°");
      return;
    }

    // ë„ˆë¬´ ì´˜ì´˜íˆ ëŒë¦¬ë©´ iPhone í„°ì§ˆ ìˆ˜ ìˆì–´ì„œ ìµœì†Œ ê°„ê²© ë³´ì¥
    const now = Date.now();
    if (now - lastOcrAttemptAt < 2600) return;
    lastOcrAttemptAt = now;

    ocrBusy = true;
    ocrAttemptCount++;

    try {
      const note = lastMetrics.moving ? "í”ë“¤ë¦¼ ê°ì§€(ê·¸ë˜ë„ OCR ì‹œë„)" : "OCR ì§„í–‰ ì¤‘...";
      setStatus(note);

      const canvas = buildOcrCanvas();
      const res = await worker.recognize(canvas);

      const conf = (res && res.data && typeof res.data.confidence === "number") ? res.data.confidence : 0;
      const raw = (res && res.data && res.data.text) ? res.data.text : "";

      const cleaned = normalizeText(raw);
      const len = effectiveLen(cleaned);

      if (len < 35) {
        markInsufficient();
        setStatus("OCR ë„ˆë¬´ ì§§ìŒ(ì§€ë¬¸ ë¶€ì¡±) â†’ ì¢…ì´ë¥¼ ë” í¬ê²Œ/ë” ì˜¤ë˜ ë¹„ì¶°");
        return;
      }

      mergeSegment(cleaned, conf);

      const acc = getAccumulatedText();
      const accLen = effectiveLen(acc);
      ocrPreview.textContent = acc;

      if (accLen >= READY_LEN_TARGET) clearInsufficient();
      else markInsufficient();

      if (!solvedOnce) {
        if (accLen >= READY_LEN_TARGET) {
          await triggerSolve(false, "ëˆ„ì  ì§€ë¬¸ì´ ì¶©ë¶„í•´ ìë™ í’€ì´í•©ë‹ˆë‹¤.", false);
        } else {
          const dur = insufficientSince ? (Date.now() - insufficientSince) : 0;

          if (!insufficientWarned && dur >= INSUFFICIENT_WARN_MS) {
            insufficientWarned = true;
            speak("ì§€ë¬¸ì´ ë¶€ì¡±í•©ë‹ˆë‹¤. ì¢…ì´ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë¹„ì¶”ê³  5ì´ˆ ì´ìƒ ê³ ì •í•´ ì£¼ì„¸ìš”.");
          }

          if (dur >= INSUFFICIENT_AUTO_SOLVE_MS) {
            await triggerSolve(false, "ì§€ë¬¸ ë¶€ì¡±ì´ ì˜¤ë˜ ì§€ì†ë˜ì–´ í˜„ì¬ê¹Œì§€ë¡œ ìë™ í’€ì´í•©ë‹ˆë‹¤.", true);
          }
        }
      }

      ocrCount++;
      setStatus("OCR ì™„ë£Œ (len=" + len + ", conf=" + conf.toFixed(1) + "%)");

      if (ocrCount >= OCR_RESET_EVERY) {
        engineReady = false;
        setStatus("OCR ì—”ì§„ ì•ˆì •í™” ë¦¬ì…‹ ì¤‘...");
        await initOcrEngine();
      }

    } catch (e) {
      const msg = String(e && e.message ? e.message : e);
      engineReady = false;
      engineError = msg;
      setStatus("OCR ì—ëŸ¬ â†’ ì—”ì§„ ì¬ì‹œì‘");
      await initOcrEngine();
      markInsufficient();
    } finally {
      ocrBusy = false;
    }
  }

  async function triggerSolve(force, reason, becauseInsufficient) {
    if (solvedOnce && !force) return;

    const acc = getAccumulatedText();
    let sendText = acc;
    if (sendText.length > MAX_SEND_CHARS) sendText = sendText.slice(sendText.length - MAX_SEND_CHARS);

    const sendLen = effectiveLen(sendText);
    if (!force && sendLen < 120) return;

    solvedOnce = true;
    answerOut.textContent = "í’€ì´ ìƒì„± ì¤‘...\n" + reason;

    try {
      const payload = { mode: "NONSUL", ocrText: sendText, ocr_text: sendText };

      const res = await fetch(SOLVE_URL, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      const ct = (res.headers.get("content-type") || "").toLowerCase();
      let out = "";

      if (ct.includes("application/json")) {
        const data = await res.json();
        out = (data && data.answer) ? String(data.answer) : JSON.stringify(data);
      } else {
        out = await res.text();
      }

      if (!res.ok) {
        answerOut.textContent = "ì„œë²„ ì—ëŸ¬(" + res.status + ")\n" + out.slice(0, 2000);
        solvedOnce = false;
        return;
      }

      if (becauseInsufficient) {
        out = "â€» ì§€ë¬¸ì´ ë¶€ì¡±í•˜ì—¬ í˜„ì¬ê¹Œì§€ë¡œ ìë™ í’€ì´í•©ë‹ˆë‹¤.\n\n" + out;
      }

      answerOut.textContent = out;
      speak(out);

    } catch (e) {
      answerOut.textContent = "solve í˜¸ì¶œ ì‹¤íŒ¨: " + String(e && e.message ? e.message : e);
      solvedOnce = false;
    }
  }

  async function boot() {
    await startCamera();
    await initOcrEngine();

    // âœ… ì—”ì§„ ì¤€ë¹„ë˜ë©´ 1ì´ˆ í›„ ì²« OCR ê°•ì œ ì‹œë„(â€œì¤€ë¹„ë¨ì¸ë° ì•„ë¬´ê²ƒë„ ì•ˆ í•¨â€ ë°©ì§€)
    setTimeout(() => {
      if (engineReady) runOcrOnce();
    }, 1000);

    setInterval(() => {
      if (!engineReady) {
        setStatus("OCR ì—”ì§„ ë¡œë”©/ë¶ˆì•ˆì •(ë„¤íŠ¸ì›Œí¬ í™•ì¸)");
        return;
      }
      runOcrOnce();
    }, OCR_INTERVAL_MS);
  }

  boot();
})();
</script>
</body>
</html>
