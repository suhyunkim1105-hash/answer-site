<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>í¸ì…ì˜ì–´ ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</title>
  <style>
    body { font-family: -apple-system, system-ui, sans-serif; margin: 16px; }
    #status { white-space: pre-wrap; padding: 10px; border: 1px solid #ddd; border-radius: 8px; min-height: 84px; }
    video { width: 100%; max-width: 520px; border-radius: 12px; background: #000; }
    button { padding: 12px 14px; border-radius: 10px; border: 1px solid #ccc; background: #fff; font-size: 16px; }
    button:disabled { opacity: 0.5; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    textarea { width: 100%; min-height: 140px; margin-top: 10px; }
    .small { font-size: 12px; color: #666; }
  </style>
</head>
<body>
  <h2>ìë™ OCR â†’ ìë™ í’€ì´ â†’ ì •ë‹µ TTS</h2>

  <div id="status">ëŒ€ê¸° ì¤‘</div>
  <div class="row" style="margin:12px 0;">
    <button id="btnStart">ğŸ“¸ ìë™ ì‹œì‘</button>
    <button id="btnStop" disabled>â›” ì¤‘ì§€</button>
  </div>

  <div class="small">
    - ë§ˆì§€ë§‰ í˜ì´ì§€ì— <b>â€œì´¬ì˜ ì™„ë£Œâ€</b>ë¼ê³  í¬ê²Œ ì¨ë‘ë©´ ìë™ìœ¼ë¡œ OCR ì¢…ë£Œ í›„ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br/>
    - OCRì´ ë¶ˆì•ˆì •í•˜ë©´ ìë™ìœ¼ë¡œ â€œë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”â€ ë˜ëŠ” â€œëª‡ ë²ˆ ë¬¸ì œ ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”â€ë¥¼ ë§í•œë‹¤.
  </div>

  <div style="margin-top:12px;">
    <video id="video" autoplay playsinline muted></video>
  </div>

  <h3 style="margin-top:16px;">OCR ëˆ„ì  í…ìŠ¤íŠ¸(ë””ë²„ê·¸)</h3>
  <textarea id="ocrBox" placeholder="ìë™ OCR ê²°ê³¼ê°€ ëˆ„ì ëœë‹¤(ìˆ˜ë™ ìˆ˜ì • ê¸ˆì§€)."></textarea>

  <h3 style="margin-top:16px;">ì •ë‹µ(ë””ë²„ê·¸)</h3>
  <textarea id="ansBox" placeholder="ìë™ í’€ì´ ê²°ê³¼ê°€ ì—¬ê¸°ì— ì¶œë ¥ëœë‹¤."></textarea>

<script>
(() => {
  const OCR_URL   = "/.netlify/functions/ocr";
  const SOLVE_URL = "/.netlify/functions/solve";

  // ì´¬ì˜/ì¸ì‹ ì„¤ì •
  const SHOTS_PER_PAGE = 3;
  const SHOT_GAP_MS = 150;              // âœ… 5ì´ˆ ëŒ€ê¸° ì œê±° (ê±°ì˜ ì¦‰ì‹œ)
  const MAX_PAGES = 25;
  const MAX_RETRY_PER_PAGE = 4;

  // í˜ì´ì§€ ë„˜ê¹€ ì•ˆë‚´(ë„ˆë¬´ ê¸¸ë©´ ë‹µë‹µí•´ì§)
  const TURN_PAGE_WAIT_MS = 600;        // âœ… ì•ˆë‚´ í›„ ì ê¹ë§Œ ì‰¬ê³  ë‹¤ìŒ í˜ì´ì§€ ì´¬ì˜

  // OCR í’ˆì§ˆ ê¸°ì¤€(ë„ˆë¬´ ë¹¡ì„¸ë©´ ë¬´í•œ ì¬ì´¬ì˜ë¨)
  const MIN_TEXT_LEN = 700;             // ê¸°ë³¸ ìµœì†Œ ê¸¸ì´
  const MIN_QNUM_HITS = 2;              // "01,02" ê°™ì€ ë¬¸í•­ë²ˆí˜¸ íˆíŠ¸
  const PASSAGE_LEN_OK = 1400;          // ë¬¸í•­ë²ˆí˜¸ê°€ ì˜ ì•ˆ ì¡í˜€ë„ ê¸¸ë©´ í†µê³¼(ì§€ë¬¸ í˜ì´ì§€ ëŒ€ë¹„)

  // ì¢…ë£Œ ê°ì§€
  const STOP_PHRASE = "ì´¬ì˜ ì™„ë£Œ";

  // ì •ë‹µ TTS
  const ANSWER_ROUNDS = 4;
  const BETWEEN_ANS_MS = 2000;          // âœ… ë¬¸í•­ ì‚¬ì´ 2ì´ˆ
  const BETWEEN_ROUND_MS = 600;

  let running = false;
  let stream = null;

  let currentPage = 1;
  let pages = []; // {page, text, conf, qnums:Set<number>}
  let allText = "";

  let koVoice = null;

  const statusEl = document.getElementById("status");
  const video = document.getElementById("video");
  const btnStart = document.getElementById("btnStart");
  const btnStop = document.getElementById("btnStop");
  const ocrBox = document.getElementById("ocrBox");
  const ansBox = document.getElementById("ansBox");

  function log(msg) {
    const t = new Date().toLocaleTimeString("ko-KR", { hour12:false });
    statusEl.textContent = `[${t}] ${msg}\n` + statusEl.textContent;
    console.log(msg);
  }
  const sleep = (ms)=>new Promise(r=>setTimeout(r,ms));

  // ---------- TTS ----------
  function pickKoreanVoice() {
    const voices = speechSynthesis.getVoices() || [];
    const ko = voices.filter(v => (v.lang || "").toLowerCase().startsWith("ko"));
    const preferred = ko.find(v => /yuna|ìœ ë‚˜|ì„œí˜„|ì§€ì€|ì•„ë¦¬/i.test(v.name));
    koVoice = preferred || ko[0] || null;
    if (koVoice) log(`TTS voice: ${koVoice.name} (${koVoice.lang})`);
    else log(`TTS voice ì„ íƒ ì‹¤íŒ¨`);
  }

  function speak(text) {
    return new Promise(resolve => {
      try {
        const u = new SpeechSynthesisUtterance(String(text));
        u.lang = "ko-KR";
        u.rate = 1.0;
        if (koVoice) u.voice = koVoice;
        u.onend = resolve;
        u.onerror = resolve;
        speechSynthesis.speak(u);
      } catch (_) { resolve(); }
    });
  }

  async function speakTurnPage(page) {
    await speak(`í˜ì´ì§€ ${page} ì¸ì‹ ì™„ë£Œ. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë„˜ê²¨ ì£¼ì„¸ìš”.`);
    await sleep(TURN_PAGE_WAIT_MS);
  }

  async function speakAnswers(answerNumMap) {
    // answerNumMap: {"1":3,...} 1~5
    const toLetter = (n)=>["A","B","C","D","E"][Number(n)-1] || "";
    const keys = Object.keys(answerNumMap).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);

    speechSynthesis.cancel();

    for (let r=1; r<=ANSWER_ROUNDS; r++) {
      // âœ… ìš”êµ¬: â€œ1ë²ˆ A, 2ì´ˆ, 2ë²ˆ B â€¦â€ í˜•íƒœë¡œë§Œ ë°˜ë³µ(êµ°ë”ë”ê¸° ìµœì†Œ)
      for (const q of keys) {
        const a = toLetter(answerNumMap[String(q)]);
        if (!a) continue;
        await speak(`${q}ë²ˆ ${a}`);
        await sleep(BETWEEN_ANS_MS);
      }
      await sleep(BETWEEN_ROUND_MS);
    }
  }

  // ---------- Camera ----------
  async function startCamera() {
    if (stream) return;
    stream = await navigator.mediaDevices.getUserMedia({
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1440 },
        height:{ ideal: 2560 }
      },
      audio: false
    });
    video.srcObject = stream;
    await new Promise(r => video.onloadedmetadata = r);
    log(`ì¹´ë©”ë¼ OK (${video.videoWidth}x${video.videoHeight})`);
  }

  function captureFrameBase64Jpeg(quality=0.90) { // OCR í’ˆì§ˆ ìœ„í•´ ì•½ê°„ ë†’ì„
    const w = video.videoWidth, h = video.videoHeight;
    const canvas = document.createElement("canvas");
    canvas.width = w; canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);
    return canvas.toDataURL("image/jpeg", quality);
  }

  // ---------- OCR ----------
  async function callOcr(dataUrl, pageIndex) {
    const payload = { image: dataUrl, pageIndex, mode: "dual" };
    const res = await fetch(OCR_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    const j = await res.json().catch(()=>null);
    if (!j || !j.ok) return { ok:false, text:"", conf:0 };
    return { ok:true, text:String(j.text||""), conf:Number(j.conf||0) };
  }

  const normalize = (s)=>String(s||"").replace(/\s+/g,"").trim();
  function detectStop(text) {
    const t = normalize(text);
    return t.includes(normalize(STOP_PHRASE));
  }

  function qnumHits(text) {
    // ì¤„ ì‹œì‘ì˜ 01~50ì„ ì£¼ë¡œ ì¡ëŠ”ë‹¤
    const m = String(text||"").match(/(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g);
    return m ? m.length : 0;
  }

  function extractQnumsFromPage(text) {
    const out = new Set();
    const re = /(?:^|\n)\s*(0[1-9]|[1-4][0-9]|50)\b/g;
    let m;
    const t = String(text||"");
    while ((m = re.exec(t)) !== null) out.add(parseInt(m[1],10));
    return out;
  }

  function qualityOk(text) {
    const len = String(text||"").length;
    const hits = qnumHits(text);
    if (len >= PASSAGE_LEN_OK) return true;          // ì§€ë¬¸ í˜ì´ì§€ ëŒ€ë¹„
    if (len >= MIN_TEXT_LEN && hits >= MIN_QNUM_HITS) return true;
    return false;
  }

  async function ocrOnePage(pageIndex) {
    let best = null;

    for (let shot=1; shot<=SHOTS_PER_PAGE; shot++) {
      if (!running) return null;
      await sleep(SHOT_GAP_MS);

      const dataUrl = captureFrameBase64Jpeg(0.90);
      const r = await callOcr(dataUrl, pageIndex);

      const text = r.ok ? r.text : "";
      const conf = r.ok ? r.conf : 0;

      // íœ´ë¦¬ìŠ¤í‹± ì ìˆ˜(ê¸¸ì´+ë¬¸í•­íˆíŠ¸+conf)
      const score = (text.length/50) + (qnumHits(text)*30) + (conf*2);
      log(`OCR ${r.ok?"OK":"FAIL"} page=${pageIndex} shot=${shot} len=${text.length} conf=${conf} score=${score.toFixed(1)}`);

      const cand = { shot, text, conf, score, stop: detectStop(text) };
      if (!best || cand.score > best.score) best = cand;

      // â€œì´¬ì˜ ì™„ë£Œâ€ê°€ ë³´ì´ë©´ ì¦‰ì‹œ ë°˜í™˜
      if (cand.stop) return cand;
    }

    if (!best) return null;
    best.stop = detectStop(best.text);
    return best;
  }

  function rebuildAllText() {
    allText = "";
    for (const p of pages) {
      allText += `[PAGE ${p.page}] (conf=${(p.conf||0).toFixed(1)})\n${p.text}\n\n`;
    }
    ocrBox.value = allText;
  }

  async function recaptureSpecificPages(targetPages) {
    // targetPages: [2,3,...] (page index)
    for (const p of targetPages) {
      if (!running) return;
      await speak(`ë¬¸ì œê°€ ìˆëŠ” í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤. í˜ì´ì§€ ${p}ë¥¼ ë³´ì—¬ ì£¼ì„¸ìš”.`);
      await sleep(350);

      let ok = false;
      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) return;

        log(`ì¬ì´¬ì˜: í˜ì´ì§€ ${p} ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        const r = await ocrOnePage(p);
        if (!r) break;

        // stop í˜ì´ì§€ë©´ ê·¸ëŒ€ë¡œ ì±„íƒ
        if (r.stop || qualityOk(r.text)) {
          const idx = pages.findIndex(x => x.page === p);
          const qnums = extractQnumsFromPage(r.text);
          const entry = { page:p, text:r.text, conf:r.conf, qnums };
          if (idx >= 0) pages[idx] = entry; else pages.push(entry);
          pages.sort((a,b)=>a.page-b.page);
          rebuildAllText();
          ok = true;
          break;
        }

        await speak(`í˜ì´ì§€ ${p} ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”.`);
      }

      if (!ok) {
        await speak(`í˜ì´ì§€ ${p}ë¥¼ ë‹¤ì‹œ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì¡°ëª…ê³¼ ê°ë„ë¥¼ ì¡°ì •í•´ ì£¼ì„¸ìš”.`);
        throw new Error(`ì¬ì´¬ì˜ ì‹¤íŒ¨(page=${p})`);
      }
    }
  }

  // ---------- Solve ----------
  async function callSolve(allText) {
    const res = await fetch(SOLVE_URL, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ text: allText })
    });
    const j = await res.json().catch(()=>null);
    if (!j) return { ok:false, error:"Solve JSON parse failed" };
    return j;
  }

  function answersToText(ansNumMap) {
    const toLetter = (n)=>["A","B","C","D","E"][Number(n)-1] || "";
    const keys = Object.keys(ansNumMap||{}).map(k=>parseInt(k,10)).filter(Number.isFinite).sort((a,b)=>a-b);
    return keys.map(k => `${k}ë²ˆ: ${toLetter(ansNumMap[String(k)])}`).join("\n");
  }

  function mapBadQuestionsToPages(badQs) {
    // badQs: [11,12,...]
    const pagesSet = new Set();
    for (const q of badQs) {
      for (const p of pages) {
        if (p.qnums && p.qnums.has(q)) pagesSet.add(p.page);
      }
    }
    return Array.from(pagesSet).sort((a,b)=>a-b);
  }

  // ---------- Main loop ----------
  async function runAuto() {
    running = true;
    btnStart.disabled = true;
    btnStop.disabled = false;

    pages = [];
    allText = "";
    currentPage = 1;
    ocrBox.value = "";
    ansBox.value = "";

    await startCamera();
    speechSynthesis.getVoices(); // iOS íŠ¸ë¦¬ê±°
    setTimeout(()=>speechSynthesis.getVoices(), 250);
    pickKoreanVoice();

    await speak("ìë™ ì´¬ì˜ì„ ì‹œì‘í•©ë‹ˆë‹¤. ì‹œí—˜ì§€ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë§ì¶° ì£¼ì„¸ìš”.");

    while (running && currentPage <= MAX_PAGES) {
      let okPage = false;
      let last = null;

      for (let retry=1; retry<=MAX_RETRY_PER_PAGE; retry++) {
        if (!running) break;

        log(`í˜ì´ì§€ ${currentPage} OCR ì‹œë„ ${retry}/${MAX_RETRY_PER_PAGE}`);
        last = await ocrOnePage(currentPage);
        if (!last) break;

        const stop = last.stop;
        const ok = stop || qualityOk(last.text);

        if (ok) {
          const qnums = extractQnumsFromPage(last.text);
          pages.push({ page: currentPage, text: last.text, conf: last.conf, qnums });
          rebuildAllText();
          okPage = true;
          break;
        } else {
          await speak(`í˜ì´ì§€ ${currentPage} ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”.`);
        }
      }

      if (!okPage) {
        await speak(`í˜ì´ì§€ ${currentPage}ë¥¼ ì½ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì¡°ëª…ê³¼ ê°ë„ë¥¼ ì¡°ì •í•´ ì£¼ì„¸ìš”.`);
        throw new Error(`OCR ì‹¤íŒ¨(page=${currentPage})`);
      }

      // stopì´ë©´ OCR ì¢…ë£Œ
      if (last && last.stop) {
        log(`STOP(ì´¬ì˜ ì™„ë£Œ) ê°ì§€ â†’ OCR ì¢…ë£Œ`);
        break;
      }

      await speakTurnPage(currentPage);
      currentPage++;
    }

    // í’€ì´ ë‹¨ê³„
    await speak("ì´ì œ ë¬¸ì œë¥¼ í’‰ë‹ˆë‹¤.");
    log("SOLVE ì‹œì‘");

    // solve ì‹œë„(ìµœëŒ€ 2íšŒ: bad_questions ë‚˜ì˜¤ë©´ í•´ë‹¹ í˜ì´ì§€ë§Œ ì¬ì´¬ì˜ í›„ ì¬ì‹œë„)
    for (let attempt=1; attempt<=2; attempt++) {
      const solved = await callSolve(allText);

      if (solved.ok && solved.answers) {
        ansBox.value = answersToText(solved.answers);
        await speak("ì •ë‹µì„ ì½ê² ìŠµë‹ˆë‹¤.");
        await speakAnswers(solved.answers);
        log("ì™„ë£Œ");
        return;
      }

      const badQs = Array.isArray(solved.bad_questions) ? solved.bad_questions : [];
      if (badQs.length === 0 || attempt === 2) {
        log(`SOLVE ì‹¤íŒ¨: ${solved.error || "unknown"}`);
        await speak("í’€ì´ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì´¬ì˜ ìƒíƒœë¥¼ ê°œì„ í•´ ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”.");
        throw new Error(`SOLVE ì‹¤íŒ¨: ${solved.error || "unknown"}`);
      }

      // bad_questions -> ì–´ëŠ í˜ì´ì§€ì¸ì§€ ì¶”ì • í›„ ì¬ì´¬ì˜
      const targetPages = mapBadQuestionsToPages(badQs);
      if (targetPages.length === 0) {
        await speak(`ì¼ë¶€ ë¬¸í•­ ì¸ì‹ì´ ë¶ˆì•ˆì •í•©ë‹ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ ì£¼ì„¸ìš”.`);
        throw new Error("bad_questions page mapping failed");
      }

      await speak(`ë‹¤ìŒ ë¬¸í•­ì´ ì˜ ì•ˆ ì½í˜”ìŠµë‹ˆë‹¤. ${badQs.slice(0,10).join(", ")}ë²ˆ. í•´ë‹¹ í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•©ë‹ˆë‹¤.`);
      await recaptureSpecificPages(targetPages);
      log("ì¬ì´¬ì˜ í›„ SOLVE ì¬ì‹œë„");
    }
  }

  function stopAll() {
    running = false;
    btnStart.disabled = false;
    btnStop.disabled = true;
    try { speechSynthesis.cancel(); } catch(_) {}
    log("STOP");
  }

  btnStart.addEventListener("click", async () => {
    try {
      await runAuto();
    } catch (e) {
      log(`ERROR: ${e && e.message ? e.message : e}`);
      await speak("ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œì‘í•´ ì£¼ì„¸ìš”.");
      stopAll();
    }
  });

  btnStop.addEventListener("click", () => stopAll());
  speechSynthesis.onvoiceschanged = () => pickKoreanVoice();
})();
</script>
</body>
</html>
