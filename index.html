<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Auto OCR â†’ Auto Solve â†’ TTS</title>
  <style>
    :root { color-scheme: dark; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Apple SD Gothic Neo, Noto Sans KR, sans-serif; background:#0b0f14; color:#e8eef7; }
    .wrap { max-width: 980px; margin: 0 auto; padding: 14px; }
    .card { background:#111826; border:1px solid #1f2a3a; border-radius:16px; padding:12px; margin-bottom:12px; }
    .row { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    button { padding:12px 14px; border-radius:14px; border:1px solid #2a3b55; background:#172235; color:#e8eef7; font-weight:700; cursor:pointer; }
    button:disabled{ opacity:.5; cursor:not-allowed; }
    .pill { padding:6px 10px; border-radius:999px; border:1px solid #2a3b55; background:#0f1624; font-size:12px; }
    #status { font-weight:700; line-height:1.35; }
    #log { white-space:pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; line-height:1.35; max-height: 240px; overflow:auto; }
    video { width:100%; border-radius:16px; background:#000; }
    img.thumb { width: 100%; border-radius:16px; border:1px solid #22324a; }
    textarea { width:100%; min-height:120px; border-radius:12px; border:1px solid #2a3b55; background:#0f1624; color:#e8eef7; padding:10px; }
    .grid { display:grid; grid-template-columns: 1.3fr .7fr; gap:12px; }
    @media (max-width: 860px){ .grid{ grid-template-columns: 1fr; } }
    .hint { color:#9bb0cc; font-size:12px; line-height:1.35; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div id="status">ëŒ€ê¸° ì¤‘ì´ë‹¤. â€œìë™ ì‹œì‘â€ì„ ëˆ„ë¥´ë©´ ì¹´ë©”ë¼ë¥¼ ì—´ê³  ìë™ OCRì„ ì‹œì‘í•œë‹¤.</div>
      <div class="row" style="margin-top:10px">
        <button id="btnAuto">ğŸ“¸ ìë™ ì‹œì‘</button>
        <button id="btnStop" disabled>â›” ì¤‘ì§€</button>
        <span class="pill" id="pillState">IDLE</span>
        <span class="pill" id="pillPage">PAGE -</span>
        <span class="pill" id="pillShot">SHOT -</span>
      </div>
      <div class="hint" style="margin-top:10px">
        - ë§ˆì§€ë§‰ í˜ì´ì§€ ì—¬ë°±ì— <b>DONE</b>ì„ í¬ê²Œ ì“°ë©´ OCRì„ ë©ˆì¶”ê³  ìë™ í’€ì´ë¡œ ë„˜ì–´ê°„ë‹¤.<br/>
        - ë°‘ì¤„ì€ OCRë§Œìœ¼ë¡œ ì™„ë²½ ë³µì› ë¶ˆê°€ â†’ í’€ì´ ë‹¨ê³„ì—ì„œ í˜ì´ì§€ ì‚¬ì§„(ë¹„ì „)ë„ ê°™ì´ ë³¸ë‹¤.<br/>
        - iOS ì‚¬íŒŒë¦¬ëŠ” í™”ë©´ ì ê¸ˆ/ì•± ì „í™˜ ì‹œ ì¹´ë©”ë¼/ìŒì„±ì´ ë©ˆì¶œ ìˆ˜ ìˆë‹¤.
      </div>
    </div>

    <div class="grid">
      <div class="card">
        <video id="video" playsinline autoplay muted></video>
      </div>
      <div class="card">
        <div class="hint" style="margin-bottom:6px">ìµœê·¼ ìº¡ì²˜ ìƒ·</div>
        <img id="lastShot" class="thumb" alt="last shot" />
      </div>
    </div>

    <div class="card">
      <div class="hint" style="margin-bottom:6px">OCR ëˆ„ì  í…ìŠ¤íŠ¸</div>
      <textarea id="ocrBox" placeholder="ìë™ OCR ê²°ê³¼ê°€ ì—¬ê¸°ì— ëˆ„ì ëœë‹¤." readonly></textarea>
    </div>

    <div class="card">
      <div class="hint" style="margin-bottom:6px">ì •ë‹µ(TTSëŠ” ìë™ìœ¼ë¡œ ì½ëŠ”ë‹¤)</div>
      <textarea id="ansBox" placeholder="ìë™ í’€ì´ ê²°ê³¼ê°€ ì—¬ê¸°ì— í‘œì‹œëœë‹¤." readonly></textarea>
    </div>

    <div class="card">
      <div class="hint" style="margin-bottom:6px">ë¡œê·¸</div>
      <div id="log"></div>
    </div>
  </div>

<script>
(() => {
  // ===== ì„¤ì • =====
  const MAX_PAGES = 30;
  const SHOTS_PER_PAGE = 3;
  const MAX_RETAKES = 2;
  const NEXT_PAGE_DELAY = 10;
  const MIN_TEXT_LEN = 40;
  const AF_WAIT_MS = 600;
  const OCR_LANG = "eng";
  const USE_VISION_SOLVE = true;

  // âœ… iOSì—ì„œ TTSê°€ ì•ˆ ë‚˜ì˜¤ë©´ ë©ˆì¶”ë˜ ë¬¸ì œë¥¼ ë§‰ê¸° ìœ„í•œ ì˜µì…˜
  const TTS_ENABLED = true;        // ìŒì„± ìì²´ ë„ê³  ì‹¶ìœ¼ë©´ false
  const TTS_BLOCKING = false;      // trueë©´ ë§ì´ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼(ê¶Œì¥X), falseë©´ ë§í•˜ë˜ ì§„í–‰ì€ ê³„ì†

  // ===== DOM =====
  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const logEl = $("log");
  const video = $("video");
  const lastShotImg = $("lastShot");
  const ocrBox = $("ocrBox");
  const ansBox = $("ansBox");
  const btnAuto = $("btnAuto");
  const btnStop = $("btnStop");
  const pillState = $("pillState");
  const pillPage = $("pillPage");
  const pillShot = $("pillShot");

  // ===== ìƒíƒœ =====
  let running = false;
  let stream = null;
  const pages = []; // {page, text, conf, imageDataUrl}

  // ===== ìœ í‹¸ =====
  function nowK() {
    const d = new Date();
    const h = String(d.getHours()).padStart(2,"0");
    const m = String(d.getMinutes()).padStart(2,"0");
    const s = String(d.getSeconds()).padStart(2,"0");
    return `${h}:${m}:${s}`;
  }
  function log(msg) {
    logEl.textContent += `[${nowK()}] ${msg}\n`;
    logEl.scrollTop = logEl.scrollHeight;
  }
  function setUIState(state, page=null, shot=null) {
    pillState.textContent = state;
    pillPage.textContent = page ? `PAGE ${page}` : `PAGE -`;
    pillShot.textContent = shot ? `SHOT ${shot}` : `SHOT -`;
  }
  function setStatus(text) { statusEl.textContent = text; }
  const wait = (ms) => new Promise(r => setTimeout(r, ms));

  // ===== TTS(ì ˆëŒ€ ë©ˆì¶”ì§€ ì•ŠëŠ” ë²„ì „) =====
  function speakSafe(text, rate=1.0) {
    if (!TTS_ENABLED) return Promise.resolve();
    return new Promise((resolve) => {
      let done = false;
      const finish = () => { if (!done) { done = true; resolve(); } };

      try {
        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "ko-KR";
        u.rate = rate;
        u.pitch = 1.0;
        u.onend = finish;
        u.onerror = finish;
        window.speechSynthesis.speak(u);

        // âœ… iOSì—ì„œ onendê°€ ì•ˆ ë¶ˆë¦¬ëŠ” ì¼€ì´ìŠ¤ ëŒ€ë¹„ íƒ€ì„ì•„ì›ƒ(ìµœëŒ€ 8ì´ˆ)
        const maxMs = Math.min(8000, 1200 + String(text).length * 60);
        setTimeout(finish, maxMs);
      } catch (_) {
        finish();
      }
    });
  }

  async function speak(text, rate=1.0) {
    if (!TTS_ENABLED) return;
    if (TTS_BLOCKING) await speakSafe(text, rate);
    else speakSafe(text, rate); // ì§„í–‰ì€ ê³„ì†
  }

  async function countdown(seconds) {
    for (let i = seconds; i >= 1; i--) {
      speak(String(i), 1.0);
      await wait(350);
    }
  }

  // ===== ì¹´ë©”ë¼ =====
  async function startCamera() {
    if (stream) return;
    setStatus("ì¹´ë©”ë¼ë¥¼ ì—¬ëŠ” ì¤‘ì´ë‹¤. ê¶Œí•œ íŒì—…ì´ ëœ¨ë©´ í—ˆìš©í•´ë¼.");
    const constraints = {
      audio: false,
      video: {
        facingMode: { ideal: "environment" },
        width: { ideal: 1920 },
        height: { ideal: 1080 }
      }
    };

    stream = await navigator.mediaDevices.getUserMedia(constraints);
    video.srcObject = stream;

    // iOSì—ì„œ playê°€ íŠ•ê¸¸ ë•Œê°€ ìˆì–´ì„œ try/catch
    try { await video.play(); } catch {}

    setStatus("ì¹´ë©”ë¼ ì¤€ë¹„ ì™„ë£Œë‹¤. ì‹œí—˜ì§€ë¥¼ í™”ë©´ì— ê½‰ ì°¨ê²Œ ë§ì¶°ë¼.");
  }

  async function stopCamera() {
    try { if (video) video.pause(); } catch {}
    try {
      if (stream) for (const t of stream.getTracks()) t.stop();
    } catch {}
    stream = null;
  }

  // ===== ìº¡ì²˜ =====
  function captureFrame() {
    const w = video.videoWidth;
    const h = video.videoHeight;
    if (!w || !h) return "";
    const canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    const ctx = canvas.getContext("2d");
    ctx.drawImage(video, 0, 0, w, h);
    return canvas.toDataURL("image/jpeg", 0.92);
  }

  // ===== OCR í˜¸ì¶œ =====
  async function callOCR(page, shot, imageDataUrl) {
    const payload = { pageIndex: page, language: OCR_LANG, imageBase64: imageDataUrl };

    const r = await fetch("/.netlify/functions/ocr", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch {}
    if (!r.ok || !j || !j.ok) {
      const detail = j?.detail ? ` / ${j.detail}` : (j?.error ? ` / ${j.error}` : "");
      throw new Error(`OCR HTTP ${r.status}${detail}`);
    }
    return j; // {ok:true, text, conf}
  }

  function isDoneText(text) {
    if (!text) return false;
    if (/\bDONE\b/.test(text)) return true;
    if (/ì´¬ì˜\s*ì™„ë£Œ/i.test(text)) return true;
    return false;
  }

  function looksLikeQuestions(text) {
    if (!text) return false;
    if (/\b\d{1,2}\.\s/.test(text)) return true;
    if (/[â‘ â‘¡â‘¢â‘£â‘¤]/.test(text)) return true;
    if (/\([a-eA-E]\)/.test(text)) return true;
    return false;
  }

  // ===== ìë™ OCR ë£¨í”„ =====
  async function runAuto() {
    running = true;
    btnAuto.disabled = true;
    btnStop.disabled = false;
    pages.length = 0;
    ocrBox.value = "";
    ansBox.value = "";
    logEl.textContent = "";

    try {
      log("AUTO START");
      await startCamera();

      setUIState("READY");
      setStatus("3ì´ˆ ë’¤ì— OCRì„ ì‹œì‘í•œë‹¤. í”ë“¤ì§€ ë§ê³  ì ê¹ ë©ˆì¶°ë¼.");
      speak("3ì´ˆ ë’¤ì— ì‹œì‘í•œë‹¤.", 1.0);
      await countdown(3);

      for (let page = 1; page <= MAX_PAGES && running; page++) {
        setUIState("OCRING", page);
        setStatus(`í˜ì´ì§€ ${page} OCR ì¤‘ì´ë‹¤. í”ë“¤ì§€ ë§ê³  ë©ˆì¶°ë¼.`);
        log(`PAGE ${page} START`);

        let best = { text:"", conf: -1, imageDataUrl:"" };
        let retakes = 0;

        while (retakes <= MAX_RETAKES && running) {
          const results = [];

          for (let shot = 1; shot <= SHOTS_PER_PAGE && running; shot++) {
            setUIState("OCRING", page, shot);
            await wait(AF_WAIT_MS);

            const dataUrl = captureFrame();
            lastShotImg.src = dataUrl;

            if (!dataUrl || !dataUrl.startsWith("data:image")) {
              log(`CAPTURE FAIL page=${page} shot=${shot} (empty dataUrl)`);
              continue;
            }

            try {
              const res = await callOCR(page, shot, dataUrl);
              const txt = (res.text || "").trim();
              const conf = Number(res.conf || 0);
              results.push({ text: txt, conf, imageDataUrl: dataUrl });
              log(`OCR OK page=${page} shot=${shot} conf=${conf} len=${txt.length}`);
            } catch (e) {
              log(`OCR FAIL page=${page} shot=${shot} :: ${e.message}`);
            }
          }

          for (const r of results) {
            const score = (r.conf || 0) + Math.min(r.text.length, 800) / 20;
            const bestScore = (best.conf || 0) + Math.min(best.text.length, 800) / 20;
            if (score > bestScore) best = r;
          }

          if (isDoneText(best.text)) {
            log(`DONE DETECTED at page ${page}`);
            pages.push({ page, text: best.text, conf: best.conf, imageDataUrl: best.imageDataUrl });
            ocrBox.value += `\n[PAGE ${page}]\n${best.text}\n`;
            speak("ì´¬ì˜ì´ ì™„ë£Œë˜ì—ˆë‹¤. ì´ì œ ìë™ìœ¼ë¡œ ë¬¸ì œë¥¼ í‘¼ë‹¤.", 1.0);
            break;
          }

          if (!best.text || best.text.length < MIN_TEXT_LEN) {
            retakes++;
            if (retakes <= MAX_RETAKES) {
              setStatus(`í˜ì´ì§€ ${page} ì¸ì‹ì´ ì•½í•˜ë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ë¼. (${retakes}/${MAX_RETAKES})`);
              speak("ì¸ì‹ì´ ì•½í•˜ë‹¤. ê°™ì€ í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ì´¬ì˜í•´ë¼.", 1.0);
              continue;
            } else {
              log(`[PAGE ${page}] FORCE-ACCEPT (low text, retakes exceeded)`);
            }
          }

          pages.push({ page, text: best.text, conf: best.conf, imageDataUrl: best.imageDataUrl });
          ocrBox.value += `\n[PAGE ${page}]\n${best.text}\n`;

          setStatus(`í˜ì´ì§€ ${page} ì¸ì‹ ì™„ë£Œë‹¤. ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ì¤˜ë¼. ${NEXT_PAGE_DELAY}ì´ˆ ë’¤ì— ë‹¤ìŒ í˜ì´ì§€ë¡œ ë„˜ì–´ê°„ë‹¤.`);
          speak(`ë‹¤ìŒ í˜ì´ì§€ë¥¼ ë³´ì—¬ì¤˜ë¼. ${NEXT_PAGE_DELAY}ì´ˆ ë’¤ì— ì¸ì‹í•œë‹¤.`, 1.0);
          await countdown(NEXT_PAGE_DELAY);
          break;
        }

        if (pages.length && isDoneText(pages[pages.length-1].text)) break;
      }

      if (!running) throw new Error("USER_STOP");

      if (!pages.some(p => isDoneText(p.text))) {
        log("FATAL :: DONE not detected within MAX_PAGES");
        setStatus("DONEì„ ì°¾ì§€ ëª»í–ˆë‹¤. ë§ˆì§€ë§‰ í˜ì´ì§€ì— DONEì„ í¬ê²Œ ì“°ê³  ë‹¤ì‹œ ì‹¤í–‰í•´ë¼.");
        speak("DONEì„ ì°¾ì§€ ëª»í–ˆë‹¤. ë§ˆì§€ë§‰ í˜ì´ì§€ì— DONEì„ í¬ê²Œ ì“°ê³  ë‹¤ì‹œ ì‹¤í–‰í•´ë¼.", 1.0);
        throw new Error("DONE_NOT_FOUND");
      }

      await solveAll();

      setUIState("DONE");
      setStatus("ì „ì²´ ê³¼ì •ì´ ëë‚¬ë‹¤.");
      btnStop.disabled = true;
      btnAuto.disabled = false;
      running = false;

    } catch (e) {
      if (String(e.message) === "USER_STOP") {
        setStatus("ì‚¬ìš©ìê°€ ì¤‘ì§€í–ˆë‹¤.");
      } else {
        setStatus(`ì˜¤ë¥˜ë‹¤: ${e.message}`);
      }
      setUIState("ERROR");
      btnStop.disabled = true;
      btnAuto.disabled = false;
      running = false;
      await stopCamera();
    }
  }

  // ===== í’€ì´ =====
  async function solvePage(p) {
    const payload = { page: p.page, ocrText: p.text || "", imageDataUrl: USE_VISION_SOLVE ? (p.imageDataUrl || "") : "" };

    const r = await fetch("/.netlify/functions/solve", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload)
    });

    const t = await r.text();
    let j = null;
    try { j = JSON.parse(t); } catch {}
    if (!r.ok || !j || !j.ok) {
      const detail = j?.detail ? ` / ${j.detail}` : "";
      throw new Error(`SOLVE HTTP ${r.status}${detail}`);
    }
    return j;
  }

  async function solveAll() {
    setUIState("SOLVING");
    setStatus("ìë™ í’€ì´ ì¤‘ì´ë‹¤.");
    log("SOLVE START");

    const answers = new Map();

    for (const p of pages) {
      if (!looksLikeQuestions(p.text)) {
        log(`SOLVE SKIP page=${p.page} (no question patterns)`);
        continue;
      }

      setStatus(`í˜ì´ì§€ ${p.page} í’€ì´ ì¤‘ì´ë‹¤.`);
      log(`SOLVE page=${p.page} START`);

      let ok = false;
      for (let attempt = 1; attempt <= 2; attempt++) {
        try {
          const res = await solvePage(p);
          const arr = Array.isArray(res.answers) ? res.answers : [];
          for (const it of arr) {
            if (it && Number.isFinite(Number(it.q)) && Number.isFinite(Number(it.a))) {
              const q = Number(it.q), a = Number(it.a);
              if (a >= 1 && a <= 5) answers.set(q, a);
            }
          }
          log(`SOLVE page=${p.page} OK answers=${arr.length}`);
          ok = true;
          break;
        } catch (e) {
          log(`SOLVE page=${p.page} FAIL attempt=${attempt} :: ${e.message}`);
          if (attempt === 2) speak(`í˜ì´ì§€ ${p.page} í’€ì´ì— ì‹¤íŒ¨í–ˆë‹¤. ë‹¤ì‹œ ì´¬ì˜í•´ë¼.`, 1.0);
          else await wait(300);
        }
      }
      if (!ok) break;
    }

    const list = [...answers.entries()].sort((a,b)=>a[0]-b[0]).map(([q,a]) => `${q}ë²ˆ ${a}ë²ˆ`).join("\n");
    ansBox.value = list || "ì •ë‹µì„ ì¶”ì¶œí•˜ì§€ ëª»í–ˆë‹¤.";

    if (list) {
      const speech = [...answers.entries()].sort((a,b)=>a[0]-b[0]).map(([q,a]) => `${q}ë²ˆ ${a}ë²ˆ`).join(", ");
      speak("ì •ë‹µì„ ë§í•œë‹¤.", 1.0);
      speak(speech, 0.95);
    } else {
      speak("ì •ë‹µì„ ë§Œë“¤ì§€ ëª»í–ˆë‹¤.", 1.0);
    }

    log("SOLVE END");
  }

  btnAuto.addEventListener("click", () => runAuto());
  btnStop.addEventListener("click", async () => {
    running = false;
    btnStop.disabled = true;
    btnAuto.disabled = false;
    setUIState("STOPPED");
    setStatus("ì¤‘ì§€ ì¤‘ì´ë‹¤.");
    speak("ì¤‘ì§€í•œë‹¤.", 1.0);
    await stopCamera();
  });

  document.addEventListener("visibilitychange", () => {
    if (document.hidden && running) log("VISIBILITY hidden (iOS may pause camera/audio)");
  });
})();
</script>
</body>
</html>

