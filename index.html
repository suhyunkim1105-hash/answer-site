<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>OCR 누적 테스트</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
      color: #111;
    }
    .wrap {
      max-width: 900px;
      margin: 0 auto;
      padding: 16px;
    }
    h1 {
      font-size: 26px;
      margin: 8px 0 12px;
      font-weight: 800;
    }
    .card {
      background: #fff;
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.06);
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }
    label {
      font-size: 13px;
      color: #444;
      min-width: 90px;
    }
    input[type="number"],
    input[type="text"] {
      padding: 6px 10px;
      border-radius: 10px;
      border: 1px solid #ccc;
      font-size: 14px;
      width: 90px;
    }
    input[type="number"]:focus,
    input[type="text"]:focus {
      outline: none;
      border-color: #111;
    }
    button {
      border: none;
      border-radius: 16px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: transform 0.05s ease, box-shadow 0.1s ease, background 0.1s ease;
    }
    button:active {
      transform: translateY(1px);
      box-shadow: none;
    }
    #btnAudio { background: #111; color:#fff; }
    #btnStart { background: #111; color:#fff; }
    #btnStop { background: #b00020; color:#fff; }
    button:disabled {
      opacity: 0.4;
      cursor: default;
    }
    .toggle-row {
      font-size: 13px;
      gap: 4px;
    }
    .toggle-row input {
      width: auto;
    }
    video {
      width: 100%;
      border-radius: 14px;
      background: #000;
    }
    .status-line {
      font-size: 13px;
      margin-top: 6px;
      line-height: 1.4;
      white-space: pre-line;
    }
    pre {
      background: #111;
      color: #e3e3e3;
      border-radius: 14px;
      padding: 10px;
      font-size: 12px;
      overflow: auto;
      max-height: 260px;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    textarea {
      width: 100%;
      min-height: 220px;
      max-height: 520px;
      border-radius: 14px;
      border: 1px solid #ccc;
      padding: 10px;
      font-size: 12px;
      resize: vertical;
      white-space: pre-wrap;
    }
    .section-title {
      font-size: 15px;
      font-weight: 700;
      margin-bottom: 6px;
    }
    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: #111;
      color: #fff;
      font-size: 11px;
      margin-right: 4px;
    }
    .small {
      font-size: 11px;
      color: #666;
    }
  </style>
</head>
<body>
<div class="wrap">
  <div style="margin-bottom:8px; font-size:14px; font-weight:600;">1:06</div>
  <h1>OCR 누적 테스트</h1>

  <!-- 컨트롤 카드 -->
  <div class="card">
    <div class="row">
      <button id="btnAudio">오디오 활성화(1회)</button>
      <button id="btnStart">시작</button>
      <button id="btnStop" disabled>중지</button>
    </div>

    <div class="row">
      <label for="startPageInput">시작 페이지</label>
      <input id="startPageInput" type="number" value="1" min="1" />
      <label for="shotsPerPageInput">샷/페이지</label>
      <input id="shotsPerPageInput" type="number" value="3" min="1" />
    </div>
    <div class="row">
      <label for="countdownInput">카운트다운(초)</label>
      <input id="countdownInput" type="number" value="5" min="0" />
      <label for="maxPageInput">최대 페이지</label>
      <input id="maxPageInput" type="number" placeholder="비우면 DONE까지" min="1" />
    </div>
    <div class="row">
      <label for="maxWidthInput">최대 가로(px)</label>
      <input id="maxWidthInput" type="number" value="2000" min="600" />
      <label for="jpegQualityInput">JPEG 품질(0~1)</label>
      <input id="jpegQualityInput" type="number" value="0.9" min="0.1" max="1" step="0.05" />
    </div>

    <div class="row toggle-row">
      <label>
        <input id="optStatusTTS" type="checkbox" checked />
        화면에 “페이지/샷/진행상태” 표시 + TTS로 넘겨라/카운트다운/완료/종료 안내
      </label>
    </div>

    <div class="row toggle-row">
      <label>
        <input id="optBestOnly" type="checkbox" checked />
        페이지당 3샷 OCR 후 “가장 좋은 1개” 자동 채택
      </label>
    </div>
  </div>

  <!-- 카메라 & 상태 -->
  <div class="card">
    <div class="section-title">카메라 프리뷰</div>
    <video id="video" autoplay playsinline muted></video>
    <div class="status-line" id="summaryStatus">
      실행중: N / 총 OCR 호출: 0 / 완료 페이지: 0 / 단계: 대기
    </div>
    <div class="status-line" id="pageShotStatus">
      현재: 페이지 - / 샷 -
    </div>
    <div class="status-line small" id="extraStatus"></div>
  </div>

  <!-- 로그 -->
  <div class="card">
    <div class="section-title">로그</div>
    <pre id="log"></pre>
  </div>

  <!-- 누적 OCR 텍스트 -->
  <div class="card">
    <div class="section-title">누적 OCR 텍스트 (베스트만)</div>
    <textarea id="bestTextArea" readonly></textarea>
  </div>

  <!-- 정답/풀이 -->
  <div class="card">
    <div class="row" style="justify-content:space-between; align-items:center;">
      <div class="section-title">자동 풀이 결과</div>
      <button id="btnSolve" disabled>문제 풀이 실행</button>
    </div>
    <div class="small" style="margin-bottom:4px;">
      OCR가 끝난 뒤 누적 텍스트를 <code>/.netlify/functions/solve</code>로 보내서 정답/풀이를 받는다.
    </div>
    <pre id="answerArea"></pre>
  </div>
</div>

<script>
  window.addEventListener('DOMContentLoaded', () => {
    // --- DOM 참조 ---
    const btnAudio = document.getElementById('btnAudio');
    const btnStart = document.getElementById('btnStart');
    const btnStop = document.getElementById('btnStop');
    const startPageInput = document.getElementById('startPageInput');
    const shotsPerPageInput = document.getElementById('shotsPerPageInput');
    const countdownInput = document.getElementById('countdownInput');
    const maxPageInput = document.getElementById('maxPageInput');
    const maxWidthInput = document.getElementById('maxWidthInput');
    const jpegQualityInput = document.getElementById('jpegQualityInput');
    const optStatusTTS = document.getElementById('optStatusTTS');
    const optBestOnly = document.getElementById('optBestOnly');
    const video = document.getElementById('video');
    const summaryStatus = document.getElementById('summaryStatus');
    const pageShotStatus = document.getElementById('pageShotStatus');
    const extraStatus = document.getElementById('extraStatus');
    const logEl = document.getElementById('log');
    const bestTextArea = document.getElementById('bestTextArea');
    const btnSolve = document.getElementById('btnSolve');
    const answerArea = document.getElementById('answerArea');

    // --- 상태 변수 ---
    let mediaStream = null;
    let running = false;
    let speechEnabled = false;
    let totalOcrCalls = 0;
    let pagesCompleted = 0;
    let combinedBestText = "";
    let currentStep = "대기";

    // --- 유틸 ---
    const sleep = (ms) => new Promise(res => setTimeout(res, ms));

    function nowTime() {
      const d = new Date();
      const h = String(d.getHours()).padStart(2, "0");
      const m = String(d.getMinutes()).padStart(2, "0");
      const s = String(d.getSeconds()).padStart(2, "0");
      return `${h}:${m}:${s}`;
    }

    function logLine(msg) {
      logEl.textContent += `[${nowTime()}] ${msg}\n`;
      logEl.scrollTop = logEl.scrollHeight;
    }

    function updateSummary(step) {
      if (step) currentStep = step;
      summaryStatus.textContent =
        `실행중: ${running ? "Y" : "N"} / 총 OCR 호출: ${totalOcrCalls} / 완료 페이지: ${pagesCompleted} / 단계: ${currentStep}`;
    }

    function updatePageShotDisplay(page, shot, countdownSec) {
      pageShotStatus.textContent = `현재: 페이지 ${page} / 샷 ${shot}`;
      if (typeof countdownSec === "number") {
        extraStatus.textContent = countdownSec > 0
          ? `페이지 ${page}의 샷 ${shot} 촬영까지 ${countdownSec}초`
          : "";
      }
    }

    function clearSpeechQueue() {
      if ("speechSynthesis" in window) {
        window.speechSynthesis.cancel();
      }
    }

    function speakIfEnabled(text) {
      if (!speechEnabled) return Promise.resolve();
      if (!("speechSynthesis" in window)) return Promise.resolve();
      return new Promise((resolve) => {
        const u = new SpeechSynthesisUtterance(text);
        u.lang = "ko-KR";
        u.onend = resolve;
        u.onerror = resolve;
        window.speechSynthesis.speak(u);
      });
    }

    async function ensureCamera() {
      if (mediaStream) return;
      try {
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "environment" },
          audio: false
        });
        video.srcObject = mediaStream;
        logLine("카메라 OK");
      } catch (e) {
        logLine("카메라 오류: " + (e.message || e));
        alert("카메라를 켤 수 없습니다: " + (e.message || e));
        throw e;
      }
    }

    function stopCamera() {
      if (mediaStream) {
        mediaStream.getTracks().forEach(t => t.stop());
        mediaStream = null;
      }
    }

    // --- 이미지 캡처 + 리사이즈 후 OCR 호출 ---
    async function captureAndOcr(page, shot) {
      if (!mediaStream) return "";
      const videoTrack = mediaStream.getVideoTracks()[0];
      const settings = videoTrack.getSettings();
      const vw = video.videoWidth || settings.width || 1280;
      const vh = video.videoHeight || settings.height || 720;

      const maxWidth = Number(maxWidthInput.value) || 2000;
      const scale = vw > maxWidth ? maxWidth / vw : 1;
      const cw = Math.round(vw * scale);
      const ch = Math.round(vh * scale);

      const canvas = document.createElement("canvas");
      canvas.width = cw;
      canvas.height = ch;
      const ctx = canvas.getContext("2d");

      // 중앙 90% 영역만 사용 (가벼운 크롭)
      const cropMarginX = vw * 0.05;
      const cropMarginY = vh * 0.05;
      const sx = cropMarginX;
      const sy = cropMarginY;
      const sw = vw - cropMarginX * 2;
      const sh = vh - cropMarginY * 2;

      ctx.drawImage(video, sx, sy, sw, sh, 0, 0, cw, ch);

      const quality = Math.min(1, Math.max(0.1, Number(jpegQualityInput.value) || 0.9));
      const dataUrl = canvas.toDataURL("image/jpeg", quality);
      const base64 = dataUrl.split(",")[1];

      const payload = { imageBase64: base64 };
      try {
        const resp = await fetch("/.netlify/functions/ocr", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        const raw = await resp.text();
        let text = "";
        try {
          const parsed = JSON.parse(raw);
          text = (parsed && parsed.text) || "";
        } catch {
          text = raw || "";
        }

        totalOcrCalls += 1;
        const len = (text || "").length;
        const score = len; // 지금은 길이를 점수로 사용
        logLine(`OCR OK page=${page} shot=${shot} len=${len} score=${score}`);

        return { text, len, score };
      } catch (e) {
        logLine(`OCR 에러 page=${page} shot=${shot}: ${e.message || e}`);
        return { text: "", len: 0, score: 0 };
      }
    }

    async function captureWithCountdown(page, shot, countdownSec) {
      const cd = countdownSec > 0 ? countdownSec : 0;
      updatePageShotDisplay(page, shot, cd);

      if (cd > 0) {
        if (optStatusTTS.checked) {
          const nums = Array.from({ length: cd }, (_, i) => cd - i).join(", ");
          await speakIfEnabled(`${page}페이지, ${cd}초 뒤에 촬영을 시작합니다. ${nums}`);
        }
        for (let t = cd; t > 0 && running; t--) {
          updatePageShotDisplay(page, shot, t);
          await sleep(1000);
        }
      }

      if (!running) return { text: "", len: 0, score: 0 };

      extraStatus.textContent = `페이지 ${page}의 샷 ${shot} 촬영 중...`;
      const result = await captureAndOcr(page, shot);
      extraStatus.textContent = "";
      return result;
    }

    function hasDoneKeyword(text) {
      return /\bDONE\b/i.test(text || "");
    }

    // --- 메인 OCR 루프 ---
    async function runOcrLoop() {
      await ensureCamera();

      const startPage = Number(startPageInput.value) || 1;
      const shotsPerPage = Math.max(1, Number(shotsPerPageInput.value) || 3);
      const countdownSec = Math.max(0, Number(countdownInput.value) || 0);
      const maxPageValue = Number(maxPageInput.value) || null;

      let page = startPage;
      combinedBestText = "";
      bestTextArea.value = "";
      pagesCompleted = 0;
      updateSummary("OCR 시작");

      while (running) {
        if (maxPageValue && page > maxPageValue) {
          logLine("최대 페이지 도달 → 자동 종료");
          break;
        }

        let bestResult = { text: "", len: 0, score: -1, shot: 0 };

        for (let shot = 1; shot <= shotsPerPage && running; shot++) {
          updatePageShotDisplay(page, shot, countdownSec);
          const result = await captureWithCountdown(page, shot, countdownSec);
          if (!running) break;

          if (!optBestOnly.checked) {
            // 필요하면 여기서 모든 샷을 누적하는 로직 추가
          }

          if (result.score > bestResult.score) {
            bestResult = { ...result, shot };
          }
        }

        if (!running) break;

        pagesCompleted += 1;
        logLine(`페이지 ${page} 완료 (best shot=${bestResult.shot}, score=${bestResult.score})`);

        if (bestResult.text && bestResult.text.trim()) {
          combinedBestText += `\n[PAGE ${page}]\n${bestResult.text.trim()}\n`;
          bestTextArea.value = combinedBestText.trim();
        }

        updateSummary("페이지 완료");

        if (hasDoneKeyword(bestResult.text)) {
          logLine(`DONE detected on page=${page}. 이제 자동 풀이로 넘어간다.`);
          if (optStatusTTS.checked) {
            await speakIfEnabled("DONE이 감지되었습니다. OCR를 자동으로 종료합니다.");
          }
          break;
        }

        page += 1;
      }

      running = false;
      btnStart.disabled = false;
      btnStop.disabled = true;
      updateSummary("종료");
      stopCamera();

      if (combinedBestText.trim()) {
        btnSolve.disabled = false;
        if (optStatusTTS.checked) {
          await speakIfEnabled("OCR가 모두 끝났습니다. 이제 문제 풀이를 시작할 수 있습니다.");
        }
      } else {
        btnSolve.disabled = true;
      }
    }

    // --- 정답 풀이 호출 ---
    async function runSolve() {
      const text = (combinedBestText || bestTextArea.value || "").trim();
      if (!text) {
        alert("먼저 OCR을 실행해서 텍스트를 만들어야 합니다.");
        return;
      }

      clearSpeechQueue();
      if (speechEnabled) {
        speakIfEnabled("이제 문제 풀이를 시작합니다.");
      }

      btnSolve.disabled = true;
      answerArea.textContent = "문제 풀이 중...";

      try {
        const resp = await fetch("/.netlify/functions/solve", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ text })
        });
        const raw = await resp.text();
        let resultText = raw;

        try {
          const parsed = JSON.parse(raw);
          if (parsed && (parsed.answer || parsed.text || parsed.result)) {
            resultText = parsed.answer || parsed.text || parsed.result;
          }
        } catch {
          // 그냥 텍스트로 사용
        }

        answerArea.textContent = resultText || "(비어 있음)";

        // 정답 음성 안내
        if (speechEnabled && resultText) {
          const short = resultText.replace(/\s+/g, " ").slice(0, 800);
          await speakIfEnabled("정답을 읽겠습니다.");
          await speakIfEnabled(short);
        }
      } catch (e) {
        answerArea.textContent = "풀이 중 오류: " + (e.message || e);
      } finally {
        btnSolve.disabled = false;
      }
    }

    // --- 이벤트 바인딩 ---
    btnAudio.addEventListener("click", async () => {
      speechEnabled = true;
      clearSpeechQueue();
      await speakIfEnabled("오디오 안내가 활성화되었습니다.");
      logLine("오디오 안내 활성화");
    });

    btnStart.addEventListener("click", async () => {
      if (running) return;
      running = true;
      totalOcrCalls = 0;
      pagesCompleted = 0;
      currentStep = "준비";
      extraStatus.textContent = "";
      logLine("AUTO START");
      updateSummary();

      btnStart.disabled = true;
      btnStop.disabled = false;
      clearSpeechQueue();
      if (optStatusTTS.checked) {
        speakIfEnabled("OCR 자동 촬영을 시작합니다.");
      }

      try {
        await runOcrLoop();
      } catch (e) {
        running = false;
        btnStart.disabled = false;
        btnStop.disabled = true;
        stopCamera();
        updateSummary("에러로 종료");
        logLine("OCR 루프 에러: " + (e.message || e));
      }
    });

    btnStop.addEventListener("click", () => {
      if (!running) return;
      running = false;
      logLine("STOP 요청");
      if (optStatusTTS.checked) {
        clearSpeechQueue();
        speakIfEnabled("사용자에 의해 OCR가 중지되었습니다.");
      }
      // 카메라 종료 및 정리는 runOcrLoop 끝에서 처리
    });

    btnSolve.addEventListener("click", () => {
      runSolve();
    });

    // 초기 상태 표시
    updateSummary();
  });
</script>
</body>
</html>
