<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Reader</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 16px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; margin: 12px 0; }
    button { padding: 10px 12px; border-radius: 10px; border: 1px solid #ccc; background: #fff; }
    button.primary { background: #111; color: #fff; border-color: #111; }
    pre { white-space: pre-wrap; word-break: break-word; margin: 0; }
    .muted { color:#666; font-size:13px; }
    .ok { color:#16a34a; font-weight:700; }
  </style>
</head>
<body>
  <h2>ì •ë‹µ ë¦¬ë” (ìë™ 4íšŒ ë‚­ë…)</h2>

  <div class="card">
    <button id="btnUnlock" class="primary">ğŸ”Š ìŒì„± ì‹œì‘(1íšŒ í´ë¦­)</button>
    <div id="ttsState" class="muted" style="margin-top:8px;">ì•„ì§ ìŒì„± ê¶Œí•œì´ í™œì„±í™”ë˜ì§€ ì•ŠìŒ</div>
  </div>

  <div class="card">
    <h3>ì •ë‹µ</h3>
    <pre id="out" class="muted">ì•„ì§ ì •ë‹µ ì—†ìŒ</pre>
  </div>

<script>
(() => {
  const out = document.getElementById("out");
  const btnUnlock = document.getElementById("btnUnlock");
  const ttsState = document.getElementById("ttsState");

  const bc = new BroadcastChannel("answers_channel");

  let unlocked = false;
  let pendingSpeakText = null;

  function formatAnswers(ansObj) {
    // ansObj: {answers:{ "1":"A"...}}
    const m = ansObj?.answers || {};
    const keys = Object.keys(m).sort((a,b)=>Number(a)-Number(b));
    return keys.map(k => `${k}ë²ˆ: ${String(m[k]).toUpperCase()}`).join("\n");
  }

  function speakRepeated(text, times = 4) {
    if (!unlocked) {
      pendingSpeakText = text;
      return;
    }
    if (!("speechSynthesis" in window)) {
      ttsState.textContent = "ì´ ë¸Œë¼ìš°ì €ëŠ” speechSynthesis(TTS)ë¥¼ ì§€ì›í•˜ì§€ ì•ŠìŒ";
      return;
    }
    window.speechSynthesis.cancel();

    let i = 0;
    const speakOnce = () => {
      i++;
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "ko-KR";
      u.rate = 1.0;
      u.pitch = 1.0;
      u.onend = () => {
        if (i < times) speakOnce();
      };
      window.speechSynthesis.speak(u);
    };
    speakOnce();
  }

  function renderPayload(payload) {
    const ansObj = payload?.answers;
    if (!ansObj || !ansObj.answers) return;

    const text = formatAnswers(ansObj);
    out.textContent = text;
    out.className = "ok";

    ttsState.textContent = unlocked ? "ìŒì„± í™œì„±í™”ë¨ â†’ 4íšŒ ë‚­ë… ì¤‘" : "ì •ë‹µ ìˆ˜ì‹ ë¨(ìŒì„± ì‹œì‘ ë²„íŠ¼ì„ ëˆŒëŸ¬ì•¼ ë‚­ë…ë¨)";
    speakRepeated(text, 4);
  }

  // ë²„íŠ¼ 1íšŒ í´ë¦­ìœ¼ë¡œ iOS TTS ê¶Œí•œ íŠ¸ë¦¬ê±°
  btnUnlock.onclick = () => {
    unlocked = true;
    ttsState.textContent = "ìŒì„± í™œì„±í™”ë¨";
    // ë¬´ìŒ(ì§§ì€) ë°œí™”ë¡œ unlock ê°•í™”
    try {
      const u = new SpeechSynthesisUtterance(" ");
      u.lang = "ko-KR";
      window.speechSynthesis.speak(u);
    } catch(e) {}
    if (pendingSpeakText) {
      const t = pendingSpeakText;
      pendingSpeakText = null;
      speakRepeated(t, 4);
    }
  };

  // ë¸Œë¡œë“œìºìŠ¤íŠ¸ ìˆ˜ì‹ 
  bc.onmessage = (ev) => {
    renderPayload(ev.data);
  };

  // ìƒˆë¡œê³ ì¹¨ ëŒ€ë¹„: localStorageì—ì„œ ë§ˆì§€ë§‰ ì •ë‹µ ë³µì›
  try {
    const s = localStorage.getItem("last_answers_payload");
    if (s) renderPayload(JSON.parse(s));
  } catch(e) {}

})();
</script>
</body>
</html>
