<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>실시간 자동 (수신 → OCR → solve → TTS)</title>
  <style>
    :root { color-scheme: light dark; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans KR, sans-serif; padding:16px; max-width:980px; margin:0 auto; }
    h1 { margin:0 0 6px 0; font-size:20px; }
    .row { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:10px 0; }
    input, button, select { padding:10px 12px; border-radius:10px; border:1px solid #ccc; }
    button { cursor:pointer; }
    video { width:100%; max-height:60vh; background:#000; border-radius:12px; }
    .panel { border:1px solid #e0e0e0; border-radius:12px; padding:12px; }
    .muted { color:#777; font-size:13px; }
    .out { white-space:pre-wrap; background:#f6f7f8; padding:10px; border-radius:10px; min-height:44px; }
    .pill { display:inline-flex; gap:6px; padding:6px 10px; border-radius:999px; border:1px solid #ddd; font-size:12px; }
    .video-wrap { position:relative; }
    label.small { font-size:12px; color:#666; }
    .ok { color:#0a7d2a; }
    .err { color:#b00020; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
</head>
<body>
  <h1>실시간 자동: 방송 수신 → OCR → solve → TTS</h1>
  <div class="muted">휴대폰에서 <code>broadcast.html</code>로 방송 시작 → 여기서 같은 Room ID로 수신하면, 화면 안정 시 자동으로 OCR→solve→TTS까지 실행한다.</div>

  <div class="panel">
    <div class="row">
      <input id="roomId" placeholder="Room ID (예: abc123)" />
      <button id="join">Join</button>
      <button id="leave" disabled>Leave</button>
      <label class="small" style="margin-left:auto">solve URL</label>
      <input id="apiUrl" style="min-width:360px" value="https://solve-bcpgmrhjuq-uc.a.run.app" />
    </div>
    <div id="status" class="muted">idle</div>
  </div>

  <div class="video-wrap" style="margin:10px 0;">
    <video id="remote" playsinline autoplay muted></video>
  </div>

  <div class="panel">
    <div class="row" style="justify-content:space-between;">
      <span class="pill">자동 모드</span>
      <label class="small"><input type="checkbox" id="auto" checked> 화면이 안정되면 자동으로 OCR→solve→TTS</label>
    </div>
    <div class="row" style="gap:18px; align-items:flex-end;">
      <div>
        <label class="small">안정 판단 임계치</label><br>
        <input id="thr" type="range" min="0.03" max="0.40" step="0.01" value="0.30">
        <div class="muted">현재: <span id="thrLbl">0.30</span></div>
      </div>
      <div>
        <label class="small">체크 간격(ms)</label><br>
        <input id="interval" type="range" min="200" max="1500" step="50" value="900">
        <div class="muted">현재: <span id="intervalLbl">900</span> ms</div>
      </div>
      <div>
        <label class="small">안정 지속(s)</label><br>
        <input id="stable" type="range" min="1" max="8" step="1" value="2">
        <div class="muted">현재: <span id="stableLbl">2</span> s</div>
      </div>
      <div>
        <label class="small">쿨다운(s)</label><br>
        <input id="cool" type="range" min="5" max="30" step="1" value="6">
        <div class="muted">현재: <span id="coolLbl">6</span> s</div>
      </div>
    </div>
    <div id="ocrStatus" class="muted" style="margin-top:6px"></div>
    <div class="out" id="answer"></div>
  </div>

<script type="module">
  // ===== Firebase RTDB (viewer.html과 동일 설정) =====
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-app.js";
  import { getDatabase, ref, set, remove, onValue, onChildAdded, push } from "https://www.gstatic.com/firebasejs/10.12.5/firebase-database.js";

  const firebaseConfig = {
    apiKey: "AIzaSyAvjpHfmbuHQq3ZeV6mNKQFI9LsnX-vf68",
    authDomain: "answer-site-p2p.firebaseapp.com",
    databaseURL: "https://answer-site-p2p-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "answer-site-p2p",
    storageBucket: "answer-site-p2p.firebasestorage.app",
    messagingSenderId: "364227113735",
    appId: "1:364227113735:web:b18355cf0b16454663cba2",
    measurementId: "G-C8MRHK5ZGS"
  };
  const app = initializeApp(firebaseConfig);
  const db  = getDatabase(app);

  const roomInp = document.getElementById('roomId');
  const joinBtn = document.getElementById('join');
  const leaveBtn= document.getElementById('leave');
  const apiUrl  = document.getElementById('apiUrl');
  const statusEl= document.getElementById('status');
  const videoEl = document.getElementById('remote');
  const ansOut  = document.getElementById('answer');
  const ocrStatus = document.getElementById('ocrStatus');

  function log(s){ statusEl.textContent = s; console.log('[AUTO]', s); }

  let pc, remoteStream, roomRef;

  async function join(){
    const id = roomInp.value.trim();
    if(!id){ alert('Room ID를 입력하세요'); return; }
    roomRef = ref(db, `webrtc/${id}`);

    const offerSnap = await new Promise(resolve => {
      onValue(ref(db, `webrtc/${id}/offer`), s => resolve(s), { onlyOnce:true });
    });
    const offer = offerSnap.val();
    if(!offer){ alert('방송이 아직 시작 안 됨 (휴대폰에서 broadcast.html → Start)'); return; }

    pc = new RTCPeerConnection({
      iceServers: [
        { urls: ['stun:stun.l.google.com:19302'] },
        { urls: 'turn:openrelay.metered.ca:80', username: 'openrelayproject', credential: 'openrelayproject' }
      ]
    });
    pc.onconnectionstatechange = () => log(`pc: ${pc.connectionState}`);
    pc.oniceconnectionstatechange = () => log(`ice: ${pc.iceConnectionState}`);

    remoteStream = new MediaStream();
    videoEl.srcObject = remoteStream; videoEl.muted = true; videoEl.playsInline = true;

    pc.ontrack = (e) => {
      e.streams[0].getTracks().forEach(t => remoteStream.addTrack(t));
      videoEl.play().catch(()=>{});
      log('track added');
    };

    pc.onicecandidate = (e) => {
      if (e.candidate) push(ref(db, `webrtc/${id}/answerCandidates`), e.candidate.toJSON());
    };

    await pc.setRemoteDescription(new RTCSessionDescription(offer));
    const answer = await pc.createAnswer();
    await pc.setLocalDescription(answer);
    await set(ref(db, `webrtc/${id}/answer`), answer);
    log('answer published');

    onChildAdded(ref(db, `webrtc/${id}/offerCandidates`), (snap)=>{
      const c = snap.val();
      if (c) pc.addIceCandidate(new RTCIceCandidate(c)).catch(()=>{});
    });

    joinBtn.disabled = true; leaveBtn.disabled = false; roomInp.disabled = true;
    window.onbeforeunload = cleanup;
  }

  async function cleanup(){
    try { await remove(ref(db, `webrtc/${roomInp.value}/answer`)); } catch {}
    try { pc?.close(); } catch {}
    joinBtn.disabled = false; leaveBtn.disabled = true; roomInp.disabled = false;
    log('left');
  }
  function leave(){ cleanup(); }

  joinBtn.onclick = join; leaveBtn.onclick = leave;

  // ===== 안정도 측정 & 자동 OCR → solve → TTS =====
  const autoChk = document.getElementById('auto');
  const thr = document.getElementById('thr');
  const thrLbl = document.getElementById('thrLbl');
  const interval = document.getElementById('interval');
  const intervalLbl = document.getElementById('intervalLbl');
  const stable = document.getElementById('stable');
  const stableLbl = document.getElementById('stableLbl');
  const cool = document.getElementById('cool');
  const coolLbl = document.getElementById('coolLbl');

  function syncLabels(){
    thrLbl.textContent = parseFloat(thr.value).toFixed(2);
    intervalLbl.textContent = parseInt(interval.value,10);
    stableLbl.textContent = parseInt(stable.value,10);
    coolLbl.textContent = parseInt(cool.value,10);
  }
  [thr,interval,stable,cool].forEach(el=>el.addEventListener('input', syncLabels));
  syncLabels();

  const diffCanvas = document.createElement('canvas');
  const diffCtx = diffCanvas.getContext('2d');
  let lastImageData=null, ratioEMA=1, stableSince=0, cooldownUntil=0, loopId=null;

  function frameDiffRatio(){
    if(!videoEl.srcObject || !videoEl.videoWidth) return 1;
    const w=480, h=Math.round(w*(videoEl.videoHeight/videoEl.videoWidth));
    diffCanvas.width=w; diffCanvas.height=h;
    diffCtx.drawImage(videoEl,0,0,w,h);
    const cur=diffCtx.getImageData(0,0,w,h).data;
    let diff=0,total=0;
    if(!lastImageData){ lastImageData=cur; return 1; }
    for(let i=0;i<cur.length;i+=4){
      const Yr=0.299*cur[i]+0.587*cur[i+1]+0.114*cur[i+2];
      const Yo=0.299*lastImageData[i]+0.587*lastImageData[i+1]+0.114*lastImageData[i+2];
      const d=Math.abs(Yr-Yo); if(d>80) diff++; total++;
    }
    lastImageData=cur;
    const ratio = total? diff/total : 1;
    ratioEMA = 0.25*ratio + 0.75*ratioEMA;
    return ratioEMA;
  }

  function speak(text){
    if(!text) return;
    const u = new SpeechSynthesisUtterance(text);
    u.lang = 'ko-KR';
    window.speechSynthesis.cancel();
    window.speechSynthesis.speak(u);
  }

  async function captureSharp(){
    const vw=videoEl.videoWidth||1280, vh=videoEl.videoHeight||720;
    const tmp=document.createElement('canvas'); tmp.width=vw; tmp.height=vh;
    const tctx=tmp.getContext('2d',{willReadFrequently:true});
    let best=null, bestScore=-1;
    function lapVar(imgData){
      const d=imgData.data; const w=vw, h=vh; const gray=new Uint8ClampedArray(w*h);
      for(let i=0,j=0;i<d.length;i+=4,j++) gray[j]=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
      const k=[-1,-1,-1,-1,8,-1,-1,-1,-1];
      let sum=0,sum2=0,n=0; const idx=(x,y)=>y*w+x;
      for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
        let v=0,p=0; for(let ky=-1;ky<=1;ky++) for(let kx=-1;kx<=1;kx++) v += gray[idx(x+kx,y+ky)] * k[p++];
        v=Math.abs(v); sum+=v; sum2+=v*v; n++;
      }
      const mean=sum/n; return sum2/n - mean*mean;
    }
    for(let k=0;k<3;k++){
      tctx.drawImage(videoEl,0,0,vw,vh);
      const im=tctx.getImageData(0,0,vw,vh);
      const score=lapVar(im);
      if(score>bestScore){ bestScore=score; best=tmp.cloneNode(true); best.getContext('2d').drawImage(tmp,0,0); }
      await new Promise(r=>setTimeout(r,200));
    }
    return best;
  }

  function preprocess(src){
    const up=document.createElement('canvas');
    up.width=Math.min(src.width*2,2200); up.height=Math.min(src.height*2,2200);
    const c=up.getContext('2d',{willReadFrequently:true});
    c.imageSmoothingEnabled=true; c.drawImage(src,0,0,up.width,up.height);
    const {width:w,height:h}=up; const img=c.getImageData(0,0,w,h); const d=img.data; const g=new Uint8ClampedArray(w*h);
    for(let i=0,j=0;i<d.length;i+=4,j++) g[j]=0.299*d[i]+0.587*d[i+1]+0.114*d[i+2];
    const tile=32, C=8; // adaptive threshold
    for(let ty=0;ty<h;ty+=tile){
      for(let tx=0;tx<w;tx+=tile){
        let sum=0,cnt=0; for(let y=ty;y<Math.min(ty+tile,h);y++) for(let x=tx;x<Math.min(tx+tile,w);x++){ sum+=g[y*w+x]; cnt++; }
        const thr=sum/cnt - C;
        for(let y=ty;y<Math.min(ty+tile,h);y++) for(let x=tx;x<Math.min(tx+tile,w);x++){ const i=y*w+x; g[i]=g[i]>thr?255:0; }
      }
    }
    for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){ const i=y*w+x; const v=g[i]*1.5 - (g[i-1]+g[i+1]+g[i-w]+g[i+w])/4*0.5; g[i]=Math.max(0,Math.min(255,v)); }
    for(let i=0,j=0;j<g.length;i+=4,j++){ const val=g[j]; d[i]=d[i+1]=d[i+2]=val; d[i+3]=255; }
    c.putImageData(img,0,0); return up;
  }

  function answerOnly(text){
    if(!text) return '';
    const m = text.match(/(?:정답|answer)\s*[:：\-]?\s*([^\n]+)/i);
    if(m) return m[1].trim();
    return text.split(/\r?\n/)[0].trim();
  }

  async function runOnce(){
    try{
      ocrStatus.textContent = '프레임 캡처…';
      const best = await captureSharp();
      if(!best){ ocrStatus.textContent='캡처 실패'; return; }
      const pre = preprocess(best);
      ocrStatus.textContent = 'OCR 중…';
      const { data } = await Tesseract.recognize(pre, 'kor+eng', {
        langPath: 'https://tessdata.projectnaptha.com/4.0.0',
        tessedit_pageseg_mode: 6,
        preserve_interword_spaces: 1,
        user_defined_dpi: 300
      });
      let text = (data?.text || '').trim();
      if(!text){ ocrStatus.textContent='문자 인식 실패'; return; }
      ocrStatus.textContent = 'solve 호출…';
      const res = await fetch(apiUrl.value.trim(), { method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({ question: text }) });
      const ct = res.headers.get('content-type')||''; let ans='';
      if(ct.includes('application/json')){ const js=await res.json(); ans = js.answer ?? JSON.stringify(js); }
      else { const tx=await res.text(); try{ const js=JSON.parse(tx); ans = js.answer ?? tx; }catch{ ans=tx; } }
      ansOut.textContent = ans;
      const say = answerOnly(ans);
      speak(say||ans);
      ocrStatus.innerHTML = '<span class="ok">완료</span>';
    }catch(e){ console.error(e); ocrStatus.innerHTML = '<span class="err">에러: '+(e.message||e)+'</span>'; }
  }

  function startLoop(){ if(loopId) clearInterval(loopId); stableSince=0; cooldownUntil=0; lastImageData=null; ratioEMA=1;
    loopId = setInterval(async ()=>{
      const now = Date.now();
      if(now < cooldownUntil) { ocrStatus.textContent = `쿨다운… ${Math.ceil((cooldownUntil-now)/1000)}s`; return; }
      const ratio = frameDiffRatio();
      const TH = parseFloat(thr.value); const ST = parseInt(stable.value,10)*1000;
      if(ratio < TH){
        if(!stableSince) stableSince = now;
        const remain = Math.max(0, ST - (now - stableSince));
        ocrStatus.textContent = `안정 감지… ${Math.ceil(remain/1000)}s`;
        if(now - stableSince >= ST){
          await runOnce();
          cooldownUntil = Date.now() + parseInt(cool.value,10)*1000;
          stableSince = 0;
        }
      } else {
        stableSince = 0; ocrStatus.textContent = '움직임 감지';
      }
    }, parseInt(interval.value,10));
  }
  function stopLoop(){ if(loopId) clearInterval(loopId); loopId=null; }

  autoChk.addEventListener('change', ()=>{ if(autoChk.checked) startLoop(); else stopLoop(); });

  // 자동 루프는 스트림 연결 완료 후 시작
  const obs = new MutationObserver(()=>{
    if(videoEl.videoWidth>0 && autoChk.checked && !loopId) startLoop();
  });
  obs.observe(videoEl, { attributes:true, attributeFilter:['srcObject'] });
</script>
</body>
</html>
